<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhangQiang&#39;s blog</title>
  
  <subtitle>Follow ur heart.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-14T15:56:56.425Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhangqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单/双向绑定、组件通讯</title>
    <link href="http://yoursite.com/2018/06/14/ng%E8%8B%B1%E9%9B%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E6%A6%82%E5%BF%B5%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8D%95%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2018/06/14/ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单双向绑定、组件通讯/</id>
    <published>2018-06-14T15:53:27.723Z</published>
    <updated>2018-06-14T15:56:56.425Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/80698441" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="为什么要学angualr-4-0-？"><a href="#为什么要学angualr-4-0-？" class="headerlink" title="为什么要学angualr(4.0+)？"></a>为什么要学angualr(4.0+)？</h2><ol><li>无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。</li><li>微软收购了github，还不赶紧学ts？</li></ol><h2 id="本文参考博客-资料："><a href="#本文参考博客-资料：" class="headerlink" title="本文参考博客/资料："></a>本文参考博客/资料：</h2><p>1.<a href="https://blog.csdn.net/u012967849/article/details/78767294/" target="_blank" rel="noopener">https://blog.csdn.net/u012967849/article/details/78767294/</a> （ng父子组件如何传值）<br>2.<a href="https://www.angular.cn/" target="_blank" rel="noopener">https://www.angular.cn/</a> （ng中文官网）<br>3.<a href="https://www.jianshu.com/p/a2b625a99c8d" target="_blank" rel="noopener">https://www.jianshu.com/p/a2b625a99c8d</a> （ng的class和interface区别）</p><h2 id="本篇笔记所用环境及NG版本一览："><a href="#本篇笔记所用环境及NG版本一览：" class="headerlink" title="本篇笔记所用环境及NG版本一览："></a>本篇笔记所用环境及NG版本一览：</h2><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614211344486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="NG版本" title="" class="">                <p>NG版本</p>            </figure><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><strong>1.组件的文件形式/结构：</strong><br>形如：<figure class="image-box">                <img src="https://img-blog.csdn.net/20180614211811858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="components" title="" class="">                <p>components</p>            </figure><br>跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。<br><strong>2.打包入口：</strong><br> app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614211620198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="moudle" title="" class="">                <p>moudle</p>            </figure><br>如图：<br>在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。<br>在@NgMoudle中，import则声明了使用的第三方库。<br>在 declarations 中注册了子组件。<br><strong>app目录不仅作为整个项目的打包入口，其本身也是一个根组件</strong>。<br><strong>3.模块划分：</strong></p><ol><li>根组件/模块 appMoudle</li><li>英雄列表 =&gt; heroes 组件</li><li><p>当前选择的英雄=&gt; hero-detail组件</p><h2 id="新的ng语法"><a href="#新的ng语法" class="headerlink" title="新的ng语法"></a>新的ng语法</h2><p>ng新语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*代表ng指令  不用ng-if,ng-for，类似于驼峰 ngFor ngIf </span><br><span class="line">()代表绑定事件   原生事件绑定直接写在括号里 (click) (keydown)</span><br><span class="line">[]单向绑定  代表绑定属性   [name] = &apos;jobs&apos; </span><br><span class="line">[()] 双向绑定&lt;input [(value=&quot;someValue&quot;)] type=&quot;text&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><p><em>官方称双向绑定写法叫盒子里的香蕉？？？？？？？</em></p><h2 id="父子组件状态传递"><a href="#父子组件状态传递" class="headerlink" title="父子组件状态传递"></a>父子组件状态传递</h2><p>Step1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。<br>Step2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。<br>Step2如图所示：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614212726956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Step2" title="" class="">                <p>Step2</p>            </figure><br>Step3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。<br>Step3如图所示：<br><figure class="image-box">                <img src="https://img-blog.csdn.net/20180614213345167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Step3" title="" class="">                <p>Step3</p>            </figure></p><p>在Vue中，通常是这样做的：<br>子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。<br>angular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。</p><h2 id="组件-运作-执行流程-的文字描述"><a href="#组件-运作-执行流程-的文字描述" class="headerlink" title="组件 运作/执行流程 的文字描述"></a>组件 运作/执行流程 的文字描述</h2><ul><li>列表组件渲染出Mock的数组 (列表组件 heroes 负责)</li><li>为每一个渲染出的项，绑定事件，并传参 (同上)</li><li>在列表组件heroes 的模版加入<code>&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</code>，这样父组件的值已经通过单向绑定至子组件，<strong>但接收与使用，决定权在于子组件</strong>。（同上）</li><li>hero-detail组件接收父组件传递过来的数值，并在内部<code>import {Input} from &#39;@angular/core&#39;</code>（hero-detail组件负责）</li><li>接着在export语句中，使用装饰器来声明+初始化 得到的属性<code>@Input() hero: Hero;</code>然后就可以用啦！  （hero-detail组件负责）</li></ul><h2 id="整体逻辑代码-步骤"><a href="#整体逻辑代码-步骤" class="headerlink" title="整体逻辑代码 步骤"></a>整体逻辑代码 步骤</h2><p><strong>Step 1</strong><br>创建列表组件，使用<code>*ngFor</code>来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;li </span><br><span class="line">    *ngFor=&quot;let thisHero of heroes&quot; </span><br><span class="line">    (click)=&quot;onSelect(thisHero)&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>在对应的.ts文件中，这个方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//方法</span><br><span class="line"></span><br><span class="line"> /*定义参数类型为Hero类型，即从hero.ts导出的类：</span><br><span class="line">   export class Hero &#123;</span><br><span class="line">    id: number;</span><br><span class="line">    name: string;</span><br><span class="line">  &#125;</span><br><span class="line">  并且，设定该方法没有返回值。</span><br><span class="line">  */</span><br><span class="line">onSelect(hero: Hero): void &#123;</span><br><span class="line"></span><br><span class="line">  //动态赋值</span><br><span class="line">  this.selectedHero = hero; </span><br><span class="line">  </span><br><span class="line"> //业务逻辑相关</span><br><span class="line">  this.bool = !this.bool;</span><br><span class="line">  this.isSelected =  &#123;</span><br><span class="line">   &apos;badge&apos;:!this.bool,</span><br><span class="line">&apos;selected&apos;:this.bool</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。<br><strong>Step 2</strong><br>在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</span><br></pre></td></tr></table></figure></p><p>把值绑定到子组件模版，这样，父组件的使命就结束了。<br><strong>Step 3</strong><br>子组件如何接收并使用父组件传来的值呢？<br>首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）<br><code>import {Input} from &#39;@angular/core&#39;</code><br>接着，装饰器来申请接收传进来值，声明+初始化二连：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Input() hero: Hero;</span><br></pre></td></tr></table></figure></p><p>哦，完事了。</p><p>此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/80698441&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈来北京后的工作节奏以及对前端的看法</title>
    <link href="http://yoursite.com/2018/05/23/%E8%B0%88%E4%B8%80%E8%B0%88%E6%9D%A5%E5%8C%97%E4%BA%AC%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%8A%82%E5%A5%8F%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%9C%8B%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/23/谈一谈来北京的工作节奏以及对前端的看法/</id>
    <published>2018-05-23T14:12:19.023Z</published>
    <updated>2018-05-23T14:24:29.983Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/80427169" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="为什么来北京"><a href="#为什么来北京" class="headerlink" title="为什么来北京"></a>为什么来北京</h2><p>这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。<br>那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。<br>下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。<br>虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。<br>想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。<br>其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。<br>两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于：</p><ul><li>熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。</li><li>对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。</li><li>对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等</li><li>对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。</li><li>能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。<br>其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。<br>其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。<br>但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2>来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。<br>在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。<br>女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。<br>最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。<br>总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。<br>很久没有写东西，思路比较乱，想到哪写到哪。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/80427169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>基于bootstrap特殊分辨率页面的实现思路</title>
    <link href="http://yoursite.com/2018/04/14/%E5%9F%BA%E4%BA%8Ebootstrap%E7%89%B9%E6%AE%8A%E5%88%86%E8%BE%A8%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/04/14/基于bootstrap特殊分辨率页面的实现思路/</id>
    <published>2018-04-14T15:11:09.000Z</published>
    <updated>2018-05-06T14:12:09.423Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="https://blog.csdn.net/qq_20264891/article/details/79945485" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="一、效果预览"><a href="#一、效果预览" class="headerlink" title="一、效果预览"></a>一、效果预览</h2><figure class="image-box">                <img src="http://img.blog.csdn.net/20180102103428658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。</p><h2 id="二、方案选择"><a href="#二、方案选择" class="headerlink" title="二、方案选择"></a>二、方案选择</h2><p>刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。</p><p>这个效果的实现，如果采用jquery的方案，直接写个动画即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//先设定好position:relative;</span><br><span class="line">$(&apos;img:hover&apos;).animate(&#123;&apos;left&apos;:&apos;10px&apos;,&apos;bottom&apos;:&apos;10px&apos;&#125;);</span><br></pre></td></tr></table></figure><p>假如追根溯源，还是使用的CSS3的动画。<br>首先自定义一个动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@keyframes testAnimate&#123;</span><br><span class="line"></span><br><span class="line">from&#123;position: relative;bottom: 0;left: 0;&#125;</span><br><span class="line"></span><br><span class="line">to&#123;position: relative;bottom: 20px;left: 30px;border: 5px solid #999;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。</p><p>接着，我们在测试的图片用例上来引入动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img:hover&#123;</span><br><span class="line">animation:testAnimate 1s;</span><br><span class="line">-webkit-animation:testAnimate  1s;</span><br><span class="line">-moz-animation:testAnimate  1s;</span><br><span class="line">-o-animation:testAnimate  1s;</span><br><span class="line">-ms-animation:testAnimate 1s;</span><br><span class="line">&#125;</span><br><span class="line">//整个动画1s完成，并设置了浏览器兼容</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180102110628693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img:hover&#123;</span><br><span class="line">animation-fill-mode: forwards;</span><br><span class="line">-ms-animation-fill-mode:forwards;//兼容IE  xxxxxx  </span><br><span class="line">-webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx</span><br><span class="line">-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx</span><br><span class="line">-o-animation-fill-mode:forwards;//兼容opear xxxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。</p><h2 id="三、分析归纳"><a href="#三、分析归纳" class="headerlink" title="三、分析归纳"></a>三、分析归纳</h2><p>众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行</p><p>预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/qq_20264891/article/details/79945485&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="bootstrap" scheme="http://yoursite.com/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>用原生js制作一个动态简历(多动症简历)及在线预览部署过程</title>
    <link href="http://yoursite.com/2018/03/11/%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86(%E5%A4%9A%E5%8A%A8%E7%97%87%E7%AE%80%E5%8E%86)%E5%8F%8A%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/03/11/用原生js制作一个动态简历(多动症简历)及在线预览部署过程 - 副本/</id>
    <published>2018-03-11T10:26:22.568Z</published>
    <updated>2018-01-29T14:38:44.357Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79197651" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="本项目Fork地址-欢迎Star-："><a href="#本项目Fork地址-欢迎Star-：" class="headerlink" title="本项目Fork地址(欢迎Star)："></a>本项目Fork地址(欢迎Star)：</h2><p><a href="https://github.com/ZQ-jhon/resume" target="_blank" rel="noopener">https://github.com/ZQ-jhon/resume</a></p><h2 id="本项目预览地址-Preview-Address"><a href="#本项目预览地址-Preview-Address" class="headerlink" title="本项目预览地址(Preview Address)"></a>本项目预览地址(Preview Address)</h2><p>Preview :  <a href="https://zq-jhon.github.io/resume/" target="_blank" rel="noopener">多动症简历</a></p><h2 id="项目起因"><a href="#项目起因" class="headerlink" title="项目起因"></a>项目起因</h2><p>因为在网上看到一个大神做的动态简历，如连接所示：</p><p><a href="http://strml.net/" target="_blank" rel="noopener">http://strml.net/</a></p><p>炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。</p><h2 id="引用的第三方库"><a href="#引用的第三方库" class="headerlink" title="引用的第三方库"></a>引用的第三方库</h2><p>1.jQuery  实际用到的地方只有1%</p><p>2.prism   代码高亮库。用到30%</p><p>3.marked.js markdown语法转html的库，实际用到20%</p><h2 id="技术概要"><a href="#技术概要" class="headerlink" title="技术概要"></a>技术概要</h2><p>通篇中使用的技术难度并不大，主要有：</p><ul><li><p><strong>核心原理：</strong>同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。</p></li><li><p>字符串提取、拼接。</p></li><li><p>setInterval定时器控制整个代码的吞吐节奏/速率。</p></li><li><p>在setInterval中设定一些if，用来控制总字符串的吞吐位置。</p><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><p><strong>1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释/</strong>/，要对/进行转义，如下`\/<em>这里填写你的内容</em>\/。**</p></li></ul><p><strong>2.字符串的命名一定要切实合理： 如图所示：</strong></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129213013960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="字符串的命名" title="" class="">                <p>字符串的命名</p>            </figure><p><strong>3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n&gt;123&amp;&amp;n&lt;321)这种方法来进行区域渲染。prism的渲染代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">官方js库地址：[http://prismjs.com/](http://prismjs.com/)</span><br><span class="line"></span><br><span class="line">语法:prism.heihlight(渲染的字符串,渲染的代码格式)</span><br><span class="line"></span><br><span class="line">Prism.highlight(str.substring(0,n), Prism.languages.css);</span><br></pre></td></tr></table></figure><p><strong>4.MarkDown ⇒ HTML渲染 ：  同样根据n的值，来使用if()来进行循环。</strong></p><p>marked.js官方库地址：<a href="https://www.npmjs.com/package/marked" target="_blank" rel="noopener">https://www.npmjs.com/package/marked</a></p><p>渲染代码如下:</p><p><code>drawBoard.innerHTML =marked(str.substring(929,1885));</code></p><p><strong>5.动态创建Pre标签（id=”drawBoard”）  ：  CSS代码版是一开始写在HTML的，但是之后的简历板子（id=”drawBoard”，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：</strong></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129214532614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="动态创建drawBoard" title="" class="">                <p>动态创建drawBoard</p>            </figure><p><strong>6.已经创建的元素无法在另外的循环中获取 ：</strong><br> <strong>在刚才的【5】中，动态创建的pre标签(id=”drawBoard”)会在if()的区域内无法document.getElementById(‘drawBoard’)，此时需要在if里面再次获取并且赋值，如图所示：</strong></p><p><img src="http://img.blog.csdn.net/20180129214929626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="再次赋值"></p><p><strong>7.动态下拉   同样通过n的值来让元素的溢出自动下拉</strong></p><p>如图：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129215552841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="动态下拉" title="" class="">                <p>动态下拉</p>            </figure><p><strong>8. 动态简历最后的魔术环节  ：   还是通过n的值来进行判断，从而渲染 </strong></p><p>其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。</p><p>代码如图：</p><p><img src="http://img.blog.csdn.net/20180129215916887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="魔术效果实现"></p><h2 id="核心原理代码"><a href="#核心原理代码" class="headerlink" title="核心原理代码"></a>核心原理代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义</span><br><span class="line"></span><br><span class="line">var styleTag = document.getElementById(&apos;styleTag&apos;);</span><br><span class="line"></span><br><span class="line">var sourceBoard = document.getElementById(&apos;sourceBoard&apos;);</span><br><span class="line"></span><br><span class="line">var str = &apos;\/*大家好...今天我给大家做一个在线简历...\/*&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var n = 0;</span><br><span class="line">window.setInterval(function()&#123;</span><br><span class="line">   n++;</span><br><span class="line">   styleTag.innerHTML = str.substring(0,n);</span><br><span class="line">    </span><br><span class="line">   sourceBoard.innerHTML = str.substring(0,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;,100);</span><br><span class="line"></span><br><span class="line">//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。</span><br></pre></td></tr></table></figure><h1 id="Demo部署到GitHub详细过程"><a href="#Demo部署到GitHub详细过程" class="headerlink" title="Demo部署到GitHub详细过程"></a>Demo部署到GitHub详细过程</h1><p>本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129220933667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gh-pages预览项目" title="" class="">                <p>gh-pages预览项目</p>            </figure><p>在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。</p><p>整个部署的环节大致如下：</p><ol><li><p>在本地的项目根目录下，<code>$ git init</code></p></li><li><p>加入当前所有文件到暂存区 <code>$ git add .</code>(后面有个“·”，代表全部文件)</p></li><li><p>连接远程仓库  <code>$ git remote add origin &quot;your repository address&quot;</code></p></li><li><p>提交所有文件到git版本控制系统 <code>$ git commit -m &quot;create Demo resume&quot;</code></p></li><li><p>push到你的远程仓库 <code>$ git push origin master</code></p></li><li><p>打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。</p><p>PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub</p></li></ol><h1 id="反思与不足"><a href="#反思与不足" class="headerlink" title="反思与不足"></a>反思与不足</h1><ol><li>在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。</li></ol><ol><li><p>我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。</p><p>我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：<a href="http://strml.net/" target="_blank" rel="noopener">http://strml.net/</a>的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。</p></li><li>整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。</li></ol><ol><li>整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。</li></ol><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79197651&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="动态简历" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86/"/>
    
      <category term="Github部署" scheme="http://yoursite.com/tags/Github%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记</title>
    <link href="http://yoursite.com/2018/03/11/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/11/typescript学习笔记/</id>
    <published>2018-03-11T10:26:22.561Z</published>
    <updated>2018-03-11T10:28:42.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79324863" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8…提前为将来的ES标准打下基础。<br>    学习tsc，不亏!</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g typescript</span><br></pre></td></tr></table></figure><p>完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your File_path</span><br><span class="line">$ tsc File_name.ts</span><br></pre></td></tr></table></figure><p>OK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180214112403989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="tsc" title="" class="">                <p>tsc</p>            </figure><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><p>1.基本类型检测</p><p>在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a:number = 1;  //OK</span><br><span class="line"></span><br><span class="line">let a:string = 1;  //error</span><br><span class="line"></span><br><span class="line">类型检测的语法，就是在变量屁股后面缀上 :类型</span><br></pre></td></tr></table></figure><p>2.数组的类型检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr:number[]=[1,2,3];   //ok   类型+[]</span><br><span class="line"> </span><br><span class="line">let brr:Array&lt;number&gt;=[4,5,6]; //OK  数组泛型+尖括号&lt; 类型 &gt;</span><br></pre></td></tr></table></figure><p>3.元组类型 Tupe </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let X:[number,string];</span><br><span class="line">x=[1,&apos;hello&apos;]; //OK</span><br><span class="line">x=[1,2];  //type error</span><br><span class="line">元组类型适用于已知个数和元素类型的数组。</span><br></pre></td></tr></table></figure><h2 id="字符串拼接及字符串模板"><a href="#字符串拼接及字符串模板" class="headerlink" title="字符串拼接及字符串模板"></a>字符串拼接及字符串模板</h2><p>拼接：跟ES6一样，通过<code>（``）</code>来实现，【`】为Tab上面的按键。</p><p>for eg  :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let hi= (`</span><br><span class="line">hello,</span><br><span class="line">wrold!</span><br><span class="line">`);</span><br><span class="line"></span><br><span class="line">//输出 hello,world!</span><br></pre></td></tr></table></figure><p>字符串模板：提供一种更优雅的书写方式：<code>${ 变量名}</code></p><p>for eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let names:string = &apos;xiaoming&apos;;</span><br><span class="line"></span><br><span class="line">let age:number = 23;</span><br><span class="line"></span><br><span class="line">let sentence:string = (`</span><br><span class="line"></span><br><span class="line">hello,my name is $&#123;names&#125;,my age is $&#123;age&#125;</span><br><span class="line"></span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>编译后的js文件为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var names = &apos;xiaoming&apos;;</span><br><span class="line"></span><br><span class="line">var age = 23;</span><br><span class="line"></span><br><span class="line">var sentence = (&quot;\nhello,my name is &quot; + names + &quot;,my age is &quot; + age + &quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">document.body.innerHTML = sentence;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> flower &#123;a,b,c,d,e,f,g&#125;;  <span class="comment">//enum关键字，后跟枚举类型的命名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rouse:flower = flower.a;  <span class="comment">//定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性</span></span><br><span class="line"></span><br><span class="line">alert(rouse);  <span class="comment">// 0 表明rouse映射的对象，在flower中的index为0</span></span><br></pre></td></tr></table></figure><h2 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h2><p>有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。</p><p><img src="http://img.blog.csdn.net/20180214120224290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="any类型"></p><p>let不能重复定义，我就用var来演示。</p><p>Any类型也可以像数组的第一种定义方法一样，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Array:</span><br><span class="line"></span><br><span class="line">let arr:number[]=[1,2,3];  // OK</span><br><span class="line"></span><br><span class="line">数字的组合，可不就是数组吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">字符串组、布尔值组...</span><br><span class="line"></span><br><span class="line">let brr:string[] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line"></span><br><span class="line">let crr:boolean[] = [true,false];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Any:</span><br><span class="line"></span><br><span class="line">let drr:any[]=[1,&apos;2&apos;,true];  //  OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">只知道是个类似于数组的数据类型，但是对元素的类型不做限制。</span><br></pre></td></tr></table></figure><h2 id="Void类型"><a href="#Void类型" class="headerlink" title="Void类型"></a>Void类型</h2><p>void类型表示空。常用在函数返回值，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//注意函数返回值类型检测的写法</span><br><span class="line">function foo():void&#123;</span><br><span class="line"></span><br><span class="line">alert(&apos;123&apos;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，void包含两种数据类型，就是null和undefind。</p><p>触类旁通，其实还有两个类型是null和undefind，如图所示：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180214121723225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="null&undefind" title="" class="">                <p>null&undefind</p>            </figure><p>如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。<br>写法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a:number =1; </span><br><span class="line"></span><br><span class="line">let b:any = &lt;number&gt;a ;  //赋值</span><br></pre></td></tr></table></figure><p>第二种写法:</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180214131500183?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="类型断言" title="" class="">                <p>类型断言</p>            </figure><h2 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h2><p>来看这样一段代码：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220191341275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="for循环实例" title="" class="">                <p>for循环实例</p>            </figure></p><p>在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220191448648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="运行结果" title="" class="">                <p>运行结果</p>            </figure><p>可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。</p><p><strong>究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果</strong></p><p>将上述代码的<code>var i</code>改为<code>let i</code>这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。<br>因此，代码结果如下图所示：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220191954426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="let执行结果" title="" class="">                <p>let执行结果</p>            </figure><p>再来看一个对比：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220193631816?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="使用var声明" title="" class="">                <p>使用var声明</p>            </figure><p>将var 改为let </p><p><img src="http://img.blog.csdn.net/20180220193713998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="使用let声明"></p><p>可见，两种声明，是一摸一样的输出，为什么呢？<br>var的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次<code>for(let i=0;i&lt;5;i++)</code>的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。<br><strong>因为这里没有异步函数</strong>，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。</p><p>总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。</p><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p>定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。<br>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = 1 ;</span><br><span class="line"></span><br><span class="line">const a = 2 ; //error</span><br></pre></td></tr></table></figure><h2 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h2><p>普通结构赋值：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220195746635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="普通结构赋值" title="" class="">                <p>普通结构赋值</p>            </figure><p>函数参数结构赋值：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220200215178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="函数结构赋值" title="" class="">                <p>函数结构赋值</p>            </figure><p>注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。</p><h2 id="数组中的【…】解构语法"><a href="#数组中的【…】解构语法" class="headerlink" title="数组中的【…】解构语法"></a>数组中的【…】解构语法</h2><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220200938878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="数组解构" title="" class="">                <p>数组解构</p>            </figure><p>输出：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220201035491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="输出" title="" class="">                <p>输出</p>            </figure><p>可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。</p><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p><img src="http://img.blog.csdn.net/2018022020404810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="对象解构"></p><p><strong>直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。</strong></p><p><strong>下图是错误示范</strong>：</p><p><img src="http://img.blog.csdn.net/20180220204209671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="对象解构错误示范"></p><p>那么同理，如果在一个方法中返回对象，同样也可以被解构。<br><figure class="image-box">                <img src="http://img.blog.csdn.net/2018022113342527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="函数返回的对象也可以解构赋值" title="" class="">                <p>函数返回的对象也可以解构赋值</p>            </figure></p><p>如果对象存在嵌套现象，可以使用冒号表达式：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180221133915180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="嵌套的对象，使用冒号表达式来嵌套化结构" title="" class="">                <p>嵌套的对象，使用冒号表达式来嵌套化结构</p>            </figure><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><p>还是使用…语法，进行数组或者对象的浅拷贝。</p><p>数组展开，形如：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220205541321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="数组展开" title="" class="">                <p>数组展开</p>            </figure></p><p>对象展开，形如：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220205712494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="对象展开" title="" class="">                <p>对象展开</p>            </figure><p><strong>对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。</strong></p><h2 id="可选参数、默认参数"><a href="#可选参数、默认参数" class="headerlink" title="可选参数、默认参数"></a>可选参数、默认参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(a:string,b?:string,c=&quot;wang&quot;)&#123;</span><br><span class="line">console.log(a)</span><br><span class="line">console.log(b)</span><br><span class="line">console.log(c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a为string类型，b为可选参数(string类型)，c是有默认值的参数</span><br></pre></td></tr></table></figure><p><strong>确定的参数要现在第一个，不能把可选参数写在第一位。</strong></p><h2 id="函数断点Yield"><a href="#函数断点Yield" class="headerlink" title="函数断点Yield"></a>函数断点Yield</h2><p>在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    yield; //设置断点，下同</span><br><span class="line"></span><br><span class="line">    console.log(2);</span><br><span class="line"></span><br><span class="line">    yield;</span><br><span class="line"></span><br><span class="line">    console.log(3);</span><br><span class="line"></span><br><span class="line">    yield;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。</span><br><span class="line"> *必须重新赋值，再调用。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">let zoo =  foo(); </span><br><span class="line"></span><br><span class="line">//这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。</span><br><span class="line">zoo.next();//1</span><br><span class="line">zoo.next();//2</span><br><span class="line">zoo.next();//3</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>作用一：主要用于声明匿名函数，简化代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sum = (a,b)=&gt;a+b</span><br><span class="line"></span><br><span class="line">上式等价于：</span><br><span class="line">var sum = function (a,b)&#123;</span><br><span class="line">retrun a+b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>作用二：消除this指针带来的歧义,优化执行上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getName (name) &#123; </span><br><span class="line"> this.name = name ;</span><br><span class="line">  setInterval(function () &#123; console.log(&apos;name is &apos;+this.name)&#125;,1000)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var john = new getName(&apos;jhon&apos;);</span><br><span class="line">console.log(john)       // 打印 name is (空)</span><br></pre></td></tr></table></figure><p>这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。</p><p>使用箭头函数改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getName (name) &#123; </span><br><span class="line"> this.name = name ;</span><br><span class="line">    setInterval(() =&gt; console.log(&apos;name is &apos;+this.name)),1000)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var john = new getName(&apos;jhon&apos;);</span><br><span class="line">console.log(john)       // 打印 name is jhon</span><br></pre></td></tr></table></figure><h2 id="For…of循环"><a href="#For…of循环" class="headerlink" title="For…of循环"></a>For…of循环</h2><p><strong>for…in 循环对象的下标</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.name = &apos;myArr&apos;;</span><br><span class="line"></span><br><span class="line">for (var n in arr) &#123; </span><br><span class="line">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class="line">&#125;</span><br><span class="line">//输出0=1,1=2,2=3,3=4,name=myArr</span><br></pre></td></tr></table></figure><p><strong>for of 循环对象的key</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.name = &apos;myArr&apos;;</span><br><span class="line"></span><br><span class="line">for (var n of arr) &#123; </span><br><span class="line">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class="line">&#125;</span><br><span class="line">//输出0=1,1=2,2=3,3=4,undefind</span><br><span class="line"></span><br><span class="line">//还可以循环字符串</span><br><span class="line">var arr =&apos;hello,world!&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (var n of arr) &#123; </span><br><span class="line">    console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">//h,e,l,l,o,，w,o,r,l,d,!;</span><br></pre></td></tr></table></figure><p><strong>forEach  循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.name = &apos;myArr&apos;;</span><br><span class="line"></span><br><span class="line">arr.forEach(function (n,v) &#123; </span><br><span class="line">    console.log(n,v)</span><br><span class="line">&#125;)</span><br><span class="line">//输出1,2,3,4，但是没有输出我们定义的name</span><br></pre></td></tr></table></figure><p>总结：for…in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for…of有点鸡肋，但是胜在使用场景广泛。</p><h2 id="interface接口"><a href="#interface接口" class="headerlink" title="interface接口"></a>interface接口</h2><p>interface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/2018022210063595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="interface" title="" class="">                <p>interface</p>            </figure><p>当然，接口中预先定义的变量，也可以规定/限制函数中的参数：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180222103808977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="限制函数中的参数" title="" class="">                <p>限制函数中的参数</p>            </figure><h2 id="基于Class的继承"><a href="#基于Class的继承" class="headerlink" title="基于Class的继承"></a>基于Class的继承</h2><p>在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script!</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180220210913277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="基于Class的继承" title="" class="">                <p>基于Class的继承</p>            </figure><p>访问权限关键字：<br><strong>public</strong> 公共成员。  子类、父类内部都可以访问到。</p><p><strong>private</strong> 私有成员。只允许在类中访问。</p><p><strong>protected</strong> 超类的私有成员。但是在子类中仍然可以访问。</p><p>构造器Construcor：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//形如：</span><br><span class="line">constructor()&#123;</span><br><span class="line"> name?string;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。</p><p>举例说明：</p><p><img src="http://img.blog.csdn.net/20180222105023915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="构造器内部的变量无法被全局访问"></p><p>这时候，只要在构造器的name上增加关键字<code>public</code>，即可在class中全局访问：</p><p><img src="http://img.blog.csdn.net/20180222105147415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="加上public，没有报错"></p><p><strong>类的继承</strong><br>真的比基于原型链的继承更加优雅和简便。<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180222105737601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="通过extends关键字实现继承" title="" class="">                <p>通过extends关键字实现继承</p>            </figure></p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79324863&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下</title>
    <link href="http://yoursite.com/2018/03/08/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8B/"/>
    <id>http://yoursite.com/2018/03/08/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下/</id>
    <published>2018-03-08T14:13:16.143Z</published>
    <updated>2018-02-22T03:05:47.703Z</updated>
    
    <content type="html"><![CDATA[<!--<script type="text/javascript">if(window.prompt('请输入密码')==123456){alert('password success')}else{alert('password error');window.history.back(-1);}          </script>--><p>本文初始编辑地址，源自我的CSDN博客：<a href="">我的CSDN博客</a></p><h2 id="6-简单说一说盒模型，W3C和IE怪异盒模型。"><a href="#6-简单说一说盒模型，W3C和IE怪异盒模型。" class="headerlink" title="6. 简单说一说盒模型，W3C和IE怪异盒模型。"></a>6. 简单说一说盒模型，W3C和IE怪异盒模型。</h2><p>W3C标准的盒模型：width ==  content_width(不包括padding+border+margin)</p><p>IE怪异盒模型： width  == content_width+padding+border</p><p>参考我之前的博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79019724" target="_blank" rel="noopener">http://blog.csdn.net/qq_20264891/article/details/79019724</a></p><h2 id="7-简要阐述XSS和CSRF攻击及防范"><a href="#7-简要阐述XSS和CSRF攻击及防范" class="headerlink" title="7.简要阐述XSS和CSRF攻击及防范"></a>7.简要阐述XSS和CSRF攻击及防范</h2><p><strong>7.1 XSS攻击与防范</strong><br>注入攻击。<br>简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。</p><p>防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。</p><p>例如: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&lt;script&gt;alert(123)&lt;/script&gt;&quot; name=&quot;input&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure><p>显然，正常的用户，不会再输入框里面输入形如<code>&lt;script&gt;alert(123)&lt;/script&gt;</code>的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。</p><p><strong>7.2 CSRF攻击与防范</strong></p><p>CSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。</p><p>举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。<br>防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。<br>参考文章：<a href="https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/" target="_blank" rel="noopener">https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/</a><br>这篇文章写的很好。</p><h2 id="8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype"><a href="#8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype" class="headerlink" title="8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)"></a>8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)</h2><p>在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个<code>_proto_</code>对象，构造函数则有一个<code>prototype</code>对象，该对象上挂载的是可以继承的方法、属性等等。</p><p>8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？</p><p>通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。</p><h2 id="9-页面性能优化有哪些方式？"><a href="#9-页面性能优化有哪些方式？" class="headerlink" title="9.页面性能优化有哪些方式？"></a>9.页面性能优化有哪些方式？</h2><p>a.文件(css,js,img)压缩、合并（雪碧图）</p><p>b.减少请求数量</p><p>c.减少页面重排/重绘</p><p>d.使用懒加载，按需加载</p><p>e.CSS3动画有限保持帧率</p><p>f.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值</p><p>g.减少代码冗余量，精简代码</p><p>h.静态资源部署到CDN节点</p><p><strong>9.1 重绘/重排是怎么回事？有什么区别？</strong></p><p>网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。</p><p>例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的<em>重排</em>。</p><p>当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是<em>重绘</em>。</p><p>重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。</p><p><em>也就是说，重排一定会引发重绘。</em></p><p>重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。</p><p><em>也就是说，重绘现象的发生，有可能是以重排作为前提。</em></p><p><strong>9.2 请举例说明重绘，什么情况下会重绘？</strong></p><p>重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。</p><p><strong>9.3  你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？</strong><br>是的。</p><p>color,background等属性会引发重绘。</p><p>浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。</p><h2 id="10-浏览器如何知道一个css文件-js文件需要缓存？"><a href="#10-浏览器如何知道一个css文件-js文件需要缓存？" class="headerlink" title="10. 浏览器如何知道一个css文件,js文件需要缓存？"></a>10. 浏览器如何知道一个css文件,js文件需要缓存？</h2><p>首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。</p><p>在<a href="https://www.cnblogs.com/shixiaomiao1122/p/7591556.html" target="_blank" rel="noopener">https://www.cnblogs.com/shixiaomiao1122/p/7591556.html</a>看到一个缓存原理图，侵删，图注的很详细：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180201144623611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="缓存机制原理图" title="" class="">                <p>缓存机制原理图</p>            </figure></p><h2 id="11-HTTP状态码304-502-503"><a href="#11-HTTP状态码304-502-503" class="headerlink" title="11.HTTP状态码304,502,503"></a>11.HTTP状态码304,502,503</h2><p>304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。</p><p>502：服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：服务器停机维护。</p><p>http状态码：<br>1XX：临时响应。并继续等待客户端的请求<br>2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容<br>3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。<br>4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。<br>5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。</p><h2 id="12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？"><a href="#12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？" class="headerlink" title="12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？"></a>12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？</h2><p>任何项目只有未发现 bug 和已经发现 bug 两种情况</p><p>不存在没有 bug 的情况</p><p>即便是测试人员也不可能覆盖 100% 的可能性</p><p>但是测试表中的要求必须 100%</p><p> 覆盖如果测试通过上线后产生的 bug </p><p>如果是测试表中未覆盖的则编制测试表的人员背锅</p><p>如果是不可抗力福利彩票背锅</p><p>作者：王小明<br>链接：<a href="https://www.zhihu.com/question/65688799/answer/233725228" target="_blank" rel="noopener">https://www.zhihu.com/question/65688799/answer/233725228</a></p><p>开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。</p><p>如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--
&lt;script type=&quot;text/javascript&quot;&gt;

if(window.prompt(&#39;请输入密码&#39;)==123456){

alert(&#39;password success&#39;)

}else{
alert(&#39;password error&#39;);window.
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
      <category term="重绘" scheme="http://yoursite.com/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="冲排" scheme="http://yoursite.com/tags/%E5%86%B2%E6%8E%92/"/>
    
      <category term="腾讯面试" scheme="http://yoursite.com/tags/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上</title>
    <link href="http://yoursite.com/2018/03/08/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8A/"/>
    <id>http://yoursite.com/2018/03/08/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上/</id>
    <published>2018-03-08T14:13:16.142Z</published>
    <updated>2018-02-22T03:05:44.100Z</updated>
    
    <content type="html"><![CDATA[<!--<script type="text/javascript">if(window.prompt('请输入密码')==123456){alert('password success')}else{alert('password error');window.history.back(-1);}          </script>--><p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79212913" target="_blank" rel="noopener">我的CSDN博客</a></p><p>这篇博客同步更新于我的GitHub博客：<a href="https://zq-jhon.github.io/2018/01/30/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94%28%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE%29%20%E4%B8%8A/" target="_blank" rel="noopener">我的GitHub博客</a></p><p>面试回顾：<a href="http://blog.csdn.net/qq_20264891/article/details/79158495" target="_blank" rel="noopener">腾讯面试回顾</a></p><h2 id="1-js中ajax发送请求的步骤"><a href="#1-js中ajax发送请求的步骤" class="headerlink" title="1.js中ajax发送请求的步骤"></a>1.js中ajax发送请求的步骤</h2><pre><code>在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下:</code></pre><p><strong>①创建XMLHttpRequest对象（标准浏览器）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> IE7及以下，这个对象为：ActiveXObject：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(window.ActiveXObject)&#123;</span><br><span class="line">var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 初始化请求</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com&apos;,是否异步?true:false);</span><br></pre></td></tr></table></figure><p><strong>③发送请求/传递数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//数据</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com/index.html&apos;,true);</span><br></pre></td></tr></table></figure><p>如果是POST方法，直接写  <code>xhr.send(&#39;数据&#39;)</code> 中。</p><p><strong>④设置异步回调callback()</strong><br>先给个错误示范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//xhr.readyState 本地的请求状态</span><br><span class="line">//xhr.status 服务器返回的请求状态码</span><br><span class="line">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">  do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1</p><p>这里的异步方式主要通过一个事件来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange()=function()&#123;</span><br><span class="line"></span><br><span class="line">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">  do something...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。</p><p>反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。</p><p>扩展：既然 readyState==4 &amp;&amp; status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~<br>参考文章 ，我以前的博客：<a href="https://zq-jhon.github.io/2017/11/06/Ajax%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">Ajax初探</a><br>上一次的面试中，xhr.open()初始化  xhr.send()发送请求  xhr.onreadystatechange=function(){}回调函数  这三点都忘记答了，一定要注意。</p><h2 id="2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？"><a href="#2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？" class="headerlink" title="2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？"></a>2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</h2><p>事件捕获、事件响应、事件冒泡。</p><p>如图：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131093105267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="事件捕获和冒泡" title="" class="">                <p>事件捕获和冒泡</p>            </figure><p>不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。</p><p>一句话概括这种机制：</p><p>捕获：自外而内，从根到叶，从大到小 。</p><p>冒泡：自内而外，从叶到根，从小到大。</p><p>来做个实验，有如下的html结构 和 js代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--HTML结构--&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;</span><br><span class="line">我是DIV1</span><br><span class="line">&lt;div id=&quot;div2&quot;&gt;</span><br><span class="line">我是DIV2</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;</span><br><span class="line">i am a button</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//script代码</span><br><span class="line"></span><br><span class="line">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class="line">var div2 = document.getElementById(&apos;div2&apos;);</span><br><span class="line">var btn = document.getElementById(&apos;btn&apos;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&apos;click&apos;, function() &#123;console.log(this.id)&#125;,false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">div2.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br><span class="line"></span><br><span class="line">div1.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br></pre></td></tr></table></figure><p>HTML结构如图：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131094357898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="HTML结构" title="" class="">                <p>HTML结构</p>            </figure><p>当点击最里面的button，会依次出现这种情况：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131094911606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="控制台输出" title="" class="">                <p>控制台输出</p>            </figure><p>可以看到，事件是在冒泡阶段被触发的。</p><p>当改变js API中最后一个Boolean值为true时，又会产生另外一种景观：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180131095628141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>这次是从外向内依次触发的。</p><p>总结：<br>1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。<br>2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。</p><h2 id="3-闭包是怎么回事？用在什么场景？"><a href="#3-闭包是怎么回事？用在什么场景？" class="headerlink" title="3.闭包是怎么回事？用在什么场景？"></a>3.闭包是怎么回事？用在什么场景？</h2><p>简而言之：<strong>1、闭包就是可以访问局部作用域的变量。</strong><br>并且：        <strong>2、 可以使局部变量常驻内存</strong><br>参考阮一峰老师的闭包博客： <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">阮一峰—-闭包</a></p><p><strong>Q:闭包的内部函数为什么变量不会被销毁？</strong><br>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">var a =1;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">a+=1;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">return b();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。</p><p><strong>Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）</strong></p><p>A：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。<br>人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；</p><p><strong>Q3.2：如何避免内存泄漏的问题？</strong><br>A：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。</p><h2 id="4-CALL和Apply是干嘛的？"><a href="#4-CALL和Apply是干嘛的？" class="headerlink" title="4.CALL和Apply是干嘛的？"></a>4.CALL和Apply是干嘛的？</h2><p>二者都是为了更改function 的this指针，举个例子</p><p>CALL(新的this对象，原先的参数1，原先的参数2…);<br>Apply(新的this对象，[原先的参数1，原先的参数2…]);</p><p>先传入新的this对象，再传入旧方法的传参。</p><h2 id="5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？"><a href="#5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？" class="headerlink" title="5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？"></a>5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</h2><p>1.jsonp跨域<br>利用<code>&lt;script&gt;</code>标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//在js预先定义好callback()函数  </span><br><span class="line"></span><br><span class="line">function fun(data)&#123;</span><br><span class="line"></span><br><span class="line">//use data to do somethings.</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//动态创建script标签，并在url中说明请求地址</span><br><span class="line">var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line"></span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line"></span><br><span class="line">script.type = &apos;text/javasctipt&apos;;</span><br><span class="line"></span><br><span class="line">script.src = &apos;require.php?callback=fun&apos;;</span><br><span class="line"></span><br><span class="line">body.appendChild(script);</span><br><span class="line"></span><br><span class="line">//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。</span><br><span class="line">      //假设传回的值是 fun(&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。</span><br></pre></td></tr></table></figure><p>这样，通过script不受跨域访问的特性，实现了跨域访问。</p><p>2.CORS跨域（主流浏览器及IE10+）<br>    对于客户端，我们还是正常使用xhr对象发送ajax请求。<br>    唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;<br>    对于服务器端，需要在 response header中设置如下两个字段:<br>    Access-Control-Allow-Origin: <a href="http://www.yourhost.com" target="_blank" rel="noopener">http://www.yourhost.com</a><br>    Access-Control-Allow-Credentials:true<br>    这样，我们就可以跨域请求接口了。</p><p>3.返回的json和jsonp有什么区别？<br>返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;&quot;name&quot;:&quot;HanMeiMei&quot;&#125;)</span><br></pre></td></tr></table></figure><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--
&lt;script type=&quot;text/javascript&quot;&gt;

if(window.prompt(&#39;请输入密码&#39;)==123456){

alert(&#39;password success&#39;)

}else{
alert(&#39;password error&#39;);window.
      
    
    </summary>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="腾讯" scheme="http://yoursite.com/tags/%E8%85%BE%E8%AE%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="浏览器兼容" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
      <category term="原理" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>javascript Dom拖动 插件 putThere.js</title>
    <link href="http://yoursite.com/2018/03/08/javascript%20Dom%E6%8B%96%E5%8A%A8%20%E6%8F%92%E4%BB%B6%20putThere.js/"/>
    <id>http://yoursite.com/2018/03/08/javascript Dom拖动 插件 putThere.js/</id>
    <published>2018-03-08T14:13:16.132Z</published>
    <updated>2018-01-31T06:10:53.500Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79171972" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="开源地址："><a href="#开源地址：" class="headerlink" title="开源地址："></a>开源地址：</h2><p>跪求各位看官给我点star吧 T.T，谢谢！<br><a href="https://github.com/ZQ-jhon/putThere.js" target="_blank" rel="noopener">https://github.com/ZQ-jhon/putThere.js</a></p><h2 id="原理及构想"><a href="#原理及构想" class="headerlink" title="原理及构想"></a>原理及构想</h2><p>关于拖动，如果不用html5的原生事件，怎样实现呢？<br>不妨先设想一下整个拖动的流程：</p><ol><li>点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute</li><li>当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值)</li><li>当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>想好其中的原理，代码也就不那么难写了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//window监听</span></span><br><span class="line">               <span class="built_in">window</span>.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">               </span><br><span class="line"><span class="comment">/*鼠标按下，dom元素脱离位置，变成绝对定位*/</span></span><br><span class="line">obj.style.position=<span class="string">'absolute'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onmouseup=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> event = <span class="built_in">window</span>.event||event;</span><br><span class="line"><span class="comment">//获取鼠标距离浏览器边界的距离</span></span><br><span class="line"><span class="keyword">var</span> x = event.clientX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = event.clientY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'鼠标距离浏览器边界(0,0)的距离('</span>+x+<span class="string">','</span>+y+<span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取dom元素距离浏览器边界的x,y值*/</span></span><br><span class="line"><span class="keyword">var</span> left = obj.style.left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> top = obj.style.top;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Dom元素距离浏览器边界(0,0)的距离('</span>+left+<span class="string">','</span>+top+<span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/</span></span><br><span class="line"><span class="keyword">if</span>(left&gt;x||top&gt;y)&#123;</span><br><span class="line"></span><br><span class="line">x=-x;</span><br><span class="line"></span><br><span class="line">y=-y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.style.left = x+<span class="string">'px'</span>; </span><br><span class="line"></span><br><span class="line">obj.style.top = y+<span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我将它封装成一个函数，调用的时候，形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">putThere(div);</span><br><span class="line"></span><br><span class="line">此时，div元素可以在<span class="built_in">document</span>中任意的拖动，改变位置。</span><br></pre></td></tr></table></figure><h2 id="效果预览："><a href="#效果预览：" class="headerlink" title="效果预览："></a>效果预览：</h2><p>鼠标拖动div效果如下：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180126140231318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Demo效果预览" title="" class="">                <p>Demo效果预览</p>            </figure><br>可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。</p><h2 id="兼容程度"><a href="#兼容程度" class="headerlink" title="兼容程度"></a>兼容程度</h2><p>实测 兼容 IE9及以上</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79171972&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="plug-in" scheme="http://yoursite.com/tags/plug-in/"/>
    
  </entry>
  
  <entry>
    <title>IONIC3 打包安卓apk详细过程（大量图文）</title>
    <link href="http://yoursite.com/2018/03/08/IONIC3%20%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A4%A7%E9%87%8F%E5%9B%BE%E6%96%87%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/08/IONIC3 打包安卓apk详细过程（大量图文）/</id>
    <published>2018-03-08T14:13:16.131Z</published>
    <updated>2018-03-08T14:21:17.730Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79319408" target="_blank" rel="noopener">我的CSDN博客</a></p><p>本文写于2018年2月12日 22:25:59。</p><p>如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。</p><p>经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。</p><h2 id="1-基本依赖环境"><a href="#1-基本依赖环境" class="headerlink" title="1.基本依赖环境"></a>1.基本依赖环境</h2><ol><li>nodejs环境 (作为一个前端相信你已经有了)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212223918473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="nodejs" title="" class="">                <p>nodejs</p>            </figure>最好提前配置好node的环境变量，便于全局访问</li><li>jdk(下面细说)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224004766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="JDK" title="" class="">                <p>JDK</p>            </figure></li><li>SDK(下面细说，其实主要难就难在SDK配置了)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224101120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SDK" title="" class="">                <p>SDK</p>            </figure></li><li>gradle(下面细说)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224141473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gradle" title="" class="">                <p>gradle</p>            </figure></li></ol><h2 id="2-基本工具"><a href="#2-基本工具" class="headerlink" title="2. 基本工具"></a>2. 基本工具</h2><ol><li>gitbash(就是用来替代windows自带的丑陋的CMD)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224300075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gitbash" title="" class="">                <p>gitbash</p>            </figure><br>下载：我都打包了！<br>链接：<a href="https://pan.baidu.com/s/1mje7ZHu" target="_blank" rel="noopener">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</li><li>windows自带的CMD(<code>window</code>+<code>R</code>输入CMD，管理员身份运行)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224327731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="CMD" title="" class="">                <p>CMD</p>            </figure></li><li>VSCode(微软爸爸开发的前端IDE)<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224349157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="VSCode" title="" class="">                <p>VSCode</p>            </figure><br>下载：请自行去微软爸爸官网下载。</li></ol><h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a>3.环境配置</h2><p><strong>3.1 nodejs (需要配置环境变量)</strong><br>前端必会，跳过。<br><strong>3.2 jdk (无需配置环境变量)</strong><br>下载：已经上传网盘↓<br>链接：<a href="https://pan.baidu.com/s/1mje7ZHu" target="_blank" rel="noopener">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m<br>请自行根据系统安装32/64位的版本。<br>安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\Program Files\Java<br>OK，jdk安装完成，在cmd中，输入<code>$ java -version</code>验证是否安装成功。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212225402220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="jdk安装成功" title="" class="">                <p>jdk安装成功</p>            </figure><p>OK。<br><strong>3.3 sdk (需要配置环境变量)</strong><br>下载：跟上面的一样，我都打包了。<br>链接：<a href="https://pan.baidu.com/s/1mje7ZHu" target="_blank" rel="noopener">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</p><p>解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。<br>将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\Program Files\SDK<br>接着配置环境变量，我的电脑——右键属性——-高级系统设置——-环境变量。<br>在下面的系统变量(s)中，新建，键值对如下：<br>name: ANDROID_HOME<br>key: C:\Program Files\SDK<br>如图所示：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212230110171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SDK环境变量" title="" class="">                <p>SDK环境变量</p>            </figure><p>然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\bin缀在最后面，前面有【;】分隔符。</p><p>然后运行CMD，输入<code>$ android -h</code>，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212230459827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ANDROID环境配置验证" title="" class="">                <p>ANDROID环境配置验证</p>            </figure><p>现在，打开SDK目录下的SDK Manager.exe<br>打开界面上的Tools,选择options，先配置国内镜像：</p><p>域名千万不要输入http或者https协议前缀，谁输谁哭。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212231404498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="配置镜像" title="" class="">                <p>配置镜像</p>            </figure><p>下面记得勾选。<br>回到主界面，点packages再点reload<br>先勾选如下图的三个Tools:<br>分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools]<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212230934859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Tools" title="" class="">                <p>Tools</p>            </figure></p><p>别急，还没完，下面还有一个：<br>[SDK platform]<figure class="image-box">                <img src="http://img.blog.csdn.net/20180212231104690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SDK platform" title="" class="">                <p>SDK platform</p>            </figure></p><p>全部选中后，点右下角 install packages 来安装，耐心等待即可。<br><strong>3.4 gradle安装(需要配置环境变量)</strong><br>打开：<a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">http://services.gradle.org/distributions/</a><br>下载：gradle-4.1-bin.zip<br>同样安装在JDK,SDK的目录下，便于查找。<br>同样的配置环境变量：<br>GRADLE_HOME=C:\Program Files\SDK\gradle-4.1<br>;%GRADLE_HOME%\bin</p><p>测试命令（查看版本）：gradle -v</p><h2 id="3-基本流程"><a href="#3-基本流程" class="headerlink" title="3.基本流程"></a>3.基本流程</h2><p>1.安装ionic和cordova </p><p>打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g ionic cordova</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224442812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="安装ionic和cordova" title="" class="">                <p>安装ionic和cordova</p>            </figure><p>2.创建ionic项目</p><p>桌面右键，在此处gitbash<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ionic start app tabs</span><br></pre></td></tr></table></figure></p><p>耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ionic serve</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212224746544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ionic serve" title="" class="">                <p>ionic serve</p>            </figure><p>稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示：</p><p><img src="http://img.blog.csdn.net/20180212224825825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="CHROME预览"></p><p>如果做到这一步没问题，说明：<br>1.nodejs与gitbash没有问题。<br>2.ionic和cordova没有问题。</p><h2 id="4-打包"><a href="#4-打包" class="headerlink" title="4.打包"></a>4.打包</h2><p>确保SDK,JDK没问题以后，使用指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ionic cordova build android --release</span><br></pre></td></tr></table></figure></p><p> (如果这条命令有问题，可以去掉–release然后debug编译，编译完成Dos会显示apk目录位置)</p><p>如若你聪慧的双眼发现如下字眼：Build Success!  即可关闭本网页，说明你已经成功打包了。</p><p>OK，此时你已经有了debug的包，但是这个包没有签名，不能发布。</p><p>此时，我们应该：<br>    First：在JDK目录下的bin文件夹下（C:\Program Files\Java\jdk1.8.0_71\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。</p><p>Second：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。<br>执行完命令1，继续执行命令2即可完成签名打包。</p><p>命令1：生成签名密钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>keytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000</p><p>命令2：给文件签名<br>使用刚才生成的zhangqiang.keystore   -signedjar   签名后的apk   签名之前的apk  签名包别  </p><p>jarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180212234119134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="签名完成" title="" class="">                <p>签名完成</p>            </figure><p>如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！<br>后续的软件压缩打包可以百度：jarsigner打包</p><h2 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5.疑难杂症"></a>5.疑难杂症</h2><p><strong>5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to <code>undefined</code> to prevent this warning.</strong></p><p> 出现这个提示，说明配置不正确。</p><p> 解决方法：<br>  在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> postcssOptions = &#123;  </span><br><span class="line"><span class="keyword">from</span>: <span class="literal">undefined</span>,  </span><br><span class="line">to: path_1.basename(sassConfig.outFile),  </span><br><span class="line">map: autoPrefixerMapOptions  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>5.2 安卓SDK组件缺失/缺少/不匹配</strong><br>报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A problem occurred configuring project &apos;:CordovaLib&apos;.</span><br><span class="line">&gt; You have not accepted the license agreements of the following SDK components:</span><br><span class="line">  [Android SDK Build-Tools 26.0.2].</span><br></pre></td></tr></table></figure><p>原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。<br>解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。</p><p><strong>5.3 缺少安卓构建/打包工具</strong><br>报错报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,</span><br><span class="line">or on your system to install the gradle wrapper. Please include gradle</span><br><span class="line">in your path, or install Android Studio</span><br><span class="line">(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure><p>原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。<br>解决办法：<br>去<a href="http://services.gradle.org/distributions/" target="_blank" rel="noopener">http://services.gradle.org/distributions/</a> 下载 gradle-4.1-bin.zip<br>配置相应的环境变量：</p><p>GRADLE_HOME=E:\software\gradle-3.0<br>PATH=%PATH%;%GRADLE_HOME%\bin</p><p>测试命令（查看版本）：gradle -v</p><p>完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。) </p><p>感谢收看。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79319408&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="SDK" scheme="http://yoursite.com/tags/SDK/"/>
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="APP" scheme="http://yoursite.com/tags/APP/"/>
    
      <category term="IONIC" scheme="http://yoursite.com/tags/IONIC/"/>
    
      <category term="gradle" scheme="http://yoursite.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录</title>
    <link href="http://yoursite.com/2018/03/08/2018%E5%B9%B41%E6%9C%8823%E6%97%A5%E8%85%BE%E8%AE%AFSNG-IMWeb%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%20%E7%94%B5%E8%AF%9D%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/03/08/2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录/</id>
    <published>2018-03-08T14:13:16.121Z</published>
    <updated>2018-02-22T03:05:32.743Z</updated>
    
    <content type="html"><![CDATA[<!--<script type="text/javascript">if(window.prompt('请输入密码')==123456){alert('password success')}else{alert('password error');window.history.back(-1);}          </script>--><p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79158495" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>   2018年1月18日，突然接到一个来自深圳的电话，对方说从拉勾网上看到我投递腾讯SNG部门的IMWEB团队前端，简单询问了一下我的具体情况，包括前端的就职年限，过去的工作经历。其中有一点比较有意思的是，对方问我为什么2016年7月毕业直到2017年2月入职中国XX网，这之间的简历是空缺的？我回答他说因为刚毕业没有太好的就业选择和机会，错过了很多校招，所以在毕业的时候去一个艺术培训学校当了半年的吉他老师，因为觉得和前端的职业经历没有关系，因此没有把这段经历写在简历上。对方说，我觉得你应该把这段经历也写在简历上，我说好的谢谢。<br>      接着问了他招聘的是什么职位，对方说是前端工程师，我说主要负责什么工作？他说主要负责腾讯课堂的一些前端工作，我跟对方说，我目前还在老家，可能无法及时的去深圳那边面试，问了他可不可以远程面试，遂对方跟我说，可以采用电话面试，并且约定了电话一面的时间，2018年1月23日。</p><h2 id="面试的过程及结果"><a href="#面试的过程及结果" class="headerlink" title="面试的过程及结果"></a>面试的过程及结果</h2><p>从接到电话直到第一次面试的这段时间，我在网上大量的检索了关于腾讯电面的经验，并且深入的针对一些常用的考点，进行梳理和总结，例如：闭包、原型、作用域链、Ajax、http协议、盒模型、兼容问题、xss/csrf攻击、浏览器渲染（重绘重排）等。<br>在1月23日的当天，5点多回家，还一直在看复习资料，饭也顾不上吃。<br>7点，从深圳打来了一个熟悉的电话。整个电话持续了40分钟之久，基本上问的都是基本的原理，而后可能我的回答让面试官也比较满意，之后是1个半小时的远程监控编程环节，三道程序设计题，给一个半小时的时间，腾讯面试官远程QQ协助监控你的桌面，只允许用浏览器的console以及本地编辑器，不允许查询资料，在编程过程中，面试官还会试图针对一些有问题的地方给予提示。最后，我还是很遗憾的没有通过，因为三道编程题目，我磕磕巴巴基本上没做出来，所以挂了，把文件打包发送给面试官后。我问面试官，像我这样经历不丰富，简历不突出的，为什么会考虑我呢？面试官说，我们什么阶段的人选都会考虑，你入行前端一年，基础还是不错的，就是编码能力需要提高。。。<br>面试完以后，大概有几个小时，一直沉浸在刚才的面试里，晚饭也忘了吃了，一直在反思自己哪些地方答的不够好，这几天的复习哪些地方有疏漏。<br>我的互联网公司处女面就以失败告终了。但是回头想想，这次失败的经历是一面镜子，让我清楚的认识到自己几斤几两，督促我在今后的学习中一步一个脚印，脚踏实地，再去仰望星空。</p><h2 id="电话里问到的题目"><a href="#电话里问到的题目" class="headerlink" title="电话里问到的题目"></a>电话里问到的题目</h2><p>接下来，根据我当天的通话录音，来对所问到的题目进行穷举：</p><p>  <strong>1.接你现在的工作主要是偏前端还是偏后端？我看你大学的课程主要是偏后端一点？</strong></p><p> A:大学课程修完以后，出来没找到工作，干了半年吉他老师，对自己就业比较迷茫。回        到老家以后，干前端、运维都有，但是主要是前端。</p><p> <strong>2.接触前端多久了？接触/学习的渠道是什么？</strong></p><p> A：满打满算一年。刚开始是同事辅导，慢慢入手以后，在W3CSCHOOL、网易云课堂、腾讯课堂、慕课网学习。</p><p> <strong>3.Ajax发送请求的步骤？</strong></p><p>   3.1 xhr.open()</p><p>   3.2 xhr.send()</p><p>   3.3 callback()</p><p> <strong>4.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</strong></p><p> <strong>5.事件代理，事件委托是什么意思？</strong></p><p> <strong>6.闭包是怎么回事？用在什么场景？</strong></p><p>   6.1   变量常驻内存会带来什么问题？</p><p>   6.2   如何避免这种问题？</p><p>   6.3   怎么销毁？</p><p><strong>7.CALL和Apply是干嘛的？</strong></p><p><strong>8.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</strong></p><p>   8.1.如何进行CORS跨域？需要什么条件？</p><p>   8.2 对服务器来说，返回json数据和JSONP数据有什么不一样？</p><p>   8.3 还有其他跨域方式吗？</p><p><strong>9.简单说一说盒模型，W3C和IE怪异盒模型。</strong></p><p><strong>10.简要阐述XSS和CSRF攻击及防范</strong></p><p>  10.1 XSS脚本劫持，如何截获？(ps.这里居然把CSRF的概念当做XSS的来回答….)</p><p>  10.2 CSRF域名劫持</p><p><strong>11.强类型语言有继承，在JS里面如何做到继承呢？(<em>proto</em>和prototype)</strong></p><p>   11.1 例如构造函数有一个test()方法，prototype上也有一个test()，这两个方法有区别吗？</p><p><strong>12.页面性能优化有哪些方式？</strong></p><p>   12.1 文件、脚本合并是如何优化的呢？</p><p>   12.2 重绘，重排是怎么回事？有什么区别？</p><p>   12.3 请举例说明重绘，什么情况下会重绘？</p><p>   12.4 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？</p><p>   <strong>13.浏览器如何知道一个文件资源是否需要缓存？</strong></p><p>   <strong>14.HTTP状态码304,502,503</strong></p><p>   14.1 <em>1,2,3,4,5</em> 开头的状态码都表示什么？</p><p>  <strong>15.Node、Vim、angular简述</strong></p><p>  15.1 Node上如何处理异常情况？（Ps.我回答的是开发调试。。。找js文件）<br> 15.2 已经上线的项目，出问题，怎么样去处理异常？</p><p>   <strong>16.构建工具除了Webpack，还接触过其他的吗？</strong></p><p> 16.1 Webpack的优点和应用场景？</p><h2 id="编程大题"><a href="#编程大题" class="headerlink" title="编程大题"></a>编程大题</h2><p> 1、页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。</p><p>2、实现超出整数存储范围的两个大正整数相加 function add(a, b) 。<br>注意：参数 a 和 b 以及函数的返回值都是字符串。</p><p>3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。</p><p>这个环节基本上就知道自己GG了。。。</p><p>第一题考基本功，DOM、事件、定位、jsAPI</p><p>第二题考算法，基本逻辑</p><p>第三题考原理，基础</p><p>不得不说面试官的技术确实比较全面，腾讯的远程面试也是好狠，直接远程监控写代码的。。。鼠标和界面都不敢静止，静止可能就会被认为作弊（不知道他们是不是这样来判断的，反正我没有停下来过）。</p><p>以下是做完所有题目后跟面试官的沟通记录。天真的我以为会被眷顾招入鹅厂，然鹅我想多了。。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180125112701622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图1" title="" class="">                <p>图1</p>            </figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180125112711300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图2" title="" class="">                <p>图2</p>            </figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180125112723206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图3" title="" class="">                <p>图3</p>            </figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180125112738983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图4" title="" class="">                <p>图4</p>            </figure><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--
&lt;script type=&quot;text/javascript&quot;&gt;

if(window.prompt(&#39;请输入密码&#39;)==123456){

alert(&#39;password success&#39;)

}else{
alert(&#39;password error&#39;);window.
      
    
    </summary>
    
    
      <category term="腾讯SNG-IMWeb面试" scheme="http://yoursite.com/tags/%E8%85%BE%E8%AE%AFSNG-IMWeb%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>用原生js制作一个动态简历(多动症简历)及在线预览部署过程</title>
    <link href="http://yoursite.com/2018/01/29/%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86(%E5%A4%9A%E5%8A%A8%E7%97%87%E7%AE%80%E5%8E%86)%E5%8F%8A%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/29/用原生js制作一个动态简历(多动症简历)及在线预览部署过程/</id>
    <published>2018-01-29T09:18:00.000Z</published>
    <updated>2018-02-01T07:18:37.659Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79197651" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="本项目Fork地址-欢迎Star-："><a href="#本项目Fork地址-欢迎Star-：" class="headerlink" title="本项目Fork地址(欢迎Star)："></a>本项目Fork地址(欢迎Star)：</h2><p><a href="https://github.com/ZQ-jhon/resume" target="_blank" rel="noopener">https://github.com/ZQ-jhon/resume</a></p><h2 id="本项目预览地址-Preview-Address"><a href="#本项目预览地址-Preview-Address" class="headerlink" title="本项目预览地址(Preview Address)"></a>本项目预览地址(Preview Address)</h2><p>Preview :  <a href="https://zq-jhon.github.io/resume/" target="_blank" rel="noopener">多动症简历</a></p><h2 id="项目起因"><a href="#项目起因" class="headerlink" title="项目起因"></a>项目起因</h2><p>因为在网上看到一个大神做的动态简历，如连接所示：</p><p><a href="http://strml.net/" target="_blank" rel="noopener">http://strml.net/</a></p><p>炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。</p><h2 id="引用的第三方库"><a href="#引用的第三方库" class="headerlink" title="引用的第三方库"></a>引用的第三方库</h2><p>1.jQuery  实际用到的地方只有1%</p><p>2.prism   代码高亮库。用到30%</p><p>3.marked.js markdown语法转html的库，实际用到20%</p><h2 id="技术概要"><a href="#技术概要" class="headerlink" title="技术概要"></a>技术概要</h2><p>通篇中使用的技术难度并不大，主要有：</p><ul><li><p><strong>核心原理：</strong>同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。</p></li><li><p>字符串提取、拼接。</p></li><li><p>setInterval定时器控制整个代码的吞吐节奏/速率。</p></li><li><p>在setInterval中设定一些if，用来控制总字符串的吞吐位置。</p><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><p><strong>1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释/</strong>/，要对/进行转义，如下`\/<em>这里填写你的内容</em>\/。**</p></li></ul><p><strong>2.字符串的命名一定要切实合理： 如图所示：</strong></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129213013960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="字符串的命名" title="" class="">                <p>字符串的命名</p>            </figure><p><strong>3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n&gt;123&amp;&amp;n&lt;321)这种方法来进行区域渲染。prism的渲染代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">官方js库地址：[http://prismjs.com/](http://prismjs.com/)</span><br><span class="line"></span><br><span class="line">语法:prism.heihlight(渲染的字符串,渲染的代码格式)</span><br><span class="line"></span><br><span class="line">Prism.highlight(str.substring(0,n), Prism.languages.css);</span><br></pre></td></tr></table></figure><p><strong>4.MarkDown ⇒ HTML渲染 ：  同样根据n的值，来使用if()来进行循环。</strong></p><p>marked.js官方库地址：<a href="https://www.npmjs.com/package/marked" target="_blank" rel="noopener">https://www.npmjs.com/package/marked</a></p><p>渲染代码如下:</p><p><code>drawBoard.innerHTML =marked(str.substring(929,1885));</code></p><p><strong>5.动态创建Pre标签（id=”drawBoard”）  ：  CSS代码版是一开始写在HTML的，但是之后的简历板子（id=”drawBoard”，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：</strong></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129214532614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="动态创建drawBoard" title="" class="">                <p>动态创建drawBoard</p>            </figure><p><strong>6.已经创建的元素无法在另外的循环中获取 ：</strong><br> <strong>在刚才的【5】中，动态创建的pre标签(id=”drawBoard”)会在if()的区域内无法document.getElementById(‘drawBoard’)，此时需要在if里面再次获取并且赋值，如图所示：</strong></p><p><img src="http://img.blog.csdn.net/20180129214929626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="再次赋值"></p><p><strong>7.动态下拉   同样通过n的值来让元素的溢出自动下拉</strong></p><p>如图：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129215552841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="动态下拉" title="" class="">                <p>动态下拉</p>            </figure><p><strong>8. 动态简历最后的魔术环节  ：   还是通过n的值来进行判断，从而渲染 </strong></p><p>其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。</p><p>代码如图：</p><p><img src="http://img.blog.csdn.net/20180129215916887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="魔术效果实现"></p><h2 id="核心原理代码"><a href="#核心原理代码" class="headerlink" title="核心原理代码"></a>核心原理代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义</span><br><span class="line"></span><br><span class="line">var styleTag = document.getElementById(&apos;styleTag&apos;);</span><br><span class="line"></span><br><span class="line">var sourceBoard = document.getElementById(&apos;sourceBoard&apos;);</span><br><span class="line"></span><br><span class="line">var str = &apos;\/*大家好...今天我给大家做一个在线简历...\/*&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var n = 0;</span><br><span class="line">window.setInterval(function()&#123;</span><br><span class="line">   n++;</span><br><span class="line">   styleTag.innerHTML = str.substring(0,n);</span><br><span class="line">    </span><br><span class="line">   sourceBoard.innerHTML = str.substring(0,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;,100);</span><br><span class="line"></span><br><span class="line">//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。</span><br></pre></td></tr></table></figure><h2 id="Demo部署到GitHub详细过程"><a href="#Demo部署到GitHub详细过程" class="headerlink" title=" Demo部署到GitHub详细过程"></a> Demo部署到GitHub详细过程</h2><p>本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180129220933667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gh-pages预览项目" title="" class="">                <p>gh-pages预览项目</p>            </figure><p>在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。</p><p>整个部署的环节大致如下：</p><ol><li><p>在本地的项目根目录下，<code>$ git init</code></p></li><li><p>加入当前所有文件到暂存区 <code>$ git add .</code>(后面有个“·”，代表全部文件)</p></li><li><p>连接远程仓库  <code>$ git remote add origin &quot;your repository address&quot;</code></p></li><li><p>提交所有文件到git版本控制系统 <code>$ git commit -m &quot;create Demo resume&quot;</code></p></li><li><p>push到你的远程仓库 <code>$ git push origin master</code></p></li><li><p>打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。</p><p>PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub</p><h2 id="反思与不足"><a href="#反思与不足" class="headerlink" title="反思与不足"></a>反思与不足</h2></li></ol><ol><li>在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。</li></ol><ol><li><p>我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。</p><p>我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：<a href="http://strml.net/" target="_blank" rel="noopener">http://strml.net/</a>的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。</p></li><li>整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。</li></ol><ol><li>整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。</li></ol><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79197651&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="动态简历" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86/"/>
    
      <category term="Github部署" scheme="http://yoursite.com/tags/Github%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>基于HEXO的个人博客图文搭建详尽过程，看不懂算我输</title>
    <link href="http://yoursite.com/2018/01/18/%E5%9F%BA%E4%BA%8EHEXO%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%96%87%E6%90%AD%E5%BB%BA%E8%AF%A6%E5%B0%BD%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%9C%8B%E4%B8%8D%E6%87%82%E7%AE%97%E6%88%91%E8%BE%93/"/>
    <id>http://yoursite.com/2018/01/18/基于HEXO的个人博客图文搭建详尽过程，看不懂算我输/</id>
    <published>2018-01-18T08:08:00.000Z</published>
    <updated>2018-01-30T01:08:31.104Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79096846" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>须知：</strong><br><em>1.最终生成的博客地址必须是： ZQ-jhon.github.io  即用户名.github.io</em><br><em>2.本地的HEXO仓库，命名必须也为 ZQ-jhon.github.io ，HEXO项目放置于该目录之下。</em></p><p>昨天经过一番折腾，终于将HEXO部署上线了，以下对于昨天整个搭建的过程做一个详细的回顾。</p><p>HEXO是基于NODE的一款博客框架，有很多丰富的主题可以选择，配合GIT来使用。</p><p>Git回顾：<a href="http://blog.csdn.net/qq_20264891/article/details/78773371" target="_blank" rel="noopener">本地仓</a>、<a href="http://blog.csdn.net/qq_20264891/article/details/78774208" target="_blank" rel="noopener">远程仓</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>整个安装过程我是参考一位博主：<a href="http://www.chenyijun.net/2016/06/04/hexo_teach_1/" target="_blank" rel="noopener">HEXO系列教程</a></p><p>以下用自己的理解来做一番梳理与归纳：</p><p>*先介绍HEXO中的4个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g #完整命令为hexo generate，用于生成静态文件  </span><br><span class="line">$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览  </span><br><span class="line">$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上  </span><br><span class="line">$ hexo n #完整命令为hexo new，用于新建一篇文章</span><br></pre></td></tr></table></figure><p>首先，确保本地Git公钥与Github公钥相匹配，参照：<a href="http://blog.csdn.net/qq_20264891/article/details/78773371" target="_blank" rel="noopener">Git本地仓</a></p><p>确认匹配后，新建Repository，命名的时候，规范为：</p><p>github名字.github.io</p><p>因此，这里的新仓库名字应该为： ZQ-jhon.github.io</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118155548420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>同样的，在本地新建一个同名的目录：ZQ-jhon.github.io  ，然后打开目录，文件夹是空的</p><p><strong>此时，在项目目录下右键打开Gitbash here</strong></p><p>1.<code>$ cnpm install hexo-cli -g</code>&nbsp; &nbsp; &nbsp; 使用淘宝镜像安装hexo-cli</p><p>2.<code>npm install hexo-deployer-git --save</code>&nbsp;&nbsp;&nbsp; 模块安装到开发目录</p><p>3.<code>$ hexo init</code>&nbsp;&nbsp;&nbsp;初始化</p><p>4.<code>$cnpm install</code>&nbsp;&nbsp;&nbsp;安装依赖</p><p>（PS：中途如果出现问题，可以 <code>cnpm install hexo-deployer-git --save 安装GIT的PUSH插件）</code><br>5.<code>$hexo g &amp;&amp; hexo s</code> 构建(genereater)并启动服务(server)，在locallhost:4000下即可预览效果</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118154519905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><h2 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h2><p>本地的文件我们已经在locallhost:4000端口预览的非常满意了，如何部署到站点(github)上呢？</p><p>1.首先，找到HEXO目录下的 __yml文件，在最下面修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ZQ-jhon/ZQ-jhon.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118154939998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title="" class="">                <p></p>            </figure><p><strong><em>注意：如下图所示，这里的repository地址就是Github download时弹出的项目地址，但是最好不要用HTTPS协议，走SSH协议，昨天因为这个问题，调试了一下午！！！</em></strong></p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118155710430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>2.布置好以后，我们来Ping一下Github，看能否有响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118155238282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>欢迎了一波，很稳。</p><p>此时，直接把Server   Ctrl + C</p><p>然后 <code>$HEXO D</code>&nbsp;&nbsp;&nbsp;直接推送，稍等片刻，打开Github仓库，看看文件是否上传成功</p><p>如果上传成功，大功告成，打开 <a href="https:ZQ-jhon.github.io" target="_blank" rel="noopener">https:ZQ-jhon.github.io</a>即可访问博客页面了。</p><h2 id="文章新建与MarkDown语法"><a href="#文章新建与MarkDown语法" class="headerlink" title="文章新建与MarkDown语法"></a>文章新建与MarkDown语法</h2><p>新建文章 <code>$hexo n filename</code></p><p>这个比较简单，建完文件，也别秀骚操作了，老老实实去source文件夹的_post文件夹里面，去用一个好点的编辑器，修改文本文档，保存为UTF-8格式，并且修改后缀名为.md，保存类型为所有类型，否则上线部署会产生乱码。</p><p>值得一提的是，CSDN的在线文档编辑器就采用的是MarkDown语法，而且该种语法与标签语言完全兼容，因此，可以将HTML代码原封不动的全被拷贝近.md文件。</p><p>##主题更换与配置##</p><p>在我们HEXO根目录下，有一个themes文件夹，里面存放的都是各式各样的主题，默认的是landscape，我们可以去官网，HEXO的THEME分类下下载更多精美的主题，然后解压缩，将文件夹放在themes下，另外稍微修改 __yml文件下，theme:lanscape 即可。</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118160508595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>相关的配置，我们可以follow官方推荐作者的github去看看人家的wiki或者code，都有详尽的说明，甚至可以加QQ咨询……</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118160644506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><h2 id="最终效果与总结"><a href="#最终效果与总结" class="headerlink" title="最终效果与总结"></a>最终效果与总结</h2><p>Welcome to the ZQ-jhon.github.io wiki!<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118163837782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="基本效果预览" title="" class="">                <p>基本效果预览</p>            </figure><br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118163853108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="文章详情预览" title="" class="">                <p>文章详情预览</p>            </figure><br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180118163911153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="搜索模块预览" title="" class="">                <p>搜索模块预览</p>            </figure></p><p>不得不说GITHUB开源生态真的非常强大，感谢这些开发者带来的精美主题。</p><p>感谢主题作者Miachel.Lu<a href="https://github.com/codefine/hexo-theme-mellow" target="_blank" rel="noopener">HEXO-Mellow-theme  点击查看该项目</a></p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79096846&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="HEXO" scheme="http://yoursite.com/tags/HEXO/"/>
    
      <category term="动态部署" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Webpack打包工具学习笔记</title>
    <link href="http://yoursite.com/2018/01/17/Webpack%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/17/Webpack打包工具学习笔记/</id>
    <published>2018-01-17T03:18:00.000Z</published>
    <updated>2018-01-19T06:54:18.498Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/u014717036/article/details/51001311" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79078776" target="_blank" rel="noopener">我的CSDN博客</a><br>前言：Webpack是一款基于node的前端打包工具，它可以将很多静态文件打包起来，自动处理依赖关系后，生成一个.js文件，然后让html来引用，不仅可以做到按需加载，而且可以减少HTTP请求，节约带宽。</p><h2 id="1-配置与安装"><a href="#1-配置与安装" class="headerlink" title="1.配置与安装"></a>1.配置与安装</h2><p>在node已经安装完成的前提下，全局安装webpack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd d:</span><br><span class="line"></span><br><span class="line">$ mkdir test &amp;&amp; cd test  //创建test ，并进入</span><br><span class="line"></span><br><span class="line">$ npm install -g webpack  //等待100s，安装完成，也可以使用淘宝镜像</span><br><span class="line"></span><br><span class="line">$ npm init //初始化package.json文件</span><br><span class="line"></span><br><span class="line">$ npm install --save-dev webpack //添加依赖 ，在package.json中声明依赖,等待安装完成</span><br></pre></td></tr></table></figure><h2 id="2-基本操作-webpack-main-js-webpack-js"><a href="#2-基本操作-webpack-main-js-webpack-js" class="headerlink" title="2.基本操作$webpack main.js webpack.js"></a>2.基本操作<code>$webpack main.js webpack.js</code></h2><p>当前目录下创建如下工作结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/---------test</span><br><span class="line"></span><br><span class="line">   ----app</span><br><span class="line">     ----main.js</span><br><span class="line">     ----index.js   </span><br><span class="line">     </span><br><span class="line">   ----index.html</span><br></pre></td></tr></table></figure><p>项目目录下，app文件夹含有两个js文件，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//main.js ，这是Webpack主要的入口文件</span><br><span class="line"></span><br><span class="line">  require(&apos;./index.js&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//index.js ，这是被主文件引用的文件</span><br><span class="line"></span><br><span class="line">document.write(&apos;Hello,world!&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//index.html ，供浏览器解读</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;./webpack.js&quot;&gt;  // 引用同目录下的webpack.js</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>webpack.js是哪来的呢？就是通过webpack打包生成的js文件，接下来，</p><p>开始生成webpack.js文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack main.js webpack.js</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180116202114667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>可以看到已经打包成功了，此时查看IDE中的项目目录，根目录下已经多了一个webpack.js文件。然后用浏览器打开index.html，效果如下：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180116202235717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>此时查看网页源代码：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180116202405946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>66666666666！</p><h2 id="3-进阶操作-（配置webpack-config-js或者配置package-json，后者依赖前者）"><a href="#3-进阶操作-（配置webpack-config-js或者配置package-json，后者依赖前者）" class="headerlink" title="3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）"></a>3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）</h2><p>每次在命令行敲目录调试，是很痛苦的，因此需要一次配置，多次使用的方法。</p><p>在根目录下新建文件： webpack.config.js  (名字就是这样，规定，不能改)，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports  = &#123;</span><br><span class="line">//入口文件位置</span><br><span class="line">    entry:__dirname+&apos;/app/main.js&apos;,</span><br><span class="line"></span><br><span class="line">//出口</span><br><span class="line">    output:&#123;</span><br><span class="line">   //路径</span><br><span class="line">        path:__dirname,</span><br><span class="line">        filename:&apos;webpack.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 __dirname是一个node的全局变量，用于指向当前的工作目录，调皮的我console.log了一下这个变量：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180116203051747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>确认无疑。</p><p>这样，我们的webpack.js写完以后，可以直接在命令行中敲：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br></pre></td></tr></table></figure><p>可以发现，项目中也同样的会生成目标js文件，也就是webpack.js，这样非常方便，省事。 </p><p>还有一种配置方法，将package.json文件中”scripts”里面添加键值对：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180116203453509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><p>这样同样可以在项目目录生成目标js文件，直接在 命令行里敲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start //因为webpack是全局安装的，直接value给webpack，而不用跟路径</span><br></pre></td></tr></table></figure><p>如果start被占用了/冲突了，也可以在scripts下面自定义一个键值对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;zq&quot;:&quot;webpack&quot;</span><br><span class="line"></span><br><span class="line">$ npm run zq //稍作修改cmd 命令</span><br></pre></td></tr></table></figure><p>最后还是可以生成。</p><h2 id="4-webpack服务器监听代码变动，自动刷新及source-map"><a href="#4-webpack服务器监听代码变动，自动刷新及source-map" class="headerlink" title="4.webpack服务器监听代码变动，自动刷新及source-map"></a>4.webpack服务器监听代码变动，自动刷新及source-map</h2><p>4.1关于source-map，也就是在webpack.config.js中配置 devtool (develpment tool)的值，例如我这样配置：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180117094811412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>在webpack完成文件打包后，会自动生成一个与目标文件相同名的 .map文件，用来说明打包文件的每个地方对应的是哪些文件，简而言之，让你能知道源码是在哪里错的，帮你刨根问底，而不用开发者自己去Debug。</p><p>参考文章1：<a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">入门WEBPACK，看这篇文章就够了—-简书</a></p><p>参考文章2：<a href="https://www.cnblogs.com/axl234/p/6500534.html" target="_blank" rel="noopener">Webpack中的sourcemap</a></p><p>4.2 webpack服务器 </p><p>首先单独安装 server 包 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure><p>同样的，在webpack.config.js中做出相应的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devtool: &apos;source-map&apos;,</span><br><span class="line">    entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;./&quot;,//本地服务器加载index.html页面所在的目录，这里写的是根目录</span><br><span class="line">        historyApiFallback: true,//不跳转</span><br><span class="line">        inline: true//实时刷新,</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好config后，还得配置一下package.json，在scirpts里面添加server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;, </span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>接着，在命令行运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ npm run server </span><br><span class="line"></span><br><span class="line">/*届时服务器会自动启动， 并且打开浏览器,默认端口为8080，也可以</span><br><span class="line">devServer:&#123;</span><br><span class="line"></span><br><span class="line">port:4040 //自己配置端口为4040</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个服务器跑起来后的演示结果，我不断的修改work.js 中 <code>document.write</code>的值，从而服务器会自动检测并刷新页面：</p><p><img src="http://img.blog.csdn.net/20180117100531064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="5-非JS文件的操作-img-json-css……-猪脚：Loaders"><a href="#5-非JS文件的操作-img-json-css……-猪脚：Loaders" class="headerlink" title="5.非JS文件的操作(img,json,css……),猪脚：Loaders"></a>5.非JS文件的操作(img,json,css……),猪脚：Loaders</h2><p> <strong>5.0 基本概念</strong><br> 前面都在说js文件，官网说什么文件都可以当做模块打包，下面就来试试非js文件。</p><p>首先要明确的是，webpack只能识别js文件，如果要识别非js文件，就需要loader来解析这些文件。</p><p>loaders 需要单独安装，并且在webpack.config.js中的modules关键字下进行配置。</p><p>Webpck2以上已经支持对json的解析打包，不需要额外的loaders，可以在main.js中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var json = require(&apos;../package.json&apos;)//json在它的上级目录</span><br><span class="line"></span><br><span class="line">document.write(json.scripts.server);</span><br></pre></td></tr></table></figure><p>运行结果 ：</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20180117101705406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>可见，网页中，没有通过任何第三方loader，即可将json解析并打包成bundle.js。</p><p><strong>5.1 Bable </strong><br>Bable可以使得开发者使用最新的ECMAscript标准来书写代码，而不用管新标准是否被当前使用的浏览器完全支持。</p><p>还是需要单独安装Bable的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel-core babel-loader babel-preset-env </span><br><span class="line"></span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>安装完成后，在webpack.config.js下的module关键字下进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &apos;source-map&apos;,</span><br><span class="line">  </span><br><span class="line">    entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">    </span><br><span class="line">    output: &#123;</span><br><span class="line">    </span><br><span class="line">        path: __dirname,</span><br><span class="line">        </span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    devtool: &apos;eval-source-map&apos;,</span><br><span class="line">    </span><br><span class="line">    devServer: &#123;</span><br><span class="line">    </span><br><span class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">        </span><br><span class="line">        historyApiFallback: true,//不跳转</span><br><span class="line">        </span><br><span class="line">        inline: true//实时刷新</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    module: &#123;</span><br><span class="line">    </span><br><span class="line">        rules: [</span><br><span class="line">        </span><br><span class="line">            &#123;</span><br><span class="line">            </span><br><span class="line">                test: /\.js$/, //正则匹配，必须</span><br><span class="line">                </span><br><span class="line">                use: &#123; //使用到的loader</span><br><span class="line">                </span><br><span class="line">                    loader: &quot;babel-loader&quot;,  //loader名</span><br><span class="line">                    </span><br><span class="line">                    options: &#123;   //选项</span><br><span class="line">                    </span><br><span class="line">                        presets: [ //预先配置</span><br><span class="line">                        </span><br><span class="line">                            &quot;env&quot;</span><br><span class="line">                            </span><br><span class="line">                        ]</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;,</span><br><span class="line">                </span><br><span class="line">                exclude: /node_modules/ //不包含的目录或文件</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>5.2 CSS文件处理 </strong><br>webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p><p>同样先安装两个包 style-loader和css-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">          &#123;.......&#125;，</span><br><span class="line"> &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;style-loader&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &quot;css-loader&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">也可以简写：</span><br><span class="line">&#123;</span><br><span class="line">test:/\.css$/.</span><br><span class="line"></span><br><span class="line">use:[&#123;</span><br><span class="line"></span><br><span class="line">loader:&quot;style!css&quot;  //这里的执行顺序是从右往左，css应该在style之前执行</span><br><span class="line"></span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>根目录下新建 ./src/index.css，写一个body的背景为green，然后在入口文件main.js中,require(‘../src/index.css’)，接着通过命令行<code>$ webpack</code></em><br>此时查看index.html，发现页面背景已经变成绿色<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180117110627698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><h2 id="6-插件plugins"><a href="#6-插件plugins" class="headerlink" title="6.插件plugins"></a>6.插件plugins</h2><p>先安装插件的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install html-webpack-plugin</span><br></pre></td></tr></table></figure><p>在webpack.config.js中 头部，引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let webpack = require(&apos;webpack&apos;);</span><br></pre></td></tr></table></figure><p>然后在webpack.config.js中配置根键值对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">      new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180117111652412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/u014717036/article/details/51001311&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>css3原理，结合jquery复习</title>
    <link href="http://yoursite.com/2018/01/17/css3%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BB%93%E5%90%88jquery%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/01/17/css3原理，结合jquery复习/</id>
    <published>2018-01-17T03:18:00.000Z</published>
    <updated>2018-01-19T07:03:06.100Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79019724" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="0-怪异盒模型"><a href="#0-怪异盒模型" class="headerlink" title="0.怪异盒模型"></a>0.怪异盒模型</h2><p>非IE及IE9及以上， 盒模型的构成为:content<br>老IE，IE8及以下， 盒模型为 content+border+padding<br>如果有这样一个DIV：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;width:100px;height:100px;border:1px solid black;padding:10px;&#125;</span><br></pre></td></tr></table></figure><p>在非IE下，盒模型为：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180110092905668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>在老IE下，盒模型为：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180110092944223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>由此可见，老IE在计算盒模型时，加入了两个padding和border的值。</p><h2 id="1-background-size"><a href="#1-background-size" class="headerlink" title="1.background-size"></a>1.background-size</h2><p>规定背景的位置。<br>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#div&#123;background-size:cover;&#125;//覆盖整个div</span><br><span class="line">#div&#123;background:url(img/123.png) no-repeat;background-size:10% 10%;&#125;//背景图片宽高为原始图片宽高的10%，且不重复</span><br></pre></td></tr></table></figure><h2 id="2-background-orgin"><a href="#2-background-orgin" class="headerlink" title="2.background-orgin:"></a>2.background-orgin:</h2><p>//可以选择的值为：content-box、margin-box、padding-box</p><p><strong><em>content-box、margin-box、padding-box的区别</em></strong></p><p>①content-box，即采用W3C标准渲染方法，不计算padding和border及margin，得出的盒子<br>②padding-box，渲染盒子的时候，把padding当做盒子宽高的组成部分，即在标准盒子模型的基础上，宽高都增加padding px。<br>③margin-box，同理，宽高都增加margin-box<br>3.border-radius  圆角边框，假如DIV 的  宽 = 高，即正方形，此时，如果border-radius = div 的宽/高，那么此时的div是一个圆形。如果border-radius远远大于div的宽/高，那么还是一个圆形，不会变化。<br>因此，background-origin的值，就取决于背景图从哪个盒子模型开始渲染。</p><h2 id="4-text-shadow-水平偏移-垂直偏移-阴影距离文字的z-index距离-颜色"><a href="#4-text-shadow-水平偏移-垂直偏移-阴影距离文字的z-index距离-颜色" class="headerlink" title="4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色"></a>4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">text-shadow: 225px 0px 0px #FF0000; /*水平偏移225，垂直不偏移 z-index为0 颜色为红色*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180110095154859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><h2 id="5-font-face-自定义字体"><a href="#5-font-face-自定义字体" class="headerlink" title="5.font-face 自定义字体"></a>5.font-face 自定义字体</h2><p>兼容度：IE及IE8以下不支持，主流浏览器都支持。<br>关于自定义字体，请参见我之前的一篇博客：<br><a href="http://blog.csdn.net/qq_20264891/article/details/78438174" target="_blank" rel="noopener">自定义图标与百度Share API</a></p><h2 id="6-Css3-之-2D转换-transform"><a href="#6-Css3-之-2D转换-transform" class="headerlink" title="6.Css3 之 2D转换 (transform)"></a>6.Css3 之 2D转换 (transform)</h2><p>释义：transform 改变;变换<br>兼容度：IE9及以上，主流浏览器都兼容。<br>下面列举的方法，都位于transform属性之下，例如：transform:rotate()、transform:translate()<br>主要的2D转换属性：<br><strong>6.1  位移：  translate()   方法 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;transform：translate(100px,100px)&#125; /*在原来位置的基础上，x轴移动10px，y轴移动10px*/</span><br></pre></td></tr></table></figure><p>如图所示：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180110101251395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><p>原本处于空白位置的DIV，现在x,y轴都平移了正的100px<br><strong>6.2 旋转   rotate() 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">img&#123;transform：rotate(30deg)&#125;</span><br><span class="line"> /*图片顺时针旋转30度，当然，也可以和css伪类配合完成一些效果 ，例如 ：*/</span><br><span class="line"> img:hover&#123;transform:rotate(30deg)&#125; /*鼠标悬停，方可旋转*/</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180110102120286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>由此可见，这个效果在一些圆形的图片上最为适用</p><p><strong>6.3 比例/缩放 scale(x轴比例，y轴比例) 方法</strong><br>跟刚才的旋转同理，我们也可以给一个图片设定一:hover伪类，然后来观察效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*文档结构：父div包含着一个图片，父div标准盒子模型100x100，原始图片100x100 */</span><br><span class="line"></span><br><span class="line">div&#123;width:101px;height:101px;overflow:hidden;border:1px solid black;&#125;</span><br><span class="line"></span><br><span class="line">img:hover&#123;transform: scale(1.5,1.5);&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180110102627735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>这个效果也很常见。鼠标放进去放大，鼠标离开变成原始比例。<br>关于这一点，可以参照之前的博客：<br><a href="http://blog.csdn.net/qq_20264891/article/details/78949964" target="_blank" rel="noopener">关于CSS3呼吸效果的探究</a><br><strong>6.4 偏斜/歪斜  skew(x轴偏斜,y轴偏斜)</strong><br>以前见过很多用CSS3做的留言墙，skew属性用的比较多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img:hover&#123;transform:skew(30deg,30deg)&#125;</span><br></pre></td></tr></table></figure><p>鉴于这个方法比较扭曲，就不上图了，值得注意的一点是，这个偏移量貌似根据tan来计算的，当我给这个方法传入90deg时，图片会不存在。<br><strong>6.5 矩阵/汇总方法 matrix</strong><br>martrix()接受6个参数，其实就是对于 平移、旋转、缩放、偏斜的汇总简写。<br>具体请参见张鑫旭大神的博客：<br><a href="http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">理解CSS3 transform中的Matrix(矩阵)</a></p><h2 id="7-Css3之3D转换-（Oprea不支持3D转换）"><a href="#7-Css3之3D转换-（Oprea不支持3D转换）" class="headerlink" title="7. Css3之3D转换 ##（Oprea不支持3D转换）"></a>7. Css3之3D转换 ##（Oprea不支持3D转换）</h2><p><strong>7.1    3D旋转 rotateY()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div:hover&#123;transform: rotateY(180deg)&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180110123324497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>框中的文字，其本身围绕Y轴旋转180°</p><h2 id="8-Transition-过渡效果"><a href="#8-Transition-过渡效果" class="headerlink" title="8.Transition 过渡效果"></a>8.Transition 过渡效果</h2><p>兼容度：IE9及以下不支持该属性，需要优雅降级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div&#123;width:100px;height:100px;background:yellow;transition:width:width 2s;&#125;</span><br><span class="line">div:hover&#123;width:300px;&#125;</span><br></pre></td></tr></table></figure><p>效果如图（鼠标移入，DIV变宽，鼠标移出，自动复原）：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180111092602675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="鼠标移入，DIV变宽" title="" class="">                <p>鼠标移入，DIV变宽</p>            </figure></p><p>此时，我们在div:hover中重写了属性width，那么，在原始的div{transition}中，我们要说明，那个属性需要过渡效果，并注明过渡时间，此时肯定是transition:width 2s，如果有多个属性需要过渡效果，那么，就应该给出如下说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition:all 2s   //所有属性都需要过渡效果，并且所有效果同步过渡的总时长为2s.</span><br></pre></td></tr></table></figure><p>如此一来，就可以实现类似于jquery的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;div&apos;).animate(&#123;width:&apos;101px&apos;;height:&apos;101px&apos;;background:&apos;green&apos;;&#125;)</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180111115416020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>甚至可以规定过渡的delay延时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition-delay:0.5s;  //0.5秒延时以后开始动画效果。</span><br></pre></td></tr></table></figure><p>效果与上图大同小异，不过有0.5s的移入和移出延时。<br>其实，在transition里有4个属性，分别是：<br>1.过渡的属性名称<br>2.过渡的总时长<br>3.过渡的方式:线性，缓慢等等<br>4.过渡的延时，即多少s以后才开始过渡<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">transition-property: width;</span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;transition:width 2s linear 2s&#125;</span><br></pre></td></tr></table></figure><h2 id="9-CSS3-动画"><a href="#9-CSS3-动画" class="headerlink" title="9.CSS3 动画"></a>9.CSS3 动画</h2><p>之前一篇帖子对于动画部分做了一些探究：<br><a href="http://blog.csdn.net/qq_20264891/article/details/78949964" target="_blank" rel="noopener">关于CSS3呼吸效果的探究 </a><br>如果对于动画的需求比较复杂，需要持续重复的完成，可以考虑动画效果，如果只是简单的一些效果，完全可以采用transform来自己实现。</p><h2 id="10-CSS-3-多列"><a href="#10-CSS-3-多列" class="headerlink" title="10.CSS 3 多列"></a>10.CSS 3 多列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">-moz-column-count:3; /* Firefox */</span><br><span class="line">-webkit-column-count:3; /* Safari and Chrome */</span><br><span class="line">column-count:3;</span><br><span class="line">&#125;</span><br><span class="line">/*将一个DIV分为三列*/</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180111133322968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>以及最后的最后，有一个允许用户自定义元素大小(可拖拽拉伸)的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">border:2px solid;</span><br><span class="line">padding:10px 40px; </span><br><span class="line">width:300px;</span><br><span class="line">resize:both;</span><br><span class="line">overflow:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20180111135633726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79019724&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Angular搭建后台人员管理系统 1.1.0</title>
    <link href="http://yoursite.com/2018/01/17/Angular%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-1-1-0/"/>
    <id>http://yoursite.com/2018/01/17/Angular搭建后台人员管理系统-1-1-0/</id>
    <published>2018-01-17T03:18:00.000Z</published>
    <updated>2018-01-19T07:00:13.467Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/78863387" target="_blank" rel="noopener">我的CSDN博客</a></p><p>今天基于原来的DEMO，将功能进行了调整。<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20171221142259866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>如图所示，增加了一个新的controller，完成了增删改查的最后一步：查。</p><p>step1中还是使用ng-repeat遍历出的options，然后这个select又绑定了一个model，可以在controller用于判定用户的选项，然后根据这个选项，在users的数组中进行查找，最后，显示在查询结果的框中。</p><p>今天遇到的几个问题：<br>1.数据可视化和canvas视图留了一个坑。<br>2.突然发现controller之间的方法、变量不可以共享，例如我在下面的控制器中创建的用户数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$scope.users=[</span><br><span class="line">&#123;...&#125;,</span><br><span class="line">&#123;...&#125;,</span><br><span class="line">&#123;...&#125;,</span><br><span class="line">&#123;...&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在上面查询控制器中无法访问，网上查询之，得到结果，原因是作用域无法访问，这点跟js比较像，两个在树形结构上是兄弟层级关系的节点，不能访问对方的内部变量。但是angular 可以像js一样，变量继承，因此，可以吧users挂到 相对比较高的祖先节点上，这样，其子控制器就可以访问到了。<br>3.在Step1的位置，出现了F5以后，默认出现一个空白options的现象，查看元素，得知该元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;option value=&quot;  undefind!&quot;&gt;&lt;/option&gt;</span><br></pre></td></tr></table></figure><p>于是采用了一个笨办法，手动添加一个<br><code>&lt;option value=&quot;&quot; selected=&quot;&quot;&gt;&lt;/option&gt;</code><br>然后，在ng-repeat的原始option选项中，也添加<code>selected=&quot;selected&quot;，这样就OK了！</code><br>4.今天对各个控制器进行合理的切分，达到模块化的效果，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*********根控制器的数据*********/</span><br><span class="line"> app.controller(&apos;rootctrl&apos;,function($scope)&#123;</span><br><span class="line"> $scope.users = [</span><br><span class="line"> &#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;,</span><br><span class="line"> &#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;,</span><br><span class="line"> &#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;,</span><br><span class="line"> &#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;,</span><br><span class="line"> &#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;,</span><br><span class="line"> &#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125;</span><br><span class="line"> </span><br><span class="line"> ];</span><br><span class="line"> &#125;)</span><br><span class="line">/**********增加用户 控制器*************/</span><br><span class="line"> $scope.addUser = function()&#123;</span><br><span class="line">       var index = $scope.users.length-1;</span><br><span class="line">  </span><br><span class="line">       $scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;);</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br><span class="line"> /**********查询 控制器************ /</span><br><span class="line"> $scope.jiansuo = function()&#123;</span><br><span class="line"> var a = $scope.selectValue;</span><br><span class="line"> $scope.result = a;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     if(a==&quot;&quot;||null||undefined)&#123;</span><br><span class="line">     document.getElementById(&apos;sp&apos;).innerHTML=&quot;未选择/未输入!&quot;;</span><br><span class="line">     document.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请先选择分类&apos;)</span><br><span class="line">     &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">     document.getElementById(&apos;sp&apos;).innerHTML=&quot;您要查询的&quot;+$scope.infos[a].name+&quot;是:&quot;+$scope.input;</span><br><span class="line">     document.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请输入具体的&apos;+$scope.infos[a].name+&quot;！&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#125;;</span><br><span class="line"> /********删除 控制器***********/</span><br><span class="line">    </span><br><span class="line">      $scope.remove = function(index)&#123;</span><br><span class="line">      </span><br><span class="line">//   if($scope.users.length&lt;=1)&#123;</span><br><span class="line">//   $scope.users.splice(index,1)</span><br><span class="line">//   &#125;</span><br><span class="line">//   else&#123;&#125;</span><br><span class="line">         $scope.users.splice(index,1)</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">            </span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><p>在切分这些控制器的过程中，一定要注意各个控制器的作用域，以及能否访问到调用数据。<br>GitHub:<br><a href="https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master" target="_blank" rel="noopener">https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master</a></p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/78863387&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="angularjs" scheme="http://yoursite.com/tags/angularjs/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS3呼吸效果的探究</title>
    <link href="http://yoursite.com/2018/01/17/%E5%85%B3%E4%BA%8ECSS3%E5%91%BC%E5%90%B8%E6%95%88%E6%9E%9C%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/01/17/关于CSS3呼吸效果的探究/</id>
    <published>2018-01-17T03:18:00.000Z</published>
    <updated>2018-01-19T06:57:55.004Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/78949964" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="一、效果预览"><a href="#一、效果预览" class="headerlink" title="一、效果预览"></a>一、效果预览</h2><figure class="image-box">                <img src="http://img.blog.csdn.net/20180102103428658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。</p><h2 id="二、方案选择"><a href="#二、方案选择" class="headerlink" title="二、方案选择"></a>二、方案选择</h2><p>刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。</p><p>这个效果的实现，如果采用jquery的方案，直接写个动画即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//先设定好position:relative;</span><br><span class="line">$(&apos;img:hover&apos;).animate(&#123;&apos;left&apos;:&apos;10px&apos;,&apos;bottom&apos;:&apos;10px&apos;&#125;);</span><br></pre></td></tr></table></figure><p>假如追根溯源，还是使用的CSS3的动画。<br>首先自定义一个动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@keyframes testAnimate&#123;</span><br><span class="line"></span><br><span class="line">from&#123;position: relative;bottom: 0;left: 0;&#125;</span><br><span class="line"></span><br><span class="line">to&#123;position: relative;bottom: 20px;left: 30px;border: 5px solid #999;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。</p><p>接着，我们在测试的图片用例上来引入动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img:hover&#123;</span><br><span class="line">animation:testAnimate 1s;</span><br><span class="line">-webkit-animation:testAnimate  1s;</span><br><span class="line">-moz-animation:testAnimate  1s;</span><br><span class="line">-o-animation:testAnimate  1s;</span><br><span class="line">-ms-animation:testAnimate 1s;</span><br><span class="line">&#125;</span><br><span class="line">//整个动画1s完成，并设置了浏览器兼容</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180102110628693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img:hover&#123;</span><br><span class="line">animation-fill-mode: forwards;</span><br><span class="line">-ms-animation-fill-mode:forwards;//兼容IE  xxxxxx  </span><br><span class="line">-webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx</span><br><span class="line">-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx</span><br><span class="line">-o-animation-fill-mode:forwards;//兼容opear xxxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。</p><h2 id="三、分析归纳"><a href="#三、分析归纳" class="headerlink" title="三、分析归纳"></a>三、分析归纳</h2><p>众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行</p><p>预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/78949964&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Html5回顾总结</title>
    <link href="http://yoursite.com/2018/01/12/Html5%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/12/Html5回顾总结/</id>
    <published>2018-01-12T02:53:00.000Z</published>
    <updated>2018-01-19T06:57:07.888Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/79041618" target="_blank" rel="noopener">我的CSDN博客</a></p><h2 id="1-新标签"><a href="#1-新标签" class="headerlink" title="1.新标签"></a>1.新标签</h2><p><strong>1.1 <code>&lt;vedio&gt;</code></strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">Your browser does not support the video tag.</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><p>两个video source源是为了最大程度的兼容所有浏览器，该标签IE8及以下不支持。<br>比较重要的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">预加载   preload:preload</span><br><span class="line">自动播放 autoplay:autoplay</span><br><span class="line">循环播放 loop:loop</span><br></pre></td></tr></table></figure><p>常见的高大上的背景视频上嵌套文字的效果可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">video&#123;z-index:-99999;float:left;position: relative;left:300px;&#125;</span><br><span class="line">h4&#123;color:white&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;video width=&quot;320&quot; height=&quot;240&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">Your browser does not support the video tag.</span><br><span class="line">&lt;/video&gt;</span><br><span class="line">&lt;div style=&quot;float:left;width:320px;height:240px;z-index:999&quot;&gt;</span><br><span class="line">   &lt;h4&gt;震惊！野生棕熊竟然对猎物熟视无睹&lt;/h4&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>给<code>video</code>给z-index：负数 ，给嵌套层的文字给 z-index：正数，然后相对定位，接着取消<code>video</code> 的controls属性，这样会隐藏音量条，播放/暂停按钮等控件。<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180112101024552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>类似于该网站的页头：<a href="http://cos.qq.com/" target="_blank" rel="noopener">英雄之刃官网</a></p><p>在js中，可以把<code>&lt;video&gt;</code> 完全当做一个Dom节点，操作他的相关属性。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;video&apos;).pause()//暂停</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;video&apos;).play()//播放</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;video&quot;).currentSrc;//获得原始播放地址</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;video&quot;).currentTime//获得播放器当前播放位置，单位为s</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;video&quot;).duration //获得视频的整个播放时长</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>还有特别多的API，例 如 EVENT：刚开始播放、结束播放、视频的网络状态等等，甚至可以结合播放时间，来控制插入广告。。。<br><strong>1.2 audio  </strong><br>与上述视频同理。兼容度更狭隘：IE9及以上<br><strong>1.3 拖放 Drag 和 drop</strong><br>兼容度：IE9、IE9+<br>示例：<a href="http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop" target="_blank" rel="noopener">W3C拖放示例</a><br><strong>1.4 Canvas</strong><br><em>“始于苹果的一项技术，使得Javascript具有图像绘制的能力”。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//HTML:</span><br><span class="line">&lt;canvas id=&quot;cvs&quot; height=&quot;200&quot; width=&quot;200&quot;&gt;</span><br><span class="line">  您的浏览器不支持&lt;canvas&gt;标签</span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">//JS:</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var c=document.getElementById(&quot;cvs&quot;);  //获取</span><br><span class="line">var cxt=c.getContext(&quot;2d&quot;);  //canvas对象特有的方法，目前仅仅支持到2D，未来可能会支持3D...</span><br><span class="line">cxt.fillStyle=&quot;green&quot;; //填充颜色 </span><br><span class="line">cxt.fillRect(0,0,150,75); //（x,y,width,height）绘制起始点坐标，绘制的宽高</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>贴上自己做的demo<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20180112115334236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><p>未完待续。。。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/79041618&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>Express快速构建应用(一)</title>
    <link href="http://yoursite.com/2017/12/25/Express%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/12/25/Express快速构建应用/</id>
    <published>2017-12-25T03:27:00.000Z</published>
    <updated>2018-01-19T06:58:47.304Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/78890797" target="_blank" rel="noopener">我的CSDN博客</a></p><p>Express是基于Nodejs的前端应用构建工具，可以快速开发基于Node的前端SPA，在Nodejs的基础上，又进行一些功能的扩充，使得应用的构建流程非常简单高效，应用也足够健壮。</p><h2 id="1-安装与-环境配置"><a href="#1-安装与-环境配置" class="headerlink" title="1.安装与 环境配置"></a>1.安装与 环境配置</h2><p>首先使用IDE建一个工程目录，放在Nodejs.exe 的同域目录下。<br>然后打开Git bash,输入，然后进入工程目录，接着 <code>$npm init</code> 表明我们要创建一个应用，最后疯狂回车，可以看到，在工程目录里自动生成了package.json文件。<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225112504969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><p>接下来安装Express，命令行敲：<code>$npm install express --save</code>将express包存放到我们的工程目录里，甚至还可以将其在json文件中声明依赖关系，只需要多加一个-dev：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install express --save-dev</span><br></pre></td></tr></table></figure><p>接着会看到工程目录里出现了modules子目录，并且已经为我们下载好了express及其依赖的包（看上图）。</p><p>接下来，我们创建一个app.js，放在工程子目录，app.js代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line">var express = require(&apos;express&apos;); //require进来我们的Express</span><br><span class="line">var app = express(); //实例化</span><br><span class="line"></span><br><span class="line">//匹配任意路由，都返回下面这句：first test success</span><br><span class="line">app.get(&apos;/&apos;,function(req,res)&#123;</span><br><span class="line">res.send(&apos;first test success!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//接着配置server</span><br><span class="line">var server = app.listen(3000,function()&#123;</span><br><span class="line">console.log(&apos;绑定到了3000端口&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在命令行敲：<code>$node app.js</code>，打开浏览器输入127.0.0.1:3000 可以看到”first test success”<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225113447312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><h2 id="2-路由功能"><a href="#2-路由功能" class="headerlink" title="2.路由功能"></a>2.路由功能</h2><p>在进入一些网页的时候，会看到后面的url坠着 index.html，这是网站的homepage，如果去列表页，则后缀会变成: list.html，这个其实就是路由，根据请求的url不同，服务器返回不同的路径。<br>而express可以很好的胜任这个功能。下面来看<br>在刚才的app.js中加入一些代码，并创建新的index.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line">//使用get请求到index.html时，会向页面吐出一个index.html的文件</span><br><span class="line">app.get(&apos;/index.html&apos;,function(req,res)&#123;</span><br><span class="line">res.sendfile(&apos;./index.html&apos;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;gekki&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;hello&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;ke;llt&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接着，继续运行<code>$node app.js</code>，网页中输入URL：127.0.0.1:3000/index.html<br>效果如图：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225130220554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><p>成功了！</p><p>在命令行中，会提示<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225130107618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>提示我们 : res.sendfile不太赞成使用，应该使用驼峰式命名 res.sendFile。。。粗心了。<br>由上述例子可知，express对于路由的配置非常之简单。设想一下，在一些需要密码和表单操作密集的地方，可以采用post请求来进行路由的配置。那么同理，如果想要加载图片或者加载其他问价，则可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//表单的html</span><br><span class="line">app.post(&apos;/form.html&apos;,function(req,res)&#123;</span><br><span class="line">res.sendFile(&apos;./form.html&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//访问路由的某个图片</span><br><span class="line">//all方法用于 匹配所有的请求类型，不管是post,get,put,delete等等都给他返回指定的东西，一视同仁。</span><br><span class="line">app.all(&apos;./longzhu.png&apos;,function(req,res)&#123;  </span><br><span class="line">res.sendFile(&apos;./img/longzhu.png&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3.静态资源"></a>3.静态资源</h2><p>所谓的静态资源，就是一旦网页生成，就不会再被改变了。例如：图片，CSS,JS文件等。<br>我们可以将这些文件放置在一个统一的文件夹里面，命名为：public<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225130726717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure></p><p>现在，在public下粘贴一张图片，接下来，我们来看这些静态资源应该如何配置以及访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line">app.use(express.static(&apos;./public&apos;));//一句话就完成了静态资源的配置</span><br></pre></td></tr></table></figure><p>接着，在浏览器中输入:127.0.0.1:3000/xxx.png ，我们可以得到效果：<br><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225130939742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><br>说明静态资源配置成功，同理，我们在来试试其他类型的文件:</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225131120326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><figure class="image-box">                <img src="http://img.blog.csdn.net/20171225131151137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>都OK。</p><p>有时候，可以在一个路由请求中写多个callback函数，来不断的匹配用户输入的需求路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line"></span><br><span class="line">app.get(&apos;/123.error&apos;,callback1,callback2);</span><br></pre></td></tr></table></figure><p>此时，如果第一个callback捕获不到路由，则将皮球提给第二个callback函数来执行，不过要在第一个callback中写明白参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function(req,res,next)&#123;</span><br><span class="line">console.log(&apos;对不起，我没找到，现在请下一个回调函数帮你找&apos;)</span><br><span class="line">next();</span><br><span class="line">&#125;,</span><br><span class="line">function (req,res)&#123;</span><br><span class="line">console.log(&apos;find it!&apos;);</span><br><span class="line">res.sendFile(&apos;123.error&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个回调函数甚至可以组成一个数组，来对用户的请求进行匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">回调函数1:  </span><br><span class="line">var a = function(req,res,next)&#123;</span><br><span class="line">....</span><br><span class="line">next();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">回调函数2:</span><br><span class="line">var b = function(req,res,next)&#123;</span><br><span class="line">....</span><br><span class="line">next();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">回调函数3:</span><br><span class="line">var b = function(req,res)&#123;</span><br><span class="line">....</span><br><span class="line">console.log(&apos;找到了!&apos;);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&apos;/123.error&apos;,[a,b,c]);  //这样写很美观</span><br></pre></td></tr></table></figure><p>当然也可以使用数组和function(){}的混合写法，但是这样写我想不出来哪个地方有好处？</p><p>在访问不同的路由时，不必从新restar server，因为服务器是在返回本地的目录，这个状态是一直轮询的，如果有就返回，没有就老老实实报错404 .</p><p>当然，整个路由匹配的时候，甚至可以使用正则魔法，以防止用户的误输入行为，防患于未然。</p><h2 id="4-API走马观花"><a href="#4-API走马观花" class="headerlink" title="4.API走马观花"></a>4.API走马观花</h2><p>1.res.download()     提示下载文件。  //res.download(‘文件名’)，<br>2.res.end()     终结响应处理流程。<br>3.res.json()     发送一个 JSON 格式的响应。<br>4.res.jsonp()     发送一个支持 JSONP 的 JSON 格式的响应。<br>5.res.redirect()     重定向请求。 //更改用于在根url之后的路由，例如用户输入了:127.0.0.1:3000/index.html<br>我们可以<code>res.redirect(&#39;error.html&#39;);</code>，此时浏览器的url会自动变成：127.0.0.1:3000/error.html</p><p>6.res.render()     渲染视图模板。<br>7.res.send()     发送各种类型的响应。<br>8.res.sendFile     以八位字节流的形式发送文件。<br>9.res.sendStatus()     设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。//express预设好了，我就试了两个:<br><code>res.sendStatus(200)//页面显示：OK</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.sendStatus(404)//页面显示：Not Found</span><br></pre></td></tr></table></figure><p>留坑。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/78890797&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Express" scheme="http://yoursite.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Angular1.4.6 &amp; Bootstrap3.3.7搭建后台人员管理系统 1.0.0</title>
    <link href="http://yoursite.com/2017/12/19/Angular1-4-6-Bootstrap3-3-7%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-1-0-0/"/>
    <id>http://yoursite.com/2017/12/19/Angular1-4-6-Bootstrap3-3-7搭建后台人员管理系统-1-0-0/</id>
    <published>2017-12-19T07:35:00.000Z</published>
    <updated>2018-01-19T07:56:49.299Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/78842927" target="_blank" rel="noopener">我的CSDN博客</a></p><p><strong>前言：接触前端快1满一年了，从什么都不会，一步步摸索，走到现在，觉得前方的路还是很迷茫，但是每天感觉自己都在进步，这是最好的！希望自己能坚持下去，也跟各位同仁共勉！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@important message!</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;Manage-system-By-AngularJs&quot;,</span><br><span class="line">    &quot;version&quot;:&quot;1.0.0&quot;,</span><br><span class="line">    &quot;author&quot;:&quot;ZQ-jhon&quot;,</span><br><span class="line">    &quot;connect&quot;:&quot;QQ:350037310&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上全部效果的演示图：<br>Let’s view together:</p><figure class="image-box">                <img src="http://img.blog.csdn.net/20171220094856558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="GIF加载中，请耐心等待... ..." title="" class="">                <p>GIF加载中，请耐心等待... ...</p>            </figure><h2 id="1-Angualr和Bootstrap的火花"><a href="#1-Angualr和Bootstrap的火花" class="headerlink" title="1.Angualr和Bootstrap的火花"></a>1.Angualr和Bootstrap的火花</h2><p>Angular是开发SPA的得力框架，其数据双向绑定和指令系统能够最大程度的保持页面的</p><p>整洁干净，而Bootstrap作为一个UI库，也能够很好的满足本系统的需求。</p><h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h2><p>2.1 在后台人员管理系统中，需要有以下功能：增、删、改、查。</p><p>为了实现这些功能，就必须在项目中留好数据接口，方便跟后台数据进行I/O操作。</p><p>2.2 为了实现部分功能的 toggle()，例如：</p><ol><li><p>点击编辑，文本框的可编辑状态会来回在:  可编辑/不可编辑  切换。</p></li><li><p>点击编辑，删除button的 show 与 hidden。</p></li></ol><p>必须使用一个ng-show = bool/ng-disabled = !bool，bool的具体方法每次访问，会</p><p>更改布尔值为对立值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//初始化:</span><br><span class="line">$scope.bool = true;</span><br><span class="line"></span><br><span class="line">//调用改变自身布尔值</span><br><span class="line">$scope.toggle = function()&#123;        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$scope.bool = !$scope.bool;  //谁调谁改变</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个<code>$scope</code>的bool()方法，应该位于<code>$rootscope</code>是最好的解决方式，所有的局部</p><p>controller都可以访问到根作用域。</p><p>因此，改写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$rootscope.toggle = function()&#123;        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$rootscope.bool = !$scope.bool;  //谁调谁改变</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><p>3.1 框架搭建 ：使用bootstrap搭建框架</p><p>3.2 初始数据展示：为了让用户有一个直观的展示，当前界面上会mock一些假的数据上</p><p>去，仅供参考(当然这些数据也可以删除)，mock的方法为，在<code>$scope</code>上绑定一个数</p><p>组，该数组是对象数组，然后用过ng-repeat来展现在我们的bootstrap表格中。</p><p>3.3 框架代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class="line">            &lt;h1 class=&quot;text-center&quot;&gt;增删改查后台管理系统&lt;/h1&gt;</span><br><span class="line">       &lt;table class=&quot;table table-responsive table-hover&quot;&gt;</span><br><span class="line">           &lt;thead&gt;</span><br><span class="line">               &lt;tr&gt;</span><br><span class="line">                   &lt;td&gt;序号&lt;/td&gt;</span><br><span class="line">                   &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">                   &lt;td&gt;年龄&lt;/td&gt;</span><br><span class="line">                   &lt;td&gt;职务&lt;/td&gt;</span><br><span class="line">                   </span><br><span class="line">               &lt;/tr&gt;</span><br><span class="line">               &lt;tr&gt;</span><br><span class="line">                   &lt;td&gt;&lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot;&gt;编辑&lt;/span&gt;&lt;/td&gt;</span><br><span class="line">               </span><br><span class="line">                   &lt;td&gt;&lt;/td&gt;</span><br><span class="line">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class="line">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class="line">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class="line">                   &lt;td&gt;&lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;</span><br><span class="line">                   </span><br><span class="line">               &lt;/tr&gt;</span><br><span class="line">           &lt;/thead&gt;</span><br><span class="line">       &lt;/table&gt;</span><br><span class="line">       </span><br><span class="line">       &lt;button class=&quot;btn btn-success&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/i&gt;创建新用户&lt;/button&gt; </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">        &lt;/body&gt;</span><br></pre></td></tr></table></figure><p>3.4 ng指令系统的控制原理与规划过程 </p><p>  3.4.1     指令构建</p><pre><code>首先在表格上声明 `ng-app =&quot;myapp&quot;`并且声明控制器`ng-controller=&quot;ctrl&quot;`接着，在需要toggle切换的地方赋值，如果默认要false,可以使用   ng-show=&quot;!bool&quot;或者 ng-disabled=&quot;bool&quot;这里因为初始值是：   `$scope.bool = true`</code></pre><p>  然后，在$<code>scope</code>上绑定初始数据，即一个对象组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      var app=angular.module(&apos;myApp&apos;,[]);</span><br><span class="line">app.controller(&apos;ctrl&apos;,function($scope)&#123;</span><br><span class="line">$scope.users = [</span><br><span class="line">&#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;,</span><br><span class="line">&#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;,</span><br><span class="line">&#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;,</span><br><span class="line">&#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;,</span><br><span class="line">&#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;,</span><br><span class="line">&#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125;</span><br><span class="line"></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>  有了元数据，就可以为所欲为了，在需要的位置，例如 table 中的 tr 进行ng - repeat</p><p>循环，循环的结果是</p><h1 id="对象数组中每一个对象！"><a href="#对象数组中每一个对象！" class="headerlink" title="对象数组中每一个对象！"></a>对象数组中每一个对象！</h1><p>然后在对应的<code>&lt;td&gt;&lt;/td&gt;</code>中使用或者balalala进行取值</p><p>   为了完成自动化序号排列以及删除功能，需要$index服务，不需要依赖注入。</p><pre><code>当每个删除按钮点击的一瞬间，Angular如何判断该删除哪个呢？我们为每一个删除按钮button添加一个指令 `ng-click = &apos;remove($index)&apos;`</code></pre><p>这里，Angular就是通过<code>$index</code>来自行判定当前的行序。来看这一块的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr ng-repeat=&quot;user in users&quot;&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot; ng-click=&quot;toggle()&quot;&gt;编辑&lt;/span&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">    &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.name&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.age&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.job&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;button class=&quot;btn btn-danger&quot; ng-click=&quot;remove($index)&quot; ng-show=&quot;!bool&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><p>OK，删除，排序，Toggle功能都完成了，还有一个增加新用户怎么完成呢？</p><p>这个更简单了，直接往Object Array 里 push 对象即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/****这是增加用户按钮的指令*****/</span><br><span class="line">ng-click = &quot;addUser()&quot;</span><br><span class="line"></span><br><span class="line">/*****以下是js*****/</span><br><span class="line"></span><br><span class="line"> $scope.addUser = function()&#123;</span><br><span class="line">       var index = $scope.users.length-1;  //确定当前最大的行序（ps.本来想自己实现 $index 功能的。。。）</span><br><span class="line">  </span><br><span class="line">       $scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;);</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>以上，就完成了一个后台管理系统，这是初始版本，后续我会增加新的功能在里面。</p><h2 id="4-初步完成alpha版本，觉得还是有很多不足之处："><a href="#4-初步完成alpha版本，觉得还是有很多不足之处：" class="headerlink" title="4.初步完成alpha版本，觉得还是有很多不足之处："></a>4.初步完成alpha版本，觉得还是有很多不足之处：</h2><p>1.数据很糙，很杂，controller中的东西太过冗杂，而我并没有选择使用构建工具来模块</p><p>化、打包、合并，这不是一个好习惯。</p><p>2.所有的输入框没有加入过滤器，例如：姓名的位置我们可以用filter或者正则来强行限</p><p>定只能输英文，而不是数字或者标点。 这是一个细节不够完善的地方。</p><p>3.在点下编辑的时候，文本框变得可以编辑，再次点下编辑，文本框变成了丑丑的不可</p><p>编辑，我在想：**</p><h2 id="如何可以使得文字在不可编辑的状态下自动切换为-lt-p-gt-标签，而在可编辑的状态下变成-lt-input-gt-表单？"><a href="#如何可以使得文字在不可编辑的状态下自动切换为-lt-p-gt-标签，而在可编辑的状态下变成-lt-input-gt-表单？" class="headerlink" title="如何可以使得文字在不可编辑的状态下自动切换为&lt;p&gt;标签，而在可编辑的状态下变成&lt;input&gt;表单？"></a>如何可以使得文字在不可编辑的状态下自动切换为<code>&lt;p&gt;</code>标签，而在可编辑的状态下变成<code>&lt;input&gt;</code>表单？</h2><p>**<br>4.自学了这么久ajax,nodejs，然而并没有从后端拉任何数据，所有数据都是angular来</p><p>进行操作的，这样也不好，我希望尽快精通express，来进行项目的全栈构建。</p><p>以上问题留给自己去解决。</p><p>最后，附上我的Github地址，fork 或者 download都可以</p><p>地址：<a href="https://github.com/ZQ-jhon/Manage-system-By-AngularJs" target="_blank" rel="noopener">https://github.com/ZQ-jhon/Manage-system-By-AngularJs</a></p><p>注意：将 index.html中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;以及&lt;link&gt;的src 及 href 替换 成本地目录</span><br></pre></td></tr></table></figure><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/78842927&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="angularjs" scheme="http://yoursite.com/tags/angularjs/"/>
    
  </entry>
  
  <entry>
    <title>关于jQuery中scrollTop中的一些兼容问题。</title>
    <link href="http://yoursite.com/2017/12/13/%E5%85%B3%E4%BA%8EjQuery%E4%B8%ADscrollTop%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/12/13/关于jQuery中scrollTop中的一些兼容问题/</id>
    <published>2017-12-13T05:25:00.000Z</published>
    <updated>2018-01-19T07:04:17.801Z</updated>
    
    <content type="html"><![CDATA[<p>本文初始编辑地址，源自我的CSDN博客：<a href="http://blog.csdn.net/qq_20264891/article/details/78790869" target="_blank" rel="noopener">我的CSDN博客</a></p><p>最近在做一个响应式的页面，需要有按钮来实现点击回到页头及点击回到页尾的功能。<br>在使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#btn&apos;).click(function()&#123;</span><br><span class="line">   $(body).animate(&#123;</span><br><span class="line"> scrollTop:0</span><br><span class="line">   &#125;,speed);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//发现，该功能只在IE与FireFox下有用，Chrome内核无效。</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="http://files.jb51.net/file_images/article/201512/2015123120741782.png?201511312749" alt="这里写图片描述" title="" class="">                <p>这里写图片描述</p>            </figure><p>即：</p><p>选择器为body时：FireFox无效，Chrome有效<br>选择器为html时：Chrome有效，FireFox无效</p><p>因此，在编写代码的时候，只要进行双重选择即可兼容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class="line">var speed = 400; //滑动的速度</span><br><span class="line">$(&apos;html,body&apos;).animate(&#123;</span><br><span class="line">scrollTop: 0</span><br><span class="line">&#125;, speed);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经测试，在IE(9及以上),FireFox及Chome浏览器下，均能正常使用该功能。</p><p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文初始编辑地址，源自我的CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq_20264891/article/details/78790869&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数式编程与响应式编程之己见]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B7%B1%E8%A7%81%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 1. what is 函数式编程？函数，在编程中，通常体现为： 输入 =&gt; 执行 =&gt; 结果。他不是命令式的，而是对一段操作进行逻辑封装，拿到输入，就能产出结果。通常来说，满足函数式编程的特性的“函数”应该有如下特点: 函数必须有入参，并且函数的产出会根据入参的不同而变化。函数执行的整个流程中，不会对全局变量、外部属性等产生影响。函数式编程代码量小，干净。举个例子： 123456789101112var arr = [1,2,3,4,5];function addOne (array) &#123; for(var i=0;i&lt;array.length;i++)&#123; array[i] += 1; &#125; return array;&#125;addOne(arr); // 2,3,4,5,6 写了一个方法，接受一个数组，产出数组每个成员+1，但这段代码的不足之处在于： 难以复用，如果需求提出 addTwo,addThree方法，需要不断修改函数名和内部逻辑。内部的代码很啰嗦， for 循环很low。·函数式编程改进版： 12let arr = [1,2,3,4,5];arr.map(item=&gt; item+1); // 3,4,5,6,7 这里，改进使用了原生的 Array.prototype.map 方法，代码量缩小了很多不说，而且复用性进一步提升。整个函数做的事情现在非常直观，入参 =&gt; 每项参数 + 1 =&gt; 返回新数组，由此，可以说，map()方法是一个纯函数(pure function)。 2. 响应式编程前端中也有一个概念叫响应式，bootstrap 。这里当然说的不是这个，对于响应式编程的概念，我想提及Vue或者 angular的双向绑定来阐述：1234567// template: i'am &#123;&#123; name &#125;&#125;// js:name = 'jhon'; 在前端MVVM的框架中，都有一个数据双向绑定的概念，这里的模版中的变量，实时反映了数据中的 name 变量的 value，而且，如果此时我修改了 name 的值，那么模版中对应的值也会跟着修改。数据 &lt;=&gt; 视图 是同时发生，同时改变的，因为模版就是对数据的一个映射。 再举个例子： c的值，是通过 a + b 来赋值的，如果ab不是固定的，而是变化的值，那么 c 的值也不会固定为3。123let a = 1,b=2;let c = a + b; // 3 不难看出，响应式编程特点： 同步发生，结果会随着修改参数而实时、动态地变化。存在固定的映射关系。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeBB搭建过程（windows+Redis）+ 科学上网方法]]></title>
    <url>%2F2018%2F06%2F22%2FNodeBB%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%88windows%2BRedis%EF%BC%89%2B%20%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 1.首先去 github 把项目 clone 下来：https://github.com/NodeBB/NodeBB 然后cd到nodebb，安装依赖 cnpm i 依赖在安装的时候，由于没有 package.json ，会自动 clone ，整个以来安装完成后，应该是这样： install 2.环境配置附上中文文档：https://docs.nodebb-cn.org/ 1.Chocolatey 可以下载离线包，之后通过 Chocolatey 安装一些环境： 1choco install -y imagemagick github python2 nodejs-lts git 这里的 github , nodejs ，git 可以选择不安装，跳过。2.数据库（database）选择 RedisRedis 可以在菜鸟教程上面找到安装教程：http://www.runoob.com/redis/redis-install.html 安装完成以后，WINDOWS + R 打开 services.msc ，找到 Redis 服务，启动之： Redis 3.Hello World Running首先，使用命令 ./nodebb build 构建静态资源，构建完如下： helloworld 此时打开监听的 127.0.0.1:4567 (默认配置的端口)，如图所示： installer 上面的直接填写，下面的数据库配置如下： database 点击最下面的 install NodeBB 后，整个项目总算 Running 了： running 4 . use LANTERN to cross wall (使用lantern 科学上网)下载lantern安装包 =&gt; 一路next安装，并启动 =&gt; 右下角图标右键 ，连接 =&gt; OK依赖环境 .net FrameWork 4.0 +我都打包好了 :链接：https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow 密码：yyfg 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>node</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单/双向绑定、组件通讯]]></title>
    <url>%2F2018%2F06%2F14%2Fng%E8%8B%B1%E9%9B%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E6%A6%82%E5%BF%B5%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8D%95%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 为什么要学angualr(4.0+)？ 无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。 微软收购了github，还不赶紧学ts？ 本文参考博客/资料：1.https://blog.csdn.net/u012967849/article/details/78767294/ （ng父子组件如何传值）2.https://www.angular.cn/ （ng中文官网）3.https://www.jianshu.com/p/a2b625a99c8d （ng的class和interface区别） 本篇笔记所用环境及NG版本一览： NG版本 文件目录1.组件的文件形式/结构：形如： components 跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。2.打包入口： app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。 moudle 如图：在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。在@NgMoudle中，import则声明了使用的第三方库。在 declarations 中注册了子组件。app目录不仅作为整个项目的打包入口，其本身也是一个根组件。3.模块划分： 根组件/模块 appMoudle 英雄列表 =&gt; heroes 组件 当前选择的英雄=&gt; hero-detail组件 新的ng语法ng新语法: 1234*代表ng指令 不用ng-if,ng-for，类似于驼峰 ngFor ngIf ()代表绑定事件 原生事件绑定直接写在括号里 (click) (keydown)[]单向绑定 代表绑定属性 [name] = &apos;jobs&apos; [()] 双向绑定&lt;input [(value=&quot;someValue&quot;)] type=&quot;text&quot;/&gt; 官方称双向绑定写法叫盒子里的香蕉？？？？？？？ 父子组件状态传递Step1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。Step2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。Step2如图所示： Step2 Step3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。Step3如图所示： Step3 在Vue中，通常是这样做的：子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。angular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。 组件 运作/执行流程 的文字描述 列表组件渲染出Mock的数组 (列表组件 heroes 负责) 为每一个渲染出的项，绑定事件，并传参 (同上) 在列表组件heroes 的模版加入&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;，这样父组件的值已经通过单向绑定至子组件，但接收与使用，决定权在于子组件。（同上） hero-detail组件接收父组件传递过来的数值，并在内部import {Input} from &#39;@angular/core&#39;（hero-detail组件负责） 接着在export语句中，使用装饰器来声明+初始化 得到的属性@Input() hero: Hero;然后就可以用啦！ （hero-detail组件负责） 整体逻辑代码 步骤Step 1创建列表组件，使用*ngFor来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。 12345&lt;li *ngFor=&quot;let thisHero of heroes&quot; (click)=&quot;onSelect(thisHero)&quot;&gt;&lt;/li&gt; 在对应的.ts文件中，这个方法为： 123456789101112131415161718192021//方法 /*定义参数类型为Hero类型，即从hero.ts导出的类： export class Hero &#123; id: number; name: string; &#125; 并且，设定该方法没有返回值。 */onSelect(hero: Hero): void &#123; //动态赋值 this.selectedHero = hero; //业务逻辑相关 this.bool = !this.bool; this.isSelected = &#123; &apos;badge&apos;:!this.bool, &apos;selected&apos;:this.bool &#125;&#125; 这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。Step 2在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：1&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt; 把值绑定到子组件模版，这样，父组件的使命就结束了。Step 3子组件如何接收并使用父组件传来的值呢？首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）import {Input} from &#39;@angular/core&#39;接着，装饰器来申请接收传进来值，声明+初始化二连：1@Input() hero: Hero; 哦，完事了。 此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈来北京后的工作节奏以及对前端的看法]]></title>
    <url>%2F2018%2F05%2F23%2F%E8%B0%88%E4%B8%80%E8%B0%88%E6%9D%A5%E5%8C%97%E4%BA%AC%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%8A%82%E5%A5%8F%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%9C%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 为什么来北京这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。 工作因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。 前端别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于： 熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。 对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。 对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等 对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。 能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。生活来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。很久没有写东西，思路比较乱，想到哪写到哪。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于bootstrap特殊分辨率页面的实现思路]]></title>
    <url>%2F2018%2F04%2F14%2F%E5%9F%BA%E4%BA%8Ebootstrap%E7%89%B9%E6%AE%8A%E5%88%86%E8%BE%A8%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 前言很久没更新博客，这段时间刚刚找到工作，会立即（从今天起）恢复更新博客的频率。罗马不是一天建成的，希望自己保持良好的学习和做笔记的习惯，笔耕不缀，他日可期！ 1.Boostrap重构传统固定px的页面在第一次接手重构任务后，有点懵逼。可能是因为自己很久没有写代码了，忘了以前做的响应式的一些细节，所以又开始不断的调试，总算是把坑补上了，于是在此做一下记录。PSD需求图： 这里写图片描述 整个需求其实蛮简单的，就是一个固定1122px的页面，里面有些图片，图片在pc端需要留出固定margin（需要像素级还原PSD稿）。想了想，自己以前做的响应式都是根据 .container类的默认宽度来写的，于是想了一会便有答案，整体思路如下： 给整个页面给一个 container类，并且限制 max-width 为1122px。 页面中右侧的小兔，因为所有图片都是从后台接口调取，一旦设定img-responsive，那么默认的max-width就是100%(想象一下，如果后台传来一个1000宽的图，用户网络慢点，基本上就GG了)，只能按照原图比例来缩放，何况每个图片的容器都是动态高度的…所以，每张图片的宽高，尽可能的去用js动态设定。 尽量使用Rem，设定好body的font-size，然后各部分的font-size都根据rem去取，例如 0.8rem,0.6rem等等。 布局方面，左侧的长图固定的，非接口调取，宽高固定的。在整个页面中，缩放的比例完全是以此图片作为参照物。因此给此图片加上img-responsive以及col-lg-3 col-md-3 col-sm-6 col-xs-6类，然后动态的让单个盒子容器的高度取 左侧长图的高度，这样会让盒子完美的呈现，不会留有内边距，也不会让box-shadow很难看。右侧的6张小图，每纵向的两个图使用一个列容器来包裹，设定 col-lg-3 col-md-3 col-sm-6 col-xs-6，这样就可以达到在手机端的显示效果，如图所示： 这里写图片描述 2.核心逻辑代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//动态设置每个box-shadow 容器的高度，为imgLong的高度var h = $(&apos;#imgLong&apos;).first().height();$(&apos;.box&apos;).each(function()&#123; $(this).css(&#123; height:h &#125;);&#125;);$(window).resize(function()&#123; var h=$(&quot;#imgLong&quot;).first().height();$(&quot;.box&quot;).each(function()&#123;$(this).css(&#123;height:h&#125;)&#125;);&#125;); //限制h4标签文本长度 $(&apos;.imgTitle&apos;).each(function()&#123; //这里由于后台Trs模版获取的标题，前面有N个空格，因此需要前端来消化一下字数，故进行“空格剔除”，所以用 .split(&apos; &apos;).join(&apos;&apos;) var txt = $(this).text().split(&apos; &apos;).join(&apos;&apos;); if(txt.length&gt;20)&#123; //其实真正的标题就10个字，但是前面有10个空格 $(this).text(txt.substring(0,19)+&apos;...&apos;); &#125; &#125;); //为所有调用的imgShort图片增加CLASS $(&apos;.imgShortParent img&apos;).each(function()&#123; $(this).addClass(&apos;imgShort&apos;);&#125;); //动态设定每个单列容器的宽度 = imgLong的宽度，高度 = imgLong的高度，以此来保证图片不会溢出 box-shadow。var h = $(&apos;.imgLong&apos;).first().height();var w = $(&apos;.imgLong&apos;).first().width();$(&apos;.col-box&apos;).each(function()&#123; $(this).width(w).height(h);&#125;);$(window).resize(function()&#123;//页面缩放时，动态获取宽高，并赋值给 col-box 列容器。 $(&apos;.col-box&apos;).each(function()&#123; $(this).width(w).height(h);&#125;)&#125;) 3.不足与改进思路3.1 页面性能不足，重绘过多，网速慢的时候，会有一瞬间发生：【图片突然很大，然后被缩放到正常比例】的恐怖现象。。。解决方案：可以为每张小图(250*165)包裹一层div，设置max-height与max-width，overflow:hidden，来解决。 3.2 实际上，整个项目我写了两套html骨架（由于项目紧，刚接手，长时间没写代码比较陌生），pc一套，mobile一套，感到非常罪过，不配成为一个前端工程师。。。但是话说回来，原先的项目也写的太TM乱了，一个注释都没有，而且一个页面中script标签不下20个。。。解决方案：用我上述的思路去实现 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记]]></title>
    <url>%2F2018%2F03%2F11%2Ftypescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 前言TypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8…提前为将来的ES标准打下基础。 学习tsc，不亏! 环境搭建1$ cnpm install -g typescript 完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下： 12$ cd your File_path$ tsc File_name.ts OK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。 tsc 类型检测1.基本类型检测 在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如： 12345let a:number = 1; //OKlet a:string = 1; //error类型检测的语法，就是在变量屁股后面缀上 :类型 2.数组的类型检测： 123let arr:number[]=[1,2,3]; //ok 类型+[] let brr:Array&lt;number&gt;=[4,5,6]; //OK 数组泛型+尖括号&lt; 类型 &gt; 3.元组类型 Tupe 1234let X:[number,string];x=[1,&apos;hello&apos;]; //OKx=[1,2]; //type error元组类型适用于已知个数和元素类型的数组。 字符串拼接及字符串模板拼接：跟ES6一样，通过（``）来实现，【`】为Tab上面的按键。 for eg : 123456let hi= (`hello,wrold!`);//输出 hello,world! 字符串模板：提供一种更优雅的书写方式：${ 变量名} for eg: 123456789let names:string = &apos;xiaoming&apos;;let age:number = 23;let sentence:string = (`hello,my name is $&#123;names&#125;,my age is $&#123;age&#125;`); 编译后的js文件为: 1234567var names = &apos;xiaoming&apos;;var age = 23;var sentence = (&quot;\nhello,my name is &quot; + names + &quot;,my age is &quot; + age + &quot;\n&quot;);document.body.innerHTML = sentence; 枚举类型12345enum flower &#123;a,b,c,d,e,f,g&#125;; //enum关键字，后跟枚举类型的命名let rouse:flower = flower.a; //定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性alert(rouse); // 0 表明rouse映射的对象，在flower中的index为0 Any类型有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。 let不能重复定义，我就用var来演示。 Any类型也可以像数组的第一种定义方法一样，形如： 1234567891011121314151617181920Array:let arr:number[]=[1,2,3]; // OK数字的组合，可不就是数组吗？字符串组、布尔值组...let brr:string[] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];let crr:boolean[] = [true,false];Any:let drr:any[]=[1,&apos;2&apos;,true]; // OK只知道是个类似于数组的数据类型，但是对元素的类型不做限制。 Void类型void类型表示空。常用在函数返回值，形如： 123456//注意函数返回值类型检测的写法function foo():void&#123;alert(&apos;123&apos;);&#125;; 其实，void包含两种数据类型，就是null和undefind。 触类旁通，其实还有两个类型是null和undefind，如图所示： null&undefind 如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。 类型断言作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。写法一： 123let a:number =1; let b:any = &lt;number&gt;a ; //赋值 第二种写法: 类型断言 Let来看这样一段代码： for循环实例 在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？ 运行结果 可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。 究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果 将上述代码的var i改为let i这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。因此，代码结果如下图所示： let执行结果 再来看一个对比： 使用var声明 将var 改为let 可见，两种声明，是一摸一样的输出，为什么呢？var的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次for(let i=0;i&lt;5;i++)的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。因为这里没有异步函数，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。 总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。 Const定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。eg: 123const a = 1 ;const a = 2 ; //error 结构赋值普通结构赋值： 普通结构赋值 函数参数结构赋值： 函数结构赋值 注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。 数组中的【…】解构语法 数组解构 输出： 输出 可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。 对象解构 直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。 下图是错误示范： 那么同理，如果在一个方法中返回对象，同样也可以被解构。 函数返回的对象也可以解构赋值 如果对象存在嵌套现象，可以使用冒号表达式： 嵌套的对象，使用冒号表达式来嵌套化结构 展开还是使用…语法，进行数组或者对象的浅拷贝。 数组展开，形如： 数组展开 对象展开，形如： 对象展开 对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。 可选参数、默认参数12345678function test(a:string,b?:string,c=&quot;wang&quot;)&#123;console.log(a)console.log(b)console.log(c)&#125;a为string类型，b为可选参数(string类型)，c是有默认值的参数 确定的参数要现在第一个，不能把可选参数写在第一位。 函数断点Yield在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。 1234567891011121314151617181920212223function* foo()&#123; console.log(1); yield; //设置断点，下同 console.log(2); yield; console.log(3); yield;&#125;;/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。 *必须重新赋值，再调用。 */let zoo = foo(); //这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。zoo.next();//1zoo.next();//2zoo.next();//3 箭头函数作用一：主要用于声明匿名函数，简化代码。123456var sum = (a,b)=&gt;a+b上式等价于：var sum = function (a,b)&#123;retrun a+b;&#125;; 作用二：消除this指针带来的歧义,优化执行上下文。 1234567function getName (name) &#123; this.name = name ; setInterval(function () &#123; console.log(&apos;name is &apos;+this.name)&#125;,1000)&#125;;var john = new getName(&apos;jhon&apos;);console.log(john) // 打印 name is (空) 这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。 使用箭头函数改造： 1234567function getName (name) &#123; this.name = name ; setInterval(() =&gt; console.log(&apos;name is &apos;+this.name)),1000)&#125;;var john = new getName(&apos;jhon&apos;);console.log(john) // 打印 name is jhon For…of循环for…in 循环对象的下标 1234567var arr = [1, 2, 3, 4];arr.name = &apos;myArr&apos;;for (var n in arr) &#123; console.log(n+&apos;==&apos;+arr[n])&#125;//输出0=1,1=2,2=3,3=4,name=myArr for of 循环对象的key 12345678910111213141516var arr = [1, 2, 3, 4];arr.name = &apos;myArr&apos;;for (var n of arr) &#123; console.log(n+&apos;==&apos;+arr[n])&#125;//输出0=1,1=2,2=3,3=4,undefind//还可以循环字符串var arr =&apos;hello,world!&apos;for (var n of arr) &#123; console.log(n)&#125;//h,e,l,l,o,，w,o,r,l,d,!; forEach 循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性 1234567var arr = [1, 2, 3, 4];arr.name = &apos;myArr&apos;;arr.forEach(function (n,v) &#123; console.log(n,v)&#125;)//输出1,2,3,4，但是没有输出我们定义的name 总结：for…in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for…of有点鸡肋，但是胜在使用场景广泛。 interface接口interface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。 interface 当然，接口中预先定义的变量，也可以规定/限制函数中的参数： 限制函数中的参数 基于Class的继承在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script! 基于Class的继承 访问权限关键字：public 公共成员。 子类、父类内部都可以访问到。 private 私有成员。只允许在类中访问。 protected 超类的私有成员。但是在子类中仍然可以访问。 构造器Construcor： 1234//形如：constructor()&#123; name?string;&#125;; 在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。 举例说明： 这时候，只要在构造器的name上增加关键字public，即可在class中全局访问： 类的继承真的比基于原型链的继承更加优雅和简便。 通过extends关键字实现继承 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>typescript</tag>
        <tag>编译</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下]]></title>
    <url>%2F2018%2F03%2F08%2F%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 6. 简单说一说盒模型，W3C和IE怪异盒模型。W3C标准的盒模型：width == content_width(不包括padding+border+margin) IE怪异盒模型： width == content_width+padding+border 参考我之前的博客：http://blog.csdn.net/qq_20264891/article/details/79019724 7.简要阐述XSS和CSRF攻击及防范7.1 XSS攻击与防范注入攻击。简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。 防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。 例如: 1&lt;input type=&quot;text&quot; value=&quot;&lt;script&gt;alert(123)&lt;/script&gt;&quot; name=&quot;input&quot;&gt;&lt;/input&gt; 显然，正常的用户，不会再输入框里面输入形如&lt;script&gt;alert(123)&lt;/script&gt;的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。 7.2 CSRF攻击与防范 CSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。 举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。参考文章：https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/这篇文章写的很好。 8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个_proto_对象，构造函数则有一个prototype对象，该对象上挂载的是可以继承的方法、属性等等。 8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？ 通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。 9.页面性能优化有哪些方式？a.文件(css,js,img)压缩、合并（雪碧图） b.减少请求数量 c.减少页面重排/重绘 d.使用懒加载，按需加载 e.CSS3动画有限保持帧率 f.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值 g.减少代码冗余量，精简代码 h.静态资源部署到CDN节点 9.1 重绘/重排是怎么回事？有什么区别？ 网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。 例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的重排。 当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是重绘。 重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。 也就是说，重排一定会引发重绘。 重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。 也就是说，重绘现象的发生，有可能是以重排作为前提。 9.2 请举例说明重绘，什么情况下会重绘？ 重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。 9.3 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？是的。 color,background等属性会引发重绘。 浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。 10. 浏览器如何知道一个css文件,js文件需要缓存？首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。 在https://www.cnblogs.com/shixiaomiao1122/p/7591556.html看到一个缓存原理图，侵删，图注的很详细： 缓存机制原理图 11.HTTP状态码304,502,503304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。 502：服务器作为网关或代理，从上游服务器收到无效响应。 503：服务器停机维护。 http状态码：1XX：临时响应。并继续等待客户端的请求2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。 12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？任何项目只有未发现 bug 和已经发现 bug 两种情况 不存在没有 bug 的情况 即便是测试人员也不可能覆盖 100% 的可能性 但是测试表中的要求必须 100% 覆盖如果测试通过上线后产生的 bug 如果是测试表中未覆盖的则编制测试表的人员背锅 如果是不可抗力福利彩票背锅 作者：王小明链接：https://www.zhihu.com/question/65688799/answer/233725228 开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。 如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>原理</tag>
        <tag>重绘</tag>
        <tag>冲排</tag>
        <tag>腾讯面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上]]></title>
    <url>%2F2018%2F03%2F08%2F%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 这篇博客同步更新于我的GitHub博客：我的GitHub博客 面试回顾：腾讯面试回顾 1.js中ajax发送请求的步骤在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下: ①创建XMLHttpRequest对象（标准浏览器）： 123if(window.XMLHttpRequest)&#123; var xhr = new XMLHttpRequest();&#125; IE7及以下，这个对象为：ActiveXObject： 123if(window.ActiveXObject)&#123;var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)&#125; ② 初始化请求 1xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com&apos;,是否异步?true:false); ③发送请求/传递数据 1xhr.send(); 请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式： 12//数据xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com/index.html&apos;,true); 如果是POST方法，直接写 xhr.send(&#39;数据&#39;) 中。 ④设置异步回调callback()先给个错误示范：12345//xhr.readyState 本地的请求状态//xhr.status 服务器返回的请求状态码if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123; do something...&#125; 这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1 这里的异步方式主要通过一个事件来完成： 1234567xhr.onreadystatechange()=function()&#123;if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123; do something...&#125;&#125; 如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。 反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。 扩展：既然 readyState==4 &amp;&amp; status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~参考文章 ，我以前的博客：Ajax初探上一次的面试中，xhr.open()初始化 xhr.send()发送请求 xhr.onreadystatechange=function(){}回调函数 这三点都忘记答了，一定要注意。 2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？事件捕获、事件响应、事件冒泡。 如图： 事件捕获和冒泡 不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。 一句话概括这种机制： 捕获：自外而内，从根到叶，从大到小 。 冒泡：自内而外，从叶到根，从小到大。 来做个实验，有如下的html结构 和 js代码： 123456789101112131415161718192021222324&lt;!--HTML结构--&gt;&lt;div id=&quot;div1&quot;&gt; 我是DIV1 &lt;div id=&quot;div2&quot;&gt; 我是DIV2 &lt;button id=&quot;btn&quot;&gt; i am a button &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;//script代码var div1 = document.getElementById(&apos;div1&apos;);var div2 = document.getElementById(&apos;div2&apos;);var btn = document.getElementById(&apos;btn&apos;);btn.addEventListener(&apos;click&apos;, function() &#123;console.log(this.id)&#125;,false);div2.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);div1.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false); HTML结构如图： HTML结构 当点击最里面的button，会依次出现这种情况： 控制台输出 可以看到，事件是在冒泡阶段被触发的。 当改变js API中最后一个Boolean值为true时，又会产生另外一种景观： 这里写图片描述 这次是从外向内依次触发的。 总结：1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。 3.闭包是怎么回事？用在什么场景？简而言之：1、闭包就是可以访问局部作用域的变量。并且： 2、 可以使局部变量常驻内存参考阮一峰老师的闭包博客： 阮一峰—-闭包 Q:闭包的内部函数为什么变量不会被销毁？A： 12345678910function a()&#123;var a =1;function b()&#123;a+=1;return a;&#125;return b();&#125; 因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。 Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法） A：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null； Q3.2：如何避免内存泄漏的问题？A：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。 4.CALL和Apply是干嘛的？二者都是为了更改function 的this指针，举个例子 CALL(新的this对象，原先的参数1，原先的参数2…);Apply(新的this对象，[原先的参数1，原先的参数2…]); 先传入新的this对象，再传入旧方法的传参。 5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？1.jsonp跨域利用&lt;script&gt;标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下： 12345678910111213141516171819202122//在js预先定义好callback()函数 function fun(data)&#123; //use data to do somethings. &#125;//动态创建script标签，并在url中说明请求地址var body = document.getElementsByTagName(&apos;body&apos;)[0];var script = document.createElement(&apos;script&apos;);script.type = &apos;text/javasctipt&apos;;script.src = &apos;require.php?callback=fun&apos;;body.appendChild(script);//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。 //假设传回的值是 fun(&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。 这样，通过script不受跨域访问的特性，实现了跨域访问。 2.CORS跨域（主流浏览器及IE10+） 对于客户端，我们还是正常使用xhr对象发送ajax请求。 唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true; 对于服务器端，需要在 response header中设置如下两个字段: Access-Control-Allow-Origin: http://www.yourhost.com Access-Control-Allow-Credentials:true 这样，我们就可以跨域请求接口了。 3.返回的json和jsonp有什么区别？返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如： 1callback(&#123;&quot;name&quot;:&quot;HanMeiMei&quot;&#125;) 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>ajax</tag>
        <tag>腾讯</tag>
        <tag>面试</tag>
        <tag>浏览器兼容</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript Dom拖动 插件 putThere.js]]></title>
    <url>%2F2018%2F03%2F08%2Fjavascript%20Dom%E6%8B%96%E5%8A%A8%20%E6%8F%92%E4%BB%B6%20putThere.js%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 开源地址：跪求各位看官给我点star吧 T.T，谢谢！https://github.com/ZQ-jhon/putThere.js 原理及构想关于拖动，如果不用html5的原生事件，怎样实现呢？不妨先设想一下整个拖动的流程： 点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute 当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值) 当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。 代码想好其中的原理，代码也就不那么难写了。1234567891011121314151617181920212223242526272829303132333435363738394041424344//window监听 window.onmousedown=function(obj)&#123; /*鼠标按下，dom元素脱离位置，变成绝对定位*/ obj.style.position='absolute'; &#125;window.onmouseup=function(event)&#123; var event = window.event||event; //获取鼠标距离浏览器边界的距离 var x = event.clientX; var y = event.clientY; console.log('鼠标距离浏览器边界(0,0)的距离('+x+','+y+')') /*获取dom元素距离浏览器边界的x,y值*/ var left = obj.style.left; var top = obj.style.top; console.log('Dom元素距离浏览器边界(0,0)的距离('+left+','+top+')') /*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/ if(left&gt;x||top&gt;y)&#123; x=-x; y=-y; &#125; obj.style.left = x+'px'; obj.style.top = y+'px'; &#125;&#125;;&#125; 我将它封装成一个函数，调用的时候，形式如下： 12345var div = document.getElementById('div');putThere(div);此时，div元素可以在document中任意的拖动，改变位置。 效果预览：鼠标拖动div效果如下： Demo效果预览 可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。 兼容程度实测 兼容 IE9及以上 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>plug-in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IONIC3 打包安卓apk详细过程（大量图文）]]></title>
    <url>%2F2018%2F03%2F08%2FIONIC3%20%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A4%A7%E9%87%8F%E5%9B%BE%E6%96%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 本文写于2018年2月12日 22:25:59。 如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。 经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。 1.基本依赖环境 nodejs环境 (作为一个前端相信你已经有了) nodejs 最好提前配置好node的环境变量，便于全局访问 jdk(下面细说) JDK SDK(下面细说，其实主要难就难在SDK配置了) SDK gradle(下面细说) gradle 2. 基本工具 gitbash(就是用来替代windows自带的丑陋的CMD) gitbash 下载：我都打包了！链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m windows自带的CMD(window+R输入CMD，管理员身份运行) CMD VSCode(微软爸爸开发的前端IDE) VSCode 下载：请自行去微软爸爸官网下载。 3.环境配置3.1 nodejs (需要配置环境变量)前端必会，跳过。3.2 jdk (无需配置环境变量)下载：已经上传网盘↓链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m请自行根据系统安装32/64位的版本。安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\Program Files\JavaOK，jdk安装完成，在cmd中，输入$ java -version验证是否安装成功。 jdk安装成功 OK。3.3 sdk (需要配置环境变量)下载：跟上面的一样，我都打包了。链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m 解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\Program Files\SDK接着配置环境变量，我的电脑——右键属性——-高级系统设置——-环境变量。在下面的系统变量(s)中，新建，键值对如下：name: ANDROID_HOMEkey: C:\Program Files\SDK如图所示： SDK环境变量 然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\bin缀在最后面，前面有【;】分隔符。 然后运行CMD，输入$ android -h，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。 ANDROID环境配置验证 现在，打开SDK目录下的SDK Manager.exe打开界面上的Tools,选择options，先配置国内镜像： 域名千万不要输入http或者https协议前缀，谁输谁哭。 配置镜像 下面记得勾选。回到主界面，点packages再点reload先勾选如下图的三个Tools:分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools] Tools 别急，还没完，下面还有一个：[SDK platform] SDK platform 全部选中后，点右下角 install packages 来安装，耐心等待即可。3.4 gradle安装(需要配置环境变量)打开：http://services.gradle.org/distributions/下载：gradle-4.1-bin.zip同样安装在JDK,SDK的目录下，便于查找。同样的配置环境变量：GRADLE_HOME=C:\Program Files\SDK\gradle-4.1;%GRADLE_HOME%\bin 测试命令（查看版本）：gradle -v 3.基本流程1.安装ionic和cordova 打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）1$ cnpm install -g ionic cordova 安装ionic和cordova 2.创建ionic项目 桌面右键，在此处gitbash1$ ionic start app tabs 耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后 1$ ionic serve ionic serve 稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示： 如果做到这一步没问题，说明：1.nodejs与gitbash没有问题。2.ionic和cordova没有问题。 4.打包确保SDK,JDK没问题以后，使用指令1$ ionic cordova build android --release (如果这条命令有问题，可以去掉–release然后debug编译，编译完成Dos会显示apk目录位置) 如若你聪慧的双眼发现如下字眼：Build Success! 即可关闭本网页，说明你已经成功打包了。 OK，此时你已经有了debug的包，但是这个包没有签名，不能发布。 此时，我们应该： First：在JDK目录下的bin文件夹下（C:\Program Files\Java\jdk1.8.0_71\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。 Second：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。执行完命令1，继续执行命令2即可完成签名打包。 命令1：生成签名密钥 123/*使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！*/ keytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000 命令2：给文件签名使用刚才生成的zhangqiang.keystore -signedjar 签名后的apk 签名之前的apk 签名包别 jarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore 签名完成 如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！后续的软件压缩打包可以百度：jarsigner打包 5.疑难杂症5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to undefined to prevent this warning. 出现这个提示，说明配置不正确。 解决方法： 在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下： 12345var postcssOptions = &#123; from: undefined, to: path_1.basename(sassConfig.outFile), map: autoPrefixerMapOptions &#125;; 5.2 安卓SDK组件缺失/缺少/不匹配报文： 123A problem occurred configuring project &apos;:CordovaLib&apos;.&gt; You have not accepted the license agreements of the following SDK components: [Android SDK Build-Tools 26.0.2]. 原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。 5.3 缺少安卓构建/打包工具报错报文： 1234Unhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,or on your system to install the gradle wrapper. Please include gradlein your path, or install Android Studio(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. 原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。解决办法：去http://services.gradle.org/distributions/ 下载 gradle-4.1-bin.zip配置相应的环境变量： GRADLE_HOME=E:\software\gradle-3.0PATH=%PATH%;%GRADLE_HOME%\bin 测试命令（查看版本）：gradle -v 完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。) 感谢收看。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>android</tag>
        <tag>SDK</tag>
        <tag>JDK</tag>
        <tag>APP</tag>
        <tag>IONIC</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录]]></title>
    <url>%2F2018%2F03%2F08%2F2018%E5%B9%B41%E6%9C%8823%E6%97%A5%E8%85%BE%E8%AE%AFSNG-IMWeb%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%20%E7%94%B5%E8%AF%9D%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 前言 2018年1月18日，突然接到一个来自深圳的电话，对方说从拉勾网上看到我投递腾讯SNG部门的IMWEB团队前端，简单询问了一下我的具体情况，包括前端的就职年限，过去的工作经历。其中有一点比较有意思的是，对方问我为什么2016年7月毕业直到2017年2月入职中国XX网，这之间的简历是空缺的？我回答他说因为刚毕业没有太好的就业选择和机会，错过了很多校招，所以在毕业的时候去一个艺术培训学校当了半年的吉他老师，因为觉得和前端的职业经历没有关系，因此没有把这段经历写在简历上。对方说，我觉得你应该把这段经历也写在简历上，我说好的谢谢。 接着问了他招聘的是什么职位，对方说是前端工程师，我说主要负责什么工作？他说主要负责腾讯课堂的一些前端工作，我跟对方说，我目前还在老家，可能无法及时的去深圳那边面试，问了他可不可以远程面试，遂对方跟我说，可以采用电话面试，并且约定了电话一面的时间，2018年1月23日。 面试的过程及结果从接到电话直到第一次面试的这段时间，我在网上大量的检索了关于腾讯电面的经验，并且深入的针对一些常用的考点，进行梳理和总结，例如：闭包、原型、作用域链、Ajax、http协议、盒模型、兼容问题、xss/csrf攻击、浏览器渲染（重绘重排）等。在1月23日的当天，5点多回家，还一直在看复习资料，饭也顾不上吃。7点，从深圳打来了一个熟悉的电话。整个电话持续了40分钟之久，基本上问的都是基本的原理，而后可能我的回答让面试官也比较满意，之后是1个半小时的远程监控编程环节，三道程序设计题，给一个半小时的时间，腾讯面试官远程QQ协助监控你的桌面，只允许用浏览器的console以及本地编辑器，不允许查询资料，在编程过程中，面试官还会试图针对一些有问题的地方给予提示。最后，我还是很遗憾的没有通过，因为三道编程题目，我磕磕巴巴基本上没做出来，所以挂了，把文件打包发送给面试官后。我问面试官，像我这样经历不丰富，简历不突出的，为什么会考虑我呢？面试官说，我们什么阶段的人选都会考虑，你入行前端一年，基础还是不错的，就是编码能力需要提高。。。面试完以后，大概有几个小时，一直沉浸在刚才的面试里，晚饭也忘了吃了，一直在反思自己哪些地方答的不够好，这几天的复习哪些地方有疏漏。我的互联网公司处女面就以失败告终了。但是回头想想，这次失败的经历是一面镜子，让我清楚的认识到自己几斤几两，督促我在今后的学习中一步一个脚印，脚踏实地，再去仰望星空。 电话里问到的题目接下来，根据我当天的通话录音，来对所问到的题目进行穷举： 1.接你现在的工作主要是偏前端还是偏后端？我看你大学的课程主要是偏后端一点？ A:大学课程修完以后，出来没找到工作，干了半年吉他老师，对自己就业比较迷茫。回 到老家以后，干前端、运维都有，但是主要是前端。 2.接触前端多久了？接触/学习的渠道是什么？ A：满打满算一年。刚开始是同事辅导，慢慢入手以后，在W3CSCHOOL、网易云课堂、腾讯课堂、慕课网学习。 3.Ajax发送请求的步骤？ 3.1 xhr.open() 3.2 xhr.send() 3.3 callback() 4.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？ 5.事件代理，事件委托是什么意思？ 6.闭包是怎么回事？用在什么场景？ 6.1 变量常驻内存会带来什么问题？ 6.2 如何避免这种问题？ 6.3 怎么销毁？ 7.CALL和Apply是干嘛的？ 8.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？ 8.1.如何进行CORS跨域？需要什么条件？ 8.2 对服务器来说，返回json数据和JSONP数据有什么不一样？ 8.3 还有其他跨域方式吗？ 9.简单说一说盒模型，W3C和IE怪异盒模型。 10.简要阐述XSS和CSRF攻击及防范 10.1 XSS脚本劫持，如何截获？(ps.这里居然把CSRF的概念当做XSS的来回答….) 10.2 CSRF域名劫持 11.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype) 11.1 例如构造函数有一个test()方法，prototype上也有一个test()，这两个方法有区别吗？ 12.页面性能优化有哪些方式？ 12.1 文件、脚本合并是如何优化的呢？ 12.2 重绘，重排是怎么回事？有什么区别？ 12.3 请举例说明重绘，什么情况下会重绘？ 12.4 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？ 13.浏览器如何知道一个文件资源是否需要缓存？ 14.HTTP状态码304,502,503 14.1 1,2,3,4,5 开头的状态码都表示什么？ 15.Node、Vim、angular简述 15.1 Node上如何处理异常情况？（Ps.我回答的是开发调试。。。找js文件） 15.2 已经上线的项目，出问题，怎么样去处理异常？ 16.构建工具除了Webpack，还接触过其他的吗？ 16.1 Webpack的优点和应用场景？ 编程大题 1、页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。 2、实现超出整数存储范围的两个大正整数相加 function add(a, b) 。注意：参数 a 和 b 以及函数的返回值都是字符串。 3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。 这个环节基本上就知道自己GG了。。。 第一题考基本功，DOM、事件、定位、jsAPI 第二题考算法，基本逻辑 第三题考原理，基础 不得不说面试官的技术确实比较全面，腾讯的远程面试也是好狠，直接远程监控写代码的。。。鼠标和界面都不敢静止，静止可能就会被认为作弊（不知道他们是不是这样来判断的，反正我没有停下来过）。 以下是做完所有题目后跟面试官的沟通记录。天真的我以为会被眷顾招入鹅厂，然鹅我想多了。。 图1 图2 图3 图4 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>腾讯SNG-IMWeb面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用原生js制作一个动态简历(多动症简历)及在线预览部署过程]]></title>
    <url>%2F2018%2F01%2F29%2F%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86(%E5%A4%9A%E5%8A%A8%E7%97%87%E7%AE%80%E5%8E%86)%E5%8F%8A%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 本项目Fork地址(欢迎Star)：https://github.com/ZQ-jhon/resume 本项目预览地址(Preview Address)Preview : 多动症简历 项目起因因为在网上看到一个大神做的动态简历，如连接所示： http://strml.net/ 炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。 引用的第三方库1.jQuery 实际用到的地方只有1% 2.prism 代码高亮库。用到30% 3.marked.js markdown语法转html的库，实际用到20% 技术概要通篇中使用的技术难度并不大，主要有： 核心原理：同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。 字符串提取、拼接。 setInterval定时器控制整个代码的吞吐节奏/速率。 在setInterval中设定一些if，用来控制总字符串的吞吐位置。 避坑指南1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释//，要对/进行转义，如下`\/这里填写你的内容\/。** 2.字符串的命名一定要切实合理： 如图所示： 字符串的命名 3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n&gt;123&amp;&amp;n&lt;321)这种方法来进行区域渲染。prism的渲染代码如下： 123456官方js库地址：[http://prismjs.com/](http://prismjs.com/)语法:prism.heihlight(渲染的字符串,渲染的代码格式)Prism.highlight(str.substring(0,n), Prism.languages.css); 4.MarkDown ⇒ HTML渲染 ： 同样根据n的值，来使用if()来进行循环。 marked.js官方库地址：https://www.npmjs.com/package/marked 渲染代码如下: drawBoard.innerHTML =marked(str.substring(929,1885)); 5.动态创建Pre标签（id=”drawBoard”） ： CSS代码版是一开始写在HTML的，但是之后的简历板子（id=”drawBoard”，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示： 动态创建drawBoard 6.已经创建的元素无法在另外的循环中获取 ： 在刚才的【5】中，动态创建的pre标签(id=”drawBoard”)会在if()的区域内无法document.getElementById(‘drawBoard’)，此时需要在if里面再次获取并且赋值，如图所示： 7.动态下拉 同样通过n的值来让元素的溢出自动下拉 如图： 动态下拉 8. 动态简历最后的魔术环节 ： 还是通过n的值来进行判断，从而渲染 其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。 代码如图： 核心原理代码1234567891011121314151617181920//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义var styleTag = document.getElementById(&apos;styleTag&apos;);var sourceBoard = document.getElementById(&apos;sourceBoard&apos;);var str = &apos;\/*大家好...今天我给大家做一个在线简历...\/*&apos;;var n = 0;window.setInterval(function()&#123; n++; styleTag.innerHTML = str.substring(0,n); sourceBoard.innerHTML = str.substring(0,n);&#125;,100);//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。 Demo部署到GitHub详细过程本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能： gh-pages预览项目 在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。 整个部署的环节大致如下： 在本地的项目根目录下，$ git init 加入当前所有文件到暂存区 $ git add .(后面有个“·”，代表全部文件) 连接远程仓库 $ git remote add origin &quot;your repository address&quot; 提交所有文件到git版本控制系统 $ git commit -m &quot;create Demo resume&quot; push到你的远程仓库 $ git push origin master 打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。 PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub 反思与不足 在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。 我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。 我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：http://strml.net/的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。 整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。 整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>动态简历</tag>
        <tag>Github部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于HEXO的个人博客图文搭建详尽过程，看不懂算我输]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%9F%BA%E4%BA%8EHEXO%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%96%87%E6%90%AD%E5%BB%BA%E8%AF%A6%E5%B0%BD%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%9C%8B%E4%B8%8D%E6%87%82%E7%AE%97%E6%88%91%E8%BE%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 前言须知：1.最终生成的博客地址必须是： ZQ-jhon.github.io 即用户名.github.io2.本地的HEXO仓库，命名必须也为 ZQ-jhon.github.io ，HEXO项目放置于该目录之下。 昨天经过一番折腾，终于将HEXO部署上线了，以下对于昨天整个搭建的过程做一个详细的回顾。 HEXO是基于NODE的一款博客框架，有很多丰富的主题可以选择，配合GIT来使用。 Git回顾：本地仓、远程仓 安装整个安装过程我是参考一位博主：HEXO系列教程 以下用自己的理解来做一番梳理与归纳： *先介绍HEXO中的4个命令： 1234$ hexo g #完整命令为hexo generate，用于生成静态文件 $ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览 $ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上 $ hexo n #完整命令为hexo new，用于新建一篇文章 首先，确保本地Git公钥与Github公钥相匹配，参照：Git本地仓 确认匹配后，新建Repository，命名的时候，规范为： github名字.github.io 因此，这里的新仓库名字应该为： ZQ-jhon.github.io 这里写图片描述 同样的，在本地新建一个同名的目录：ZQ-jhon.github.io ，然后打开目录，文件夹是空的 此时，在项目目录下右键打开Gitbash here 1.$ cnpm install hexo-cli -g&nbsp; &nbsp; &nbsp; 使用淘宝镜像安装hexo-cli 2.npm install hexo-deployer-git --save&nbsp;&nbsp;&nbsp; 模块安装到开发目录 3.$ hexo init&nbsp;&nbsp;&nbsp;初始化 4.$cnpm install&nbsp;&nbsp;&nbsp;安装依赖 （PS：中途如果出现问题，可以 cnpm install hexo-deployer-git --save 安装GIT的PUSH插件）5.$hexo g &amp;&amp; hexo s 构建(genereater)并启动服务(server)，在locallhost:4000下即可预览效果 这里写图片描述 远程部署本地的文件我们已经在locallhost:4000端口预览的非常满意了，如何部署到站点(github)上呢？ 1.首先，找到HEXO目录下的 __yml文件，在最下面修改如下： 1234deploy: type: git repository: git@github.com:ZQ-jhon/ZQ-jhon.github.io.git branch: master 注意：如下图所示，这里的repository地址就是Github download时弹出的项目地址，但是最好不要用HTTPS协议，走SSH协议，昨天因为这个问题，调试了一下午！！！ 这里写图片描述 2.布置好以后，我们来Ping一下Github，看能否有响应： 1$ ssh -T git@github.com 这里写图片描述 欢迎了一波，很稳。 此时，直接把Server Ctrl + C 然后 $HEXO D&nbsp;&nbsp;&nbsp;直接推送，稍等片刻，打开Github仓库，看看文件是否上传成功 如果上传成功，大功告成，打开 https:ZQ-jhon.github.io即可访问博客页面了。 文章新建与MarkDown语法新建文章 $hexo n filename 这个比较简单，建完文件，也别秀骚操作了，老老实实去source文件夹的_post文件夹里面，去用一个好点的编辑器，修改文本文档，保存为UTF-8格式，并且修改后缀名为.md，保存类型为所有类型，否则上线部署会产生乱码。 值得一提的是，CSDN的在线文档编辑器就采用的是MarkDown语法，而且该种语法与标签语言完全兼容，因此，可以将HTML代码原封不动的全被拷贝近.md文件。 ##主题更换与配置## 在我们HEXO根目录下，有一个themes文件夹，里面存放的都是各式各样的主题，默认的是landscape，我们可以去官网，HEXO的THEME分类下下载更多精美的主题，然后解压缩，将文件夹放在themes下，另外稍微修改 __yml文件下，theme:lanscape 即可。 这里写图片描述 相关的配置，我们可以follow官方推荐作者的github去看看人家的wiki或者code，都有详尽的说明，甚至可以加QQ咨询…… 这里写图片描述 最终效果与总结Welcome to the ZQ-jhon.github.io wiki! 基本效果预览 文章详情预览 搜索模块预览 不得不说GITHUB开源生态真的非常强大，感谢这些开发者带来的精美主题。 感谢主题作者Miachel.LuHEXO-Mellow-theme 点击查看该项目 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>HEXO</tag>
        <tag>动态部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack打包工具学习笔记]]></title>
    <url>%2F2018%2F01%2F17%2FWebpack%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 前言本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言：Webpack是一款基于node的前端打包工具，它可以将很多静态文件打包起来，自动处理依赖关系后，生成一个.js文件，然后让html来引用，不仅可以做到按需加载，而且可以减少HTTP请求，节约带宽。 1.配置与安装在node已经安装完成的前提下，全局安装webpack 123456789$ cd d:$ mkdir test &amp;&amp; cd test //创建test ，并进入$ npm install -g webpack //等待100s，安装完成，也可以使用淘宝镜像$ npm init //初始化package.json文件$ npm install --save-dev webpack //添加依赖 ，在package.json中声明依赖,等待安装完成 2.基本操作$webpack main.js webpack.js当前目录下创建如下工作结构: 1234567/---------test ----app ----main.js ----index.js ----index.html 项目目录下，app文件夹含有两个js文件，修改如下： 1234567891011121314151617181920212223//main.js ，这是Webpack主要的入口文件 require(&apos;./index.js&apos;);//index.js ，这是被主文件引用的文件document.write(&apos;Hello,world!&apos;);//index.html ，供浏览器解读&lt;html&gt;...&lt;script src=&quot;./webpack.js&quot;&gt; // 引用同目录下的webpack.js...&lt;/html&gt; webpack.js是哪来的呢？就是通过webpack打包生成的js文件，接下来， 开始生成webpack.js文件： 1$ webpack main.js webpack.js 这里写图片描述 可以看到已经打包成功了，此时查看IDE中的项目目录，根目录下已经多了一个webpack.js文件。然后用浏览器打开index.html，效果如下： 这里写图片描述 此时查看网页源代码： 这里写图片描述 66666666666！ 3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）每次在命令行敲目录调试，是很痛苦的，因此需要一次配置，多次使用的方法。 在根目录下新建文件： webpack.config.js (名字就是这样，规定，不能改)，内容如下： 123456789101112module.exports = &#123;//入口文件位置 entry:__dirname+&apos;/app/main.js&apos;,//出口 output:&#123; //路径 path:__dirname, filename:&apos;webpack.js&apos; &#125;&#125; 这里的 __dirname是一个node的全局变量，用于指向当前的工作目录，调皮的我console.log了一下这个变量： 这里写图片描述 确认无疑。 这样，我们的webpack.js写完以后，可以直接在命令行中敲： 1$ webpack 可以发现，项目中也同样的会生成目标js文件，也就是webpack.js，这样非常方便，省事。 还有一种配置方法，将package.json文件中”scripts”里面添加键值对： 这里写图片描述 这样同样可以在项目目录生成目标js文件，直接在 命令行里敲 1$ npm start //因为webpack是全局安装的，直接value给webpack，而不用跟路径 如果start被占用了/冲突了，也可以在scripts下面自定义一个键值对： 123&quot;zq&quot;:&quot;webpack&quot;$ npm run zq //稍作修改cmd 命令 最后还是可以生成。 4.webpack服务器监听代码变动，自动刷新及source-map4.1关于source-map，也就是在webpack.config.js中配置 devtool (develpment tool)的值，例如我这样配置： 这里写图片描述 在webpack完成文件打包后，会自动生成一个与目标文件相同名的 .map文件，用来说明打包文件的每个地方对应的是哪些文件，简而言之，让你能知道源码是在哪里错的，帮你刨根问底，而不用开发者自己去Debug。 参考文章1：入门WEBPACK，看这篇文章就够了—-简书 参考文章2：Webpack中的sourcemap 4.2 webpack服务器 首先单独安装 server 包 ： 1$ npm install --save-dev webpack-dev-server 同样的，在webpack.config.js中做出相应的配置： 123456789101112131415161718module.exports = &#123; devtool: &apos;source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, module: &#123; &#125;, devServer: &#123; contentBase: &quot;./&quot;,//本地服务器加载index.html页面所在的目录，这里写的是根目录 historyApiFallback: true,//不跳转 inline: true//实时刷新, &#125; &#125; 配置好config后，还得配置一下package.json，在scirpts里面添加server： 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot;, &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, 接着，在命令行运行 123456789$ npm run server /*届时服务器会自动启动， 并且打开浏览器,默认端口为8080，也可以devServer:&#123;port:4040 //自己配置端口为4040&#125; 下面是一个服务器跑起来后的演示结果，我不断的修改work.js 中 document.write的值，从而服务器会自动检测并刷新页面： 5.非JS文件的操作(img,json,css……),猪脚：Loaders 5.0 基本概念 前面都在说js文件，官网说什么文件都可以当做模块打包，下面就来试试非js文件。 首先要明确的是，webpack只能识别js文件，如果要识别非js文件，就需要loader来解析这些文件。 loaders 需要单独安装，并且在webpack.config.js中的modules关键字下进行配置。 Webpck2以上已经支持对json的解析打包，不需要额外的loaders，可以在main.js中 123var json = require(&apos;../package.json&apos;)//json在它的上级目录document.write(json.scripts.server); 运行结果 ： 这里写图片描述 可见，网页中，没有通过任何第三方loader，即可将json解析并打包成bundle.js。 5.1 Bable Bable可以使得开发者使用最新的ECMAscript标准来书写代码，而不用管新标准是否被当前使用的浏览器完全支持。 还是需要单独安装Bable的包： 123$ npm install --save-dev babel-core babel-loader babel-preset-env / 安装完成后，在webpack.config.js下的module关键字下进行配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859module.exports = &#123; devtool: &apos;source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, devtool: &apos;eval-source-map&apos;, devServer: &#123; contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //正则匹配，必须 use: &#123; //使用到的loader loader: &quot;babel-loader&quot;, //loader名 options: &#123; //选项 presets: [ //预先配置 &quot;env&quot; ] &#125; &#125;, exclude: /node_modules/ //不包含的目录或文件 &#125; ] &#125; &#125;; 5.2 CSS文件处理 webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 同样先安装两个包 style-loader和css-loader 1$ npm install --save-dev style-loader css-loader 123456789101112131415161718192021 module: &#123; rules: [ &#123;.......&#125;， &#123; test: /\.css$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125;也可以简写：&#123;test:/\.css$/.use:[&#123;loader:&quot;style!css&quot; //这里的执行顺序是从右往左，css应该在style之前执行&#125;]&#125; 根目录下新建 ./src/index.css，写一个body的背景为green，然后在入口文件main.js中,require(‘../src/index.css’)，接着通过命令行$ webpack此时查看index.html，发现页面背景已经变成绿色 这里写图片描述 6.插件plugins先安装插件的包： 1cnpm install html-webpack-plugin 在webpack.config.js中 头部，引入依赖： 1let webpack = require(&apos;webpack&apos;); 然后在webpack.config.js中配置根键值对： 123plugins: [ new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;) ], 这里写图片描述 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular搭建后台人员管理系统 1.1.0]]></title>
    <url>%2F2018%2F01%2F17%2FAngular%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-1-1-0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 今天基于原来的DEMO，将功能进行了调整。 这里写图片描述 如图所示，增加了一个新的controller，完成了增删改查的最后一步：查。 step1中还是使用ng-repeat遍历出的options，然后这个select又绑定了一个model，可以在controller用于判定用户的选项，然后根据这个选项，在users的数组中进行查找，最后，显示在查询结果的框中。 今天遇到的几个问题：1.数据可视化和canvas视图留了一个坑。2.突然发现controller之间的方法、变量不可以共享，例如我在下面的控制器中创建的用户数组： 123456$scope.users=[&#123;...&#125;,&#123;...&#125;,&#123;...&#125;,&#123;...&#125;] 在上面查询控制器中无法访问，网上查询之，得到结果，原因是作用域无法访问，这点跟js比较像，两个在树形结构上是兄弟层级关系的节点，不能访问对方的内部变量。但是angular 可以像js一样，变量继承，因此，可以吧users挂到 相对比较高的祖先节点上，这样，其子控制器就可以访问到了。3.在Step1的位置，出现了F5以后，默认出现一个空白options的现象，查看元素，得知该元素： 1&lt;option value=&quot; undefind!&quot;&gt;&lt;/option&gt; 于是采用了一个笨办法，手动添加一个&lt;option value=&quot;&quot; selected=&quot;&quot;&gt;&lt;/option&gt;然后，在ng-repeat的原始option选项中，也添加selected=&quot;selected&quot;，这样就OK了！4.今天对各个控制器进行合理的切分，达到模块化的效果，例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*********根控制器的数据*********/ app.controller(&apos;rootctrl&apos;,function($scope)&#123; $scope.users = [ &#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;, &#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;, &#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;, &#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;, &#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;, &#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125; ]; &#125;)/**********增加用户 控制器*************/ $scope.addUser = function()&#123; var index = $scope.users.length-1; $scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;); &#125; /**********查询 控制器************ / $scope.jiansuo = function()&#123; var a = $scope.selectValue; $scope.result = a; if(a==&quot;&quot;||null||undefined)&#123; document.getElementById(&apos;sp&apos;).innerHTML=&quot;未选择/未输入!&quot;; document.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请先选择分类&apos;) &#125; else&#123; document.getElementById(&apos;sp&apos;).innerHTML=&quot;您要查询的&quot;+$scope.infos[a].name+&quot;是:&quot;+$scope.input; document.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请输入具体的&apos;+$scope.infos[a].name+&quot;！&quot;); &#125; &#125;; /********删除 控制器***********/ $scope.remove = function(index)&#123; // if($scope.users.length&lt;=1)&#123;// $scope.users.splice(index,1)// &#125;// else&#123;&#125; $scope.users.splice(index,1) &#125;; 在切分这些控制器的过程中，一定要注意各个控制器的作用域，以及能否访问到调用数据。GitHub:https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3原理，结合jquery复习]]></title>
    <url>%2F2018%2F01%2F17%2Fcss3%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BB%93%E5%90%88jquery%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 0.怪异盒模型非IE及IE9及以上， 盒模型的构成为:content老IE，IE8及以下， 盒模型为 content+border+padding如果有这样一个DIV： 1div&#123;width:100px;height:100px;border:1px solid black;padding:10px;&#125; 在非IE下，盒模型为： 这里写图片描述 在老IE下，盒模型为： 这里写图片描述 由此可见，老IE在计算盒模型时，加入了两个padding和border的值。 1.background-size规定背景的位置。eg: 12#div&#123;background-size:cover;&#125;//覆盖整个div#div&#123;background:url(img/123.png) no-repeat;background-size:10% 10%;&#125;//背景图片宽高为原始图片宽高的10%，且不重复 2.background-orgin://可以选择的值为：content-box、margin-box、padding-box content-box、margin-box、padding-box的区别 ①content-box，即采用W3C标准渲染方法，不计算padding和border及margin，得出的盒子②padding-box，渲染盒子的时候，把padding当做盒子宽高的组成部分，即在标准盒子模型的基础上，宽高都增加padding px。③margin-box，同理，宽高都增加margin-box3.border-radius 圆角边框，假如DIV 的 宽 = 高，即正方形，此时，如果border-radius = div 的宽/高，那么此时的div是一个圆形。如果border-radius远远大于div的宽/高，那么还是一个圆形，不会变化。因此，background-origin的值，就取决于背景图从哪个盒子模型开始渲染。 4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色1234&#123;text-shadow: 225px 0px 0px #FF0000; /*水平偏移225，垂直不偏移 z-index为0 颜色为红色*/&#125; 最终效果： 这里写图片描述 5.font-face 自定义字体兼容度：IE及IE8以下不支持，主流浏览器都支持。关于自定义字体，请参见我之前的一篇博客：自定义图标与百度Share API 6.Css3 之 2D转换 (transform)释义：transform 改变;变换兼容度：IE9及以上，主流浏览器都兼容。下面列举的方法，都位于transform属性之下，例如：transform:rotate()、transform:translate()主要的2D转换属性：6.1 位移： translate() 方法 1div&#123;transform：translate(100px,100px)&#125; /*在原来位置的基础上，x轴移动10px，y轴移动10px*/ 如图所示： 这里写图片描述 原本处于空白位置的DIV，现在x,y轴都平移了正的100px6.2 旋转 rotate() 方法 1234```img&#123;transform：rotate(30deg)&#125; /*图片顺时针旋转30度，当然，也可以和css伪类配合完成一些效果 ，例如 ：*/ img:hover&#123;transform:rotate(30deg)&#125; /*鼠标悬停，方可旋转*/ 这里写图片描述 由此可见，这个效果在一些圆形的图片上最为适用 6.3 比例/缩放 scale(x轴比例，y轴比例) 方法跟刚才的旋转同理，我们也可以给一个图片设定一:hover伪类，然后来观察效果 12345/*文档结构：父div包含着一个图片，父div标准盒子模型100x100，原始图片100x100 */div&#123;width:101px;height:101px;overflow:hidden;border:1px solid black;&#125;img:hover&#123;transform: scale(1.5,1.5);&#125; 这里写图片描述 这个效果也很常见。鼠标放进去放大，鼠标离开变成原始比例。关于这一点，可以参照之前的博客：关于CSS3呼吸效果的探究6.4 偏斜/歪斜 skew(x轴偏斜,y轴偏斜)以前见过很多用CSS3做的留言墙，skew属性用的比较多。 1img:hover&#123;transform:skew(30deg,30deg)&#125; 鉴于这个方法比较扭曲，就不上图了，值得注意的一点是，这个偏移量貌似根据tan来计算的，当我给这个方法传入90deg时，图片会不存在。6.5 矩阵/汇总方法 matrixmartrix()接受6个参数，其实就是对于 平移、旋转、缩放、偏斜的汇总简写。具体请参见张鑫旭大神的博客：理解CSS3 transform中的Matrix(矩阵) 7. Css3之3D转换 ##（Oprea不支持3D转换）7.1 3D旋转 rotateY() 1div:hover&#123;transform: rotateY(180deg)&#125; 这里写图片描述 框中的文字，其本身围绕Y轴旋转180° 8.Transition 过渡效果兼容度：IE9及以下不支持该属性，需要优雅降级 12div&#123;width:100px;height:100px;background:yellow;transition:width:width 2s;&#125;div:hover&#123;width:300px;&#125; 效果如图（鼠标移入，DIV变宽，鼠标移出，自动复原）： 鼠标移入，DIV变宽 此时，我们在div:hover中重写了属性width，那么，在原始的div{transition}中，我们要说明，那个属性需要过渡效果，并注明过渡时间，此时肯定是transition:width 2s，如果有多个属性需要过渡效果，那么，就应该给出如下说明： 1transition:all 2s //所有属性都需要过渡效果，并且所有效果同步过渡的总时长为2s. 如此一来，就可以实现类似于jquery的效果： 1$(&apos;div&apos;).animate(&#123;width:&apos;101px&apos;;height:&apos;101px&apos;;background:&apos;green&apos;;&#125;) 这里写图片描述 甚至可以规定过渡的delay延时： 1transition-delay:0.5s; //0.5秒延时以后开始动画效果。 效果与上图大同小异，不过有0.5s的移入和移出延时。其实，在transition里有4个属性，分别是：1.过渡的属性名称2.过渡的总时长3.过渡的方式:线性，缓慢等等4.过渡的延时，即多少s以后才开始过渡例如： 123456div&#123; transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s;&#125; 可以简写为： 1div&#123;transition:width 2s linear 2s&#125; 9.CSS3 动画之前一篇帖子对于动画部分做了一些探究：关于CSS3呼吸效果的探究 如果对于动画的需求比较复杂，需要持续重复的完成，可以考虑动画效果，如果只是简单的一些效果，完全可以采用transform来自己实现。 10.CSS 3 多列123456div&#123;-moz-column-count:3; /* Firefox */-webkit-column-count:3; /* Safari and Chrome */column-count:3;&#125;/*将一个DIV分为三列*/ 这里写图片描述 以及最后的最后，有一个允许用户自定义元素大小(可拖拽拉伸)的属性 12345678div&#123;border:2px solid;padding:10px 40px; width:300px;resize:both;overflow:auto;&#125; 这里写图片描述 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS3呼吸效果的探究]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%85%B3%E4%BA%8ECSS3%E5%91%BC%E5%90%B8%E6%95%88%E6%9E%9C%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 一、效果预览 这里写图片描述 如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。 二、方案选择刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。 这个效果的实现，如果采用jquery的方案，直接写个动画即可。 12//先设定好position:relative;$(&apos;img:hover&apos;).animate(&#123;&apos;left&apos;:&apos;10px&apos;,&apos;bottom&apos;:&apos;10px&apos;&#125;); 假如追根溯源，还是使用的CSS3的动画。首先自定义一个动画： 1234567@keyframes testAnimate&#123;from&#123;position: relative;bottom: 0;left: 0;&#125;to&#123;position: relative;bottom: 20px;left: 30px;border: 5px solid #999;&#125;&#125; 这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。 接着，我们在测试的图片用例上来引入动画： 12345678img:hover&#123;animation:testAnimate 1s;-webkit-animation:testAnimate 1s;-moz-animation:testAnimate 1s;-o-animation:testAnimate 1s;-ms-animation:testAnimate 1s;&#125;//整个动画1s完成，并设置了浏览器兼容 效果如下： 这里写图片描述 可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案： 1234567img:hover&#123;animation-fill-mode: forwards;-ms-animation-fill-mode:forwards;//兼容IE xxxxxx -webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx-o-animation-fill-mode:forwards;//兼容opear xxxxxx&#125; 这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。 三、分析归纳众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行 预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5回顾总结]]></title>
    <url>%2F2018%2F01%2F12%2FHtml5%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 1.新标签1.1 &lt;vedio&gt; 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 两个video source源是为了最大程度的兼容所有浏览器，该标签IE8及以下不支持。比较重要的属性： 123预加载 preload:preload自动播放 autoplay:autoplay循环播放 loop:loop 常见的高大上的背景视频上嵌套文字的效果可以这样实现： 12345678910111213141516171819202122&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; video&#123;z-index:-99999;float:left;position: relative;left:300px;&#125; h4&#123;color:white&#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;video width=&quot;320&quot; height=&quot;240&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt; &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/mp4&quot;&gt;Your browser does not support the video tag.&lt;/video&gt;&lt;div style=&quot;float:left;width:320px;height:240px;z-index:999&quot;&gt; &lt;h4&gt;震惊！野生棕熊竟然对猎物熟视无睹&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 给video给z-index：负数 ，给嵌套层的文字给 z-index：正数，然后相对定位，接着取消video 的controls属性，这样会隐藏音量条，播放/暂停按钮等控件。 这里写图片描述 类似于该网站的页头：英雄之刃官网 在js中，可以把&lt;video&gt; 完全当做一个Dom节点，操作他的相关属性。例如： 12345678910document.getElementById(&apos;video&apos;).pause()//暂停document.getElementById(&apos;video&apos;).play()//播放document.getElementById(&quot;video&quot;).currentSrc;//获得原始播放地址document.getElementById(&quot;video&quot;).currentTime//获得播放器当前播放位置，单位为sdocument.getElementById(&quot;video&quot;).duration //获得视频的整个播放时长...... 还有特别多的API，例 如 EVENT：刚开始播放、结束播放、视频的网络状态等等，甚至可以结合播放时间，来控制插入广告。。。1.2 audio 与上述视频同理。兼容度更狭隘：IE9及以上1.3 拖放 Drag 和 drop兼容度：IE9、IE9+示例：W3C拖放示例1.4 Canvas“始于苹果的一项技术，使得Javascript具有图像绘制的能力”。 123456789101112//HTML:&lt;canvas id=&quot;cvs&quot; height=&quot;200&quot; width=&quot;200&quot;&gt; 您的浏览器不支持&lt;canvas&gt;标签&lt;/canvas&gt;//JS:&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;cvs&quot;); //获取var cxt=c.getContext(&quot;2d&quot;); //canvas对象特有的方法，目前仅仅支持到2D，未来可能会支持3D...cxt.fillStyle=&quot;green&quot;; //填充颜色 cxt.fillRect(0,0,150,75); //（x,y,width,height）绘制起始点坐标，绘制的宽高&lt;/script&gt; 贴上自己做的demo 这里写图片描述 未完待续。。。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express快速构建应用(一)]]></title>
    <url>%2F2017%2F12%2F25%2FExpress%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 Express是基于Nodejs的前端应用构建工具，可以快速开发基于Node的前端SPA，在Nodejs的基础上，又进行一些功能的扩充，使得应用的构建流程非常简单高效，应用也足够健壮。 1.安装与 环境配置首先使用IDE建一个工程目录，放在Nodejs.exe 的同域目录下。然后打开Git bash,输入，然后进入工程目录，接着 $npm init 表明我们要创建一个应用，最后疯狂回车，可以看到，在工程目录里自动生成了package.json文件。 这里写图片描述 接下来安装Express，命令行敲：$npm install express --save将express包存放到我们的工程目录里，甚至还可以将其在json文件中声明依赖关系，只需要多加一个-dev： 1$npm install express --save-dev 接着会看到工程目录里出现了modules子目录，并且已经为我们下载好了express及其依赖的包（看上图）。 接下来，我们创建一个app.js，放在工程子目录，app.js代码如下： 12345678910111213//app.jsvar express = require(&apos;express&apos;); //require进来我们的Expressvar app = express(); //实例化//匹配任意路由，都返回下面这句：first test successapp.get(&apos;/&apos;,function(req,res)&#123;res.send(&apos;first test success!&apos;);&#125;);//接着配置servervar server = app.listen(3000,function()&#123;console.log(&apos;绑定到了3000端口&apos;)&#125;); 在命令行敲：$node app.js，打开浏览器输入127.0.0.1:3000 可以看到”first test success” 这里写图片描述 2.路由功能在进入一些网页的时候，会看到后面的url坠着 index.html，这是网站的homepage，如果去列表页，则后缀会变成: list.html，这个其实就是路由，根据请求的url不同，服务器返回不同的路径。而express可以很好的胜任这个功能。下面来看在刚才的app.js中加入一些代码，并创建新的index.html文件： 1234567891011121314151617181920//app.js//使用get请求到index.html时，会向页面吐出一个index.html的文件app.get(&apos;/index.html&apos;,function(req,res)&#123; res.sendfile(&apos;./index.html&apos;) &#125;);//index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;gekki&lt;/h1&gt; &lt;h2&gt;hello&lt;/h2&gt; &lt;h3&gt;ke;llt&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 接着，继续运行$node app.js，网页中输入URL：127.0.0.1:3000/index.html效果如图： 这里写图片描述 成功了！ 在命令行中，会提示 这里写图片描述 提示我们 : res.sendfile不太赞成使用，应该使用驼峰式命名 res.sendFile。。。粗心了。由上述例子可知，express对于路由的配置非常之简单。设想一下，在一些需要密码和表单操作密集的地方，可以采用post请求来进行路由的配置。那么同理，如果想要加载图片或者加载其他问价，则可以： 123456789101112//表单的htmlapp.post(&apos;/form.html&apos;,function(req,res)&#123;res.sendFile(&apos;./form.html&apos;);&#125;);//访问路由的某个图片//all方法用于 匹配所有的请求类型，不管是post,get,put,delete等等都给他返回指定的东西，一视同仁。app.all(&apos;./longzhu.png&apos;,function(req,res)&#123; res.sendFile(&apos;./img/longzhu.png&apos;);&#125;); 3.静态资源所谓的静态资源，就是一旦网页生成，就不会再被改变了。例如：图片，CSS,JS文件等。我们可以将这些文件放置在一个统一的文件夹里面，命名为：public 这里写图片描述 现在，在public下粘贴一张图片，接下来，我们来看这些静态资源应该如何配置以及访问： 12//app.jsapp.use(express.static(&apos;./public&apos;));//一句话就完成了静态资源的配置 接着，在浏览器中输入:127.0.0.1:3000/xxx.png ，我们可以得到效果： 这里写图片描述 说明静态资源配置成功，同理，我们在来试试其他类型的文件: 这里写图片描述 这里写图片描述 都OK。 有时候，可以在一个路由请求中写多个callback函数，来不断的匹配用户输入的需求路由： 123//app.jsapp.get(&apos;/123.error&apos;,callback1,callback2); 此时，如果第一个callback捕获不到路由，则将皮球提给第二个callback函数来执行，不过要在第一个callback中写明白参数:123456789function(req,res,next)&#123;console.log(&apos;对不起，我没找到，现在请下一个回调函数帮你找&apos;)next();&#125;,function (req,res)&#123;console.log(&apos;find it!&apos;);res.sendFile(&apos;123.error&apos;);&#125; 整个回调函数甚至可以组成一个数组，来对用户的请求进行匹配： 12345678910111213141516171819202122回调函数1: var a = function(req,res,next)&#123;....next();&#125;;回调函数2:var b = function(req,res,next)&#123;....next();&#125;;回调函数3:var b = function(req,res)&#123;....console.log(&apos;找到了!&apos;);&#125;;app.get(&apos;/123.error&apos;,[a,b,c]); //这样写很美观 当然也可以使用数组和function(){}的混合写法，但是这样写我想不出来哪个地方有好处？ 在访问不同的路由时，不必从新restar server，因为服务器是在返回本地的目录，这个状态是一直轮询的，如果有就返回，没有就老老实实报错404 . 当然，整个路由匹配的时候，甚至可以使用正则魔法，以防止用户的误输入行为，防患于未然。 4.API走马观花1.res.download() 提示下载文件。 //res.download(‘文件名’)，2.res.end() 终结响应处理流程。3.res.json() 发送一个 JSON 格式的响应。4.res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。5.res.redirect() 重定向请求。 //更改用于在根url之后的路由，例如用户输入了:127.0.0.1:3000/index.html我们可以res.redirect(&#39;error.html&#39;);，此时浏览器的url会自动变成：127.0.0.1:3000/error.html 6.res.render() 渲染视图模板。7.res.send() 发送各种类型的响应。8.res.sendFile 以八位字节流的形式发送文件。9.res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。//express预设好了，我就试了两个:res.sendStatus(200)//页面显示：OK 1res.sendStatus(404)//页面显示：Not Found 留坑。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular1.4.6 & Bootstrap3.3.7搭建后台人员管理系统 1.0.0]]></title>
    <url>%2F2017%2F12%2F19%2FAngular1-4-6-Bootstrap3-3-7%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-1-0-0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 前言：接触前端快1满一年了，从什么都不会，一步步摸索，走到现在，觉得前方的路还是很迷茫，但是每天感觉自己都在进步，这是最好的！希望自己能坚持下去，也跟各位同仁共勉！ 1234567@important message!&#123; &quot;name&quot;:&quot;Manage-system-By-AngularJs&quot;, &quot;version&quot;:&quot;1.0.0&quot;, &quot;author&quot;:&quot;ZQ-jhon&quot;, &quot;connect&quot;:&quot;QQ:350037310&quot;&#125; 直接上全部效果的演示图：Let’s view together: GIF加载中，请耐心等待... ... 1.Angualr和Bootstrap的火花Angular是开发SPA的得力框架，其数据双向绑定和指令系统能够最大程度的保持页面的 整洁干净，而Bootstrap作为一个UI库，也能够很好的满足本系统的需求。 2.思路2.1 在后台人员管理系统中，需要有以下功能：增、删、改、查。 为了实现这些功能，就必须在项目中留好数据接口，方便跟后台数据进行I/O操作。 2.2 为了实现部分功能的 toggle()，例如： 点击编辑，文本框的可编辑状态会来回在: 可编辑/不可编辑 切换。 点击编辑，删除button的 show 与 hidden。 必须使用一个ng-show = bool/ng-disabled = !bool，bool的具体方法每次访问，会 更改布尔值为对立值： 12345678910//初始化:$scope.bool = true;//调用改变自身布尔值$scope.toggle = function()&#123; $scope.bool = !$scope.bool; //谁调谁改变 &#125; 而这个$scope的bool()方法，应该位于$rootscope是最好的解决方式，所有的局部 controller都可以访问到根作用域。 因此，改写如下： 123456$rootscope.toggle = function()&#123; $rootscope.bool = !$scope.bool; //谁调谁改变 &#125; 3.实现3.1 框架搭建 ：使用bootstrap搭建框架 3.2 初始数据展示：为了让用户有一个直观的展示，当前界面上会mock一些假的数据上 去，仅供参考(当然这些数据也可以删除)，mock的方法为，在$scope上绑定一个数 组，该数组是对象数组，然后用过ng-repeat来展现在我们的bootstrap表格中。 3.3 框架代码： 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;h1 class=&quot;text-center&quot;&gt;增删改查后台管理系统&lt;/h1&gt; &lt;table class=&quot;table table-responsive table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;职务&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot;&gt;编辑&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;button class=&quot;btn btn-success&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/i&gt;创建新用户&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; 3.4 ng指令系统的控制原理与规划过程 3.4.1 指令构建 首先在表格上声明 `ng-app =&quot;myapp&quot;` 并且声明控制器`ng-controller=&quot;ctrl&quot;` 接着，在需要toggle切换的地方赋值，如果默认要false,可以使用 ng-show=&quot;!bool&quot;或者 ng-disabled=&quot;bool&quot; 这里因为初始值是： `$scope.bool = true` 然后，在$scope上绑定初始数据，即一个对象组： 1234567891011 var app=angular.module(&apos;myApp&apos;,[]);app.controller(&apos;ctrl&apos;,function($scope)&#123; $scope.users = [ &#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;, &#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;, &#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;, &#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;, &#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;, &#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125; ]; 有了元数据，就可以为所欲为了，在需要的位置，例如 table 中的 tr 进行ng - repeat 循环，循环的结果是 对象数组中每一个对象！然后在对应的&lt;td&gt;&lt;/td&gt;中使用或者balalala进行取值 为了完成自动化序号排列以及删除功能，需要$index服务，不需要依赖注入。 当每个删除按钮点击的一瞬间，Angular如何判断该删除哪个呢？ 我们为每一个删除按钮button添加一个指令 `ng-click = &apos;remove($index)&apos;` 这里，Angular就是通过$index来自行判定当前的行序。来看这一块的代码： 1234567891011121314151617181920&lt;tr ng-repeat=&quot;user in users&quot;&gt; &lt;td&gt; &lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot; ng-click=&quot;toggle()&quot;&gt;编辑&lt;/span&gt; &lt;/td&gt; &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.name&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.age&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.job&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;button class=&quot;btn btn-danger&quot; ng-click=&quot;remove($index)&quot; ng-show=&quot;!bool&quot;&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt; OK，删除，排序，Toggle功能都完成了，还有一个增加新用户怎么完成呢？ 这个更简单了，直接往Object Array 里 push 对象即可： 1234567891011/****这是增加用户按钮的指令*****/ng-click = &quot;addUser()&quot;/*****以下是js*****/ $scope.addUser = function()&#123; var index = $scope.users.length-1; //确定当前最大的行序（ps.本来想自己实现 $index 功能的。。。） $scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;); &#125; 以上，就完成了一个后台管理系统，这是初始版本，后续我会增加新的功能在里面。 4.初步完成alpha版本，觉得还是有很多不足之处：1.数据很糙，很杂，controller中的东西太过冗杂，而我并没有选择使用构建工具来模块 化、打包、合并，这不是一个好习惯。 2.所有的输入框没有加入过滤器，例如：姓名的位置我们可以用filter或者正则来强行限 定只能输英文，而不是数字或者标点。 这是一个细节不够完善的地方。 3.在点下编辑的时候，文本框变得可以编辑，再次点下编辑，文本框变成了丑丑的不可 编辑，我在想：** 如何可以使得文字在不可编辑的状态下自动切换为&lt;p&gt;标签，而在可编辑的状态下变成&lt;input&gt;表单？**4.自学了这么久ajax,nodejs，然而并没有从后端拉任何数据，所有数据都是angular来 进行操作的，这样也不好，我希望尽快精通express，来进行项目的全栈构建。 以上问题留给自己去解决。 最后，附上我的Github地址，fork 或者 download都可以 地址：https://github.com/ZQ-jhon/Manage-system-By-AngularJs 注意：将 index.html中的 1&lt;script&gt;以及&lt;link&gt;的src 及 href 替换 成本地目录 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于jQuery中scrollTop中的一些兼容问题。]]></title>
    <url>%2F2017%2F12%2F13%2F%E5%85%B3%E4%BA%8EjQuery%E4%B8%ADscrollTop%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 最近在做一个响应式的页面，需要有按钮来实现点击回到页头及点击回到页尾的功能。在使用 1234567$(&apos;#btn&apos;).click(function()&#123; $(body).animate(&#123; scrollTop:0 &#125;,speed);&#125;);//发现，该功能只在IE与FireFox下有用，Chrome内核无效。 这里写图片描述 即： 选择器为body时：FireFox无效，Chrome有效选择器为html时：Chrome有效，FireFox无效 因此，在编写代码的时候，只要进行双重选择即可兼容： 1234567$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123; var speed = 400; //滑动的速度 $(&apos;html,body&apos;).animate(&#123; scrollTop: 0 &#125;, speed); return false; &#125;); 经测试，在IE(9及以上),FireFox及Chome浏览器下，均能正常使用该功能。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs基础配置、核心概念与学习路线回顾]]></title>
    <url>%2F2017%2F12%2F12%2FNodeJs%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 Nodejs把前端开发带入一个全新的阶段，他使得js能够跑在服务端上，大大强化了js这门语言的可塑性。OK，环境配置不提，配置好了以后，直接来跑一些简单的demo 以前一直没搞懂nodejs复杂的目录（其实是不懂linux），老把文件目录和运行时的目录搞错。 在gitbash下，先进入对应的目录，例如我的js文件在 D:\node\nodejs下，那么应该： 12$ cd d:$ cd node/nodejs 这样就OK啦，如果想跟IDE进行配合也不是不行，步骤如下：1.在node.exe同级下建立project，命名为 nodejs ： 这里写图片描述 2.在IDE中添加新建项目，添加刚才的文件夹路径： 这里写图片描述 欧~~尅！接着，在IDE里面新建几个js文件，然后在我们的Node上面跑一跑(CreateServer那个DEMO就不做了)。建立第一个文件:hello.js （null文件）建立第二个文件:world.js（null文件）两个文件可以在同级目录，也可以不在。 将下列代码填入hello.js： 1234function hello()&#123; console.log(&quot;hello&quot;)&#125;exports.hello =hello(); 打开gitBash,找到IDE中工程的目录(最好把js文件放在工程目录下即可，或者单独建一个js文件夹)：然后输入：$ node hello.js 这里写图片描述 然后将下列代码填入 world.js : 12var world = require(&quot;./hello.js&quot;);world.hello 运行之，得出下图： 这里写图片描述 可以看到，两次的运行结果一样。hello.js的运行结果为hello不足为奇，那么world.js为什么也输出hello呢？ 这是因为在hello.js中，打包出来一个公共模块，exports.hello =function(){....}而在world.js中，引入了这个模块，并且赋值给变量world: 123456789var world = require(&apos;./hello.js&apos;) /*引入【hello.js里面打包的模块】*//*此时，world相当于拥有共有模块的所有属性和方法了，那么此时，这个world有一个方法为hello,我们调用这个hello方法，world.hello ，自然而然输出hello*/ 如果将hello.js改进一下，12345var i=0 ; function hello()&#123;++i;console.log(&quot;hello for &quot; + i)&#125;; 运行 node hello.js 输出: //hello for 1 同时更改world.js: 1234var world = require(&apos;./hello.js&apos;)var world1 = require(&apos;./hello.js&apos;)world.helloworld1.hello 运行 $node world.js 输出//hello for 1甭管运行几次，都是这个结果 这说明，引入模块时，只有第一次引入时会初始化模块。 模块的集合：包(package)所谓的包，就是内部集成了好多模块，主要使用一个入口文件作为包的入口，该文件的导出对象作为包的公有模块： 1234567一 ---nodejs|一 ----js | -----main.js | ------head.js | ------body.js | ------footer.js|一 ------package.json 此时，main.js是包的入口和导出对象模块，在main.js中，很有可能引入了head.js、body.js、footer.js的导出模块，然后写入一些功能和方法，最后导出一个公有方法，供其他的包或者模块使用。 当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。 当引用包的入口文件时，require(‘./node/nodejs/main.js’)这样给人感觉仿佛在引用一个模块，而不是整个包。解决方法是，将Main.js命名为index.js，这样，在引入包的入口文件时，直接填写包入口文件的路径：1234var cat = require(&apos;./js/index.js&apos;);var cat = require(&apos;/js&apos;);//上面两条语句等价 这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。 也可以用json文件来声明入口： 123｛ &apos;main&apos;:&apos;./main.js&apos;｝ 这样，在引入包的入口文件时 require(‘./node/nodejs’)时，会优先查找json文件，并从中读取入口配置，注意，此时的json一定要在引用的路径之下。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax回顾]]></title>
    <url>%2F2017%2F12%2F12%2Fajax%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 jq与原生以及angular中的ajax（长文）http://blog.csdn.net/qq_20264891/article/details/78457021 上面是之前写的一篇关于ajax的帖子，里面的集成包xampp的配置方法有点不太科学， 虽然这样可以运行，但感觉不是很美滋滋。 感谢新浪博主@期待下一站幸福 具体参考原文地址：http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html 配置外部服务器，运行后端代码php？对于完全是小白的我而言，实在是想都不敢想。因为得学习Ajax，就必须得给服务器的发送请求和等待服务器响。所以就在老师的带领下，开始了服务器的配置。 首先介绍一下，我用的IDE:​HBuilder. 后端语言是php。 我使用的是模拟服务器的软件：XAMPP​ (下载地址：https://www.apachefriends.org/download.html) 然后说一下，我要做什么样的效果： 让一个PHP文件在本地服务器上运行。（对！就是这么简单，我捣鼓了一个多小时…）​ 好了，接下来我们来看看吧。 ​ 1,安装一个模拟的服务器。 如果你和我一样，没有任何的​Apache，MySQL，tomcat等WEB服务器。那就下载一个XAMPP.【好用于部署一个本地服务器】 ​安装完成后，打开的界面是这样子的： 这里写图片描述 我们可以先点击“start”启动，这时候需要注意的是：可能出现错误。【错误是：端口被占用】。 引用块内容 解决方法是：点击config–进入Apache（httpd.conf）–找到listen（监听的端口号）进行修改。如图： 这里写图片描述 好了，可以重新启动Apache啦。 2.打开HBuilder，然后新建一个项目。 注意：新建的项目—一定要在我们刚刚打开的XMAPP安装目录下的​htdocs文件夹下面。 （不要问为啥，这是我一晚上调试出来的经验）​ 这里写图片描述 在安装目录下的htdocs，新建文件 3.在HBuilder中的快捷工具栏中找到【浏览器】，打开它的下拉菜单，点击【设置web服务器】。 进入页面点击”外置web服务器“​–选择”新建“ 这里写图片描述 这里写图片描述 添加本地服务器 4.把你写的PHP文件可以在浏览器中，打开了。 这是我的源文件： 这里写图片描述 这里写图片描述 OK,接下来才是正文：一、javaScript原生Ajax1.浏览器自带的与服务器交互的对象及附带API 该对象是一个全局对象，即位于window对象下。IE与非IE，该对象不同 非IE &amp;&amp; IE7+ : XMLHttpRequest IE5,IE6: ActiveXObject 2.兼容创建大法 123456789101112var xhr=null;//初始化变量if(window.XMLHttpRequest)&#123;//非IE&amp;&amp;IE7+xhr = new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//不同的IE版本，里面写的东西不一样，具体请自行baidu&#125; 3.创建好之后的后续步骤 xhr.open() //该方法用于 创建 连接服务端的请求。 xhr.send(); //所有的事情完毕，正式发送请求。 注意： xhr.open(method,url,async) 请求方式，请求地址，是否异步？(ps:默认为true,异步执行) 设置好open中的传参，接着执行xhr.send()。 4.如何知道请求与相应成功不成功？？ 这里，xhr对象自带 一个方法，用来检测连接是否成功，以及对xhr创建过程进行监听， 为什么这样说呢？直接看代码： 123456789101112131415 xhr.onreadystatechange=function()&#123; if(xhr.readyState=4&amp;&amp;xhr.status==200)&#123; document.getElementById(&apos;box&apos;).innerHTML = xhr.responseText; &#125; &#125;***************上面界定了，请求成功以后，将响应的内容放在我们的box盒子里******** xhr.open(&quot;GET&quot;,&quot;01.php?a=5&amp;b=1&quot;,true);//传参a=5,b=1 xhr.send(); //因为上面的方法是异步执行的，因此不用纠结，xhr.open()和send()的位置。&#125; 运行结果: 这里写图片描述 附上php的代码： 123&lt;?phpecho &quot;a为&#123;$_GET[&apos;a&apos;]&#125;,那么b为&#123;$_GET[&apos;b&apos;]&#125;&quot; ?&gt; 这里php代码看不懂的话， 可以去http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP 的基本语法。作为一个前端，后端语言要了解其接口和语法，这是最起码的(这个B装的66666)。 说好的监听xhr对象的创建过程呢？123456xhr.onreadystatechange = function()&#123;//这里加上一句话 :console.log(&quot;当前的XMLHttpRequest对象的创建进度为&quot;+xhr.readyState)...... &#125; 来看打印结果: 这里写图片描述 可见，每次xhr对象自身状态值改变，都会调用函数，因此导致我们打印的结果发生变化。 由此可得，ajax的创建是分步进行的，查询资料可得： 0 对象未创建 1 已与服务器连接 2 服务器已经接受请求 3 服务器正在处理请求 4 服务器将请求下发同时，status也需要有响应的返回值，从服务器传递回来，有个状态值(xhr.status)： 如果响应成功，就返回200如果没找到，返回404其他还有403,5系列等等，不再赘述。 二、jQuery中的ajax1.load方法 1234567891011121314151617181920兹有按钮与容器各一个：&lt;input type=&quot;button&quot; value=&quot;点我加载&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;//js如下 &lt;script type=&quot;text/javascript&quot;&gt; $(&apos;#btn&apos;).click(function()&#123; $(&apos;#box&apos;).load(&apos;03.php&apos;) &lt;/script&gt; //php如下&lt;?phpecho &quot;hello,world!&lt;br/&gt;a = &#123;$_POST[&apos;a&apos;]&#125;&lt;br/&gt;b = &#123;$_POST[&apos;b&apos;]&#125;&quot;?&gt; 这里，点击按钮，box载入响应值，这个方法是get方法。如图： 这里写图片描述 如果，在load()多传一个json对象: 1234$(&apos;#box&apos;).load(&apos;03.php&apos;,&#123; a:5, b:1 &#125;) 那么这个请求会自动 变成post请求。 这里写图片描述 在 Ajax数据载入完毕之后，就能执行回调函数 callback，也就是第三个参数。回调函数也可以传递三个可选参数：responseText（请求返回）、textStatus（请求状态)、XMLHttpRequest对象。 123456789$(&apos;#btn&apos;).click(function () &#123; $(&apos;#box&apos;).load(&apos;03.php&apos;, &#123; a:5, b:1 &#125;, function (response, status, xhr) &#123; alert(&apos;返回的值为：&apos; + response + &apos;，状态为：&apos; + status + &apos;， 状态是：&apos; + xhr.statusText); &#125;);&#125;); 运行结果： 这里写图片描述 这里的status和xhr.statusText都是经过jQuery进行处理的，原本的值应该对应为：2002.$.get()和$.post() .load()方法是局部方法，因为他需要一个包含元素的 jQuery对象作为前缀。而$.get()和$.post()是全局方法，无须指定某个元素。对于用途而言，.load()适合做静态文件的异步获取，而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。 123456$(&apos;#btn&apos;).click($.get(url,&#123;json.data&#125;,callback(),type)&#123;&#125;)/*GET方法与load()方法相比，多了最后一个参数，返回类型，可以设置为xml,html,json,text等，一般不需要设置，都是jQuery智能判断返回的。第一个参数：请求地址，是必须的，后面的都是可选参数。*/ $.post()方法 的使用和$.get()基本上一致，他们之间的区别也比较隐晦，基本都是背后的 不同，在用户使用上体现不出。具体区别如下： 1.GET请求是通过 URL提交的，而 POST请求则是 HTTP消息实体提交的； 2.GET提交有大小限制（2KB），而 POST方式不受限制； 3.GET方式会被缓存下来，可能有安全性问题，而 POST没有这个问题； 4.GET方式通过$_GET[]获取，POST方式通过$_POST[]获取。3.load(),$.get(),$.post() 的集合：$.ajax 12345678910111213//ajax是jQuery封装的最底层的方法 $(&apos;btn[submit]&apos;)[0].click(function()&#123; $.ajax(&#123; type:&quot;get&quot;, //请求方式 url:&quot;02.php&quot;, //地址 async:true, //异步 success:function(response,status,xhr)&#123;alert(response)&#125;, //成功回调函数 error:function()&#123;&#125;,//失败回调 data:$(&apos;form&apos;).serialize()//表单序列化 &#125;); &#125;) 三、AngularJs中的ajax1234567891011121314151617181920212223在任一一个控制器中注入http依赖var app = angular.module(&apos;myApp&apos;,[]);//http模块注入到任一一个控制器中app.controller(&apos;ctrl1&apos;,function($scope,$http)&#123;$http(&#123; method: &apos;GET&apos;, //选择请求方式 url: &apos;02.php&apos; //请求地址 &#125;).then(function successCallback(response) &#123; // 请求成功执行代码 &#125;, function errorCallback(response) &#123; // 请求失败执行代码//语法为：$http.then(success(),fail())&#125;); 声明：v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代。因此千万不要 1$http.success().error()//错误写法！z不能跟jQuery混淆 总结：Js/jq/angularjs 中ajax的： 相同点1.都是异步的请求，都支持get,post方法,jq,angular支持(put)。 不同点： 1.jq中，对于ajax请求的写法非常简单，非常直观。angular中，通过$http模块也进行相应的封装，非常方便。 2.普通的javaScript AJAX请求，如果需要GET方法传参，只能强行用”？”追加到url后面，并且不同参数连接要用&amp;进行，非常繁琐。 3.所谓jq的success(),error()，以及angular的then方法，都是对原生ajax的 status的不同返回值进行封装,例如：200就会执行success函数，404就执行error函数。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git与GitHub之远程仓库]]></title>
    <url>%2F2017%2F12%2F11%2FGit%E4%B8%8EGitHub%E4%B9%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 在GitHub上创建一个repository。1.首先，生成私钥和公钥： $ ssh-keygen -t rsa -C “350037310@qq.com” (最好填写gitHub的注册邮箱) 这里有个关键的地方：SSH，待会会用到。 这里写图片描述 2.将本地的Git关联到GitHub 在本地命令行中：git remote add origin git@github.com:ZQ-jhon/test.git即可关联远程仓库(这里的git@github.com对应上图。) 狂敲回车，然后在C：/Administrator下会生成一个.ssh文件夹，找到里面_pub的文件，记事本打开，全部ctrl+c，来到: gitHub—–&gt;Settings——&gt;SSH and GPG keys ,点New SSH Key ，title随便取个名字，底下内容粘贴刚才复制的_pub文件，OK。 OK，至此，两个库已经关联起来了。关联的GitHub项目库仅仅是名为test的这个库。 3.将本地库推到GitHub中。$ git push -u origin master 4.提示信息第一次关联推送时，提示： 123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 输入yes，回车，OK，现在远程仓库和本地仓目录一摸一样了。 以后每次推送，只需要$git push origin master就行。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git与GitHub之本地仓库]]></title>
    <url>%2F2017%2F12%2F11%2FGit%E4%B8%8EGitHub%E4%B9%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 马上就要到年底了，再复习一下Git的相关知识，还有20天，再拼拼命！概念Git:分布式版本管理系统。GitHub:全球最大同性交友平台。(匿) 1.本地的版本库1.1环境搭建首先确保已经安装了Nodejs的环境。首先，下载GitBash命令工具。https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit运行之。命令行中敲入 1234$cd g:$mkdir git$cd gitg盘下创建git目录，并且进入该目录 1.2 建仓库1.创建本地仓库 1$git init //创建OK，g:\目录下多了一个 .git的文件夹 然后，在桌面上手动新建一个test.txt文本，里面输入 “hllo,world”，然后将该文本放到git目录下(就是刚才创建的那个目录) 这里写图片描述 2.现在，将文件读取至工作区 1$ git add test.txt 这样，就完成了工作流的初步设置 3.对txt文件暗中做手脚 在test.txt文件中，将”hello,world”改为”hey,boy”，然后ctrl+s，ctrl+F4二连。 4.再次commit至暂存区再次提交至暂存区（如果不再次提交，那么刚才的改变只是在仓库里改变了，而并非在我们的暂存区进行记录。）1$ git add test.txt 5.然后读取暂存区文件的状态： 1$ git status 6.接着上传到本地版本库: 123$git commit -m &quot;first change&quot; //回车***************注意:!!!每次commit都会生成一个版本****** OK,这样，系统就记录下了这次改变。当然也可以随时$git status ，来查看当前的暂存区是否干净 (clean)。 7.要查看历次的修改记录，或者回滚到任一一个版本，可以: 12$git log或者$git reflog //reflog可以显示每次迭代的文件值，并进行排序 如果想要项目升级或降级到某一个版本，可以这样： 1$git reflog //查看变更记录，与对应的入口文件值(自动生成) 想去哪里就去那里： 123$git reset --hard &quot;对应的文件入口，例如35s421&quot;/*这里的入口文件值，可以写5位，4位甚至更少，因为计算机会自动根据名字来遍历检索，因此为了效率和不必要的麻烦，尽量写7位左右。*/ 8.撤销修改改到一半发现还不如不改？如果没有commit，那么可以使用“一键还原” 123$git checkout --test.txt//这会使test.txt回到版本库中的状态，即：还没有bei $git add test.txt的时候 如果已经commit了，那么只能回到最后一次commit的状态。 123$git rm test.txt //做完测试，顺手清理 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP初体验]]></title>
    <url>%2F2017%2F12%2F09%2FPHP%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 1.连接符1234567$color = &apos;red&apos;第一种连接方式: echo &quot;my color is $color&quot;第二种连接方式: echo &quot;my color is&quot;. $color .&quot;&lt;br&gt;&quot;//（VB是&amp;链接，js+链接，这个.链接真的反人类）第三种连接方式: echo&quot;my colo is&#123;$color&#125;&quot;//花括号包住变量第四种连接方式(相当于js字符串的+=):$a=&quot;hello&quot;;echo $a.=&quot;world&quot;; //hello,world 2.变量Scope1.全局作用域定义的变量只能在全局读取，函数内部都无法读取。2.局部作用域定义的变量只能在局部读取，全局无法读取。（js的变量是：父域的变量可以让子域读取，反过来则不能。）如果局部子域想要访问Global变量，则需要提前声明：爸爸，我要用你的变量： 12345678$a = 5;function son()&#123;global $a ;$b = 1;return a+b&#125;son();//6 更或通过所有全局变量的数组来访问全局变量，因此上述的表达式 1global $a等价于： $GLOBAL[&apos;a&apos;] (下标注意，有引号) 如果想要局部变量的函数在函数执行完成以后不被销毁，即继续在全局域下使用，那么应该提前声明static(静态的)关键字： 12345678910111213&lt;?phpfunction myTest() &#123; static $x=2; echo &quot;结果是:$x&quot;; $x=$x*$x;&#125;myTest();//2myTest();//4myTest();//16?&gt; 3.常量(真·全局量)相当于全局的变量，但是值不可更改或者撤销定义 定义方法：define(name,value,bool)，参数很简单，关键在第三个参数，对大小写不敏感吗？默认flase，对大小写敏感，如果强行设置第三个参数为true,则对常量名字大小写不敏感。 4.运算符+，-，*，/，% ,==,=== 大同小异。 唯一和js不同的是，不等于可以写成 &lt;&gt;，啊哈哈，和vb有点像 5.超全局变量PHP 超全局变量1$_GET 和 $_POST 用于收集表单数据（form-data）。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记3]]></title>
    <url>%2F2017%2F12%2F05%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 eg13.依赖注入故事要从js说起，在js的function(){}中，参数可以传递为另外一个函数。举个例子： 1234567891011121314151617function first()&#123; return 3&#125;//参数函数1function second()&#123; return 5 &#125;//参数函数2function add(a,b)&#123; var a_ = a(); var b_= b(); alert(a_+b_)&#125;//总函数add(first,second);//调用总函数，其参数为first和second的返回值，弹出 8 不光如此，在回调函数中，大致也是这样的思路：12345678function callback(result)&#123; console.log(&quot;您的计算结果为:&quot;+result)&#125;function fn(num,callback)&#123; num = num*num callback(num);&#125;fn(10,callback);//控制台：您的计算结果为100 简短回忆后，发现javaScript函数的特点，函数定义时的参数个数是定死的，但是如果传入的参数不达标/超出/太少，那么函数体就会报错。例如上面的add(first,second)只传入add(first)就会报错：b is not a function普通函数的参数往往是由调用它的人时候来决定的回到angular中，依赖注入与javaScript函数正好相反，函数体一旦定义了参数，调用它的人就得老老实实的传入指定数量/类型的参数。for eg1: 123456&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;c&apos;,function()&#123; alert(arguments.length);//这里打印出0，因为没参数，这个OK，接着往下看 &#125;);&lt;/script&gt; 12345678 &lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;c&apos;,function(s,b)&#123; alert(arguments.length); &#125;); &lt;/script&gt;这里我们发现，虽然传入了s,b两个参数，但是压根连弹窗都没有，只能说明，传入的参数不合法，函数不认。 1234567for eg3:&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;c&apos;,function()&#123; alert(arguments.length); &#125;);&lt;/script&gt; ``` 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax初探]]></title>
    <url>%2F2017%2F11%2F06%2FAjax%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 Ajax初探 1.环境搭建与配置这两天在捣鼓Ajax,期初用的都是开发工具自己集成的apache服务器，但是因为我太蠢，找不到相关的设置项和说明，又或者是我懒得找把，于是搜了一款数据库和Apache服务器集成好的本地站点包：【XAMPP】，百度下载好，按照相关说明进行配置。2.基本设置与文件索引目录 这里写图片描述 如图所示，只需要将Apache与MySQL打钩，并且star，就OK。打开浏览器，输入站点ip与端口（默认是127.0.0.1）然后在安装目录下的,安装盘:\xampp\htdocs 看到有个.html的文件，该就是刚才在浏览器中看到的。可以将这个.html的文件删除，刷新浏览器，可以直接看到浏览器中的目录索引。 这里写图片描述 现在网页上127.0.0.1的目录就是文件库中的映射。以后我们可以将服务器端需要响应的asp/php/txt文件，都放在 安装盘:\xampp\htdocs下即可，环境搭建完成。 3.喜闻乐见敲代码环节 3.1 javascript原生Ajax 所谓Ajax： A:async 异步加载 ja: javascript 脚本语言 x:xml 前后台通信的数据载体，文本 （鉴与json的出现，XML正在被逐渐取代，大有&quot;Ajaj&quot;的趋势） 3.2 目的 目的是为了提高用户体验，更新局部数据时不用刷新整个网页，就可以完成数据交互。 3.3 对象(API) 1. 在IE7+/Chrome/Opera/Safari 中，对象为XMLHttpRequest，该对象属于window下的子对象; 创建方法为1var xhr = new XMLHttpRequest;2.在IE7以下， 对象为ActiveXObject,该对象属于window下的子对象; 创建方法为12var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);//括号中的必须有。 3.4 浏览器兼容判断 12345678910 var xhr =; //var 一个空对象 if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest; &#125; //非IE7以下 else if(window.ActiveXObject)&#123;xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125;//IE7以下else&#123;alert(&quot;您的浏览器过于先进，请降级到合适的版本！&quot;)&#125; 3.5 方法 这个xhr对象，自带了一些方法。 1.open（规定请求的类型，地址，是否异步）方法1xhr.open(method,url,async)2.send(string)方法，用于发送请求该方法中的string，只要在method=”post”时，才可以使用。3.当method==true,那么要设定就绪时执行的函数，跟回调函数有点像: 先说两个属性： (1)xhr.responseText //······························· 返回字符串形式的相应数据 (2)xhr.responseXML //································ 返回XML形式的相应数据1234567891011xhr.onreadystateChange=function&#123;if(xhr.readystate==4&amp;&amp;xhr.status==200)&#123; //这里写下要回调的方法 document.getElementById(&apos;div&apos;).innerHTML=xhr.responseText; //获取返回的文本，这里也可以写xhr.responseXML &#125;&#125;xhr.open(&apos;get&apos;,&apos;123.php&apos;,true);xhr.send();OK,这是默认的异步处理，要执行一个就绪时的函数。那么，在同步模式下，即async=false时，应该这么写请求：xhr.open(“GET”,”/try/ajax/ajax_info.txt”,false);xh.send();document.getElementById(“Div”).innerHTML=xhr.responseText; 3.6 onreadystatechange 存储函数 onreadystatechange 存储着xhr的好几种状态： 0：初始化未就绪 (想找老板要工资，但没准备好) 1：已经与服务器连接 （已经走进老板办公室） 2：服务器已经接受（老板已经听到你的诉求） 3：正在处理请求（老板在苦思冥想给不给你钱） 4：请求已经完成，并且响应也已经下发（想了半天给你了） 每当 readyState 改变时，就会触发 onreadystatechange 事件。 同时，status也需要有响应的返回值，从服务器传递回来，有两个值： 200 响应就绪，成功下发（会计接到老板的电话，立马爽快的给了你工资） 404 未找到 （会计跑路了，尽管老板同意，你还是没拿到钱） 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于百度集成API bd_share的一些窥探]]></title>
    <url>%2F2017%2F11%2F03%2F%E5%85%B3%E4%BA%8E%E7%99%BE%E5%BA%A6%E9%9B%86%E6%88%90API-bd-share%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AA%A5%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 最近在做一个项目因为要用bootstrap，需要对第三方分享的图标设计两个款式，最终需求的效果如下： 一、需求分析 1.在PC端，要求用font字符来实现第三方分享的图标,并且鼠标经过时，设定hover效果： 这里写图片描述 2.在小屏幕设备上，需要设定另外一种款式： 这里写图片描述 二、思路分析 理清需求以后，下面来看是如何实现的： 首先，需要点击这些第三方应用的图片或者字符，来实现相应的跳转，例如点击QQ，进入QQ的分享界面。 如果要完成这一步，需要去每个平台的官网获取分享组件，其实就是人家官方定义好的js API接口。整个页面如果只需要1个2个分享图标还好，要是十几个，20个图标，估计页面会乱七八糟自己看着都糟心。 于是这里安利百度share，集成了大多数的第三方share API,非常的方便，省事，复制，粘贴，一气呵成，但是效果可能就不尽人意了。 看到这里，我以为我打开了二零零年的一张网页，真的，这图标，这32*32的icon清晰度，真的让我很难受。 首先推荐一几个icon库，这些icon非常精美，并且实时更新：1.阿里妈妈icon库：http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&amp;manage_type=myicons&amp;icontype=histories&amp;keyword=2.Easyiconhttp://www.easyicon.net/在这里可以下载相应的icon，推荐下载SVG，这个格式的图片制作字体很方便。 看一下百度官方的代码 12345678910111213141516171819202122232425262728293031&lt;div class=&quot;bdsharebuttonbox&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tqq&quot; data-cmd=&quot;tqq&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_renren&quot; data-cmd=&quot;renren&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdSnsKey&quot;: &#123;&#125;, &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;2&quot;, &quot;bdPic&quot;: &quot;&quot;, &quot;bdStyle&quot;: &quot;0&quot;, &quot;bdSize&quot;: &quot;16&quot; &#125;, &quot;share&quot;: &#123;&#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125;, &quot;selectShare&quot;: &#123; &quot;bdContainerClass&quot;: null, &quot;bdSelectMiniList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;] &#125; &#125;; with(document) 0[(getElementsByTagName(&apos;head&apos;)[0] || body).appendChild(createElement(&apos;script&apos;)).src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5)];&lt;/script&gt; 不难发现，其实a标签的父div：bdsharebuttonbox已经提前为a标签设置好了样式和背景图了。 这里我们下载好图标，能否直接插入到&lt;a&gt; 标签中，然后 实现对应图片的替换呢？显然不行，因为百度通过class类设定好的背景图片，不会被框架内的图片所覆盖，给大家演示一下错误的示范： 这是错误的示范 不仅没有变美，反而更丑了。 三、功能实现 3.1 将原始图标替换为图片图标 怎么办呢？其实我们应该直接设定对应class类的背景图，并且加权!important，就可以完美实现背景图的替换了。 12.bd_qzone&#123;background:url(./img/qq.png) !important&#125;.bd_tsina&#123;background:url(./img/sina.png) !important&#125; 这里要说明一下，百度的Share api第三方的图标，全部都是32*32的，因此如果你的图片过于清晰（分辨率太高），应该增加backgrond-size:cover !important ，来填充。12.bd_qzone&#123;background:url(./img/qq.png) !important;backgrond-size:cover !important &#125;.bd_tsina&#123;background:url(./img/sina.png) !important;backgrond-size:cover !important &#125; 这样，可以实现一个比较好看的图标分享小模块了： 这里写图片描述 这里我用的图标是128*128的，即便将网页放大10倍，也没有锯齿感。 3.2字符图标完成Share 功能的实现 字符图标相比于图片图标，更加节省资源，而且兼容性更棒！(IE4+都支持字符图标)。 我们首先去阿里妈妈或者easyicon下载好对应的透明的svg文件，接着到： https://icomoon.io/app/#/select 这个网站很牛逼，可以将图片转为各种浏览器看得懂的字符文件 (1)我们打开网站，最上方点击import Icons，上传自己的图标图片文件 这里写图片描述 (2)上传好以后， 可以按铅笔图标对文件进行编辑，比如命名，方向结构等等 这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述 （3）上传好以后，点击下面的Generate Font,下载已经转换好的字体文件 （4）下载好以后解压，用记事本打开style.css的文件，复制到你的html页面中的1![这里写图片描述](http://img.blog.csdn.net/20171103180119963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 复制好如下： @font-face { font-family: ‘icomoon’; src: url(‘fonts/icomoon.eot?eqsiuf’); src: url(‘fonts/icomoon.eot?eqsiuf#iefix’) format(‘embedded-opentype’), url(‘fonts/icomoon.ttf?eqsiuf’) format(‘truetype’), url(‘fonts/icomoon.woff?eqsiuf’) format(‘woff’), url(‘fonts/icomoon.svg?eqsiuf#icomoon’) format(‘svg’); font-weight: normal; font-style: normal;} [class^=”icon-“], [class=” icon-“] { / use !important to prevent issues with browser extensions that change fonts */ font-family: ‘icomoon’ !important; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; / Better Font Rendering =========== / -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;} .icon-baidu:before { content: “\e900”;}.icon-mail:before { content: “\e901”;}.icon-qq:before { content: “\e902”;}.icon-qzone:before { content: “\e903”;}.icon-renren:before { content: “\e904”;}.icon-sina:before { content: “\e905”;}.icon-wechat:before { content: “\e906”;}.icon-copy:before { content: “\e907”;} 12345&gt; 这段CSS代码最好不用通过`&lt;link&gt;`标签引入，否则会出现字符无法正常显示的问题，这个问题目前我还在找原因。现在可以看到，通过@font-face已经引入了字体文件，并且已经为你预设好了每张图片(现在他们已经变成了字符或者说字体)的类名。和bootstrap的glyphicon的调用方法很像，都是通过给目标对象添加类名来调用。并且通过css3的高级选择器 ，在被选择元素之前添加了content，然后是对应字符的编号，非常贴心，这个时候只需要在你想要调用的地方添加class类名即可。 最终的效果如下： 这里写图片描述 我通过js/jq又添加了hover效果，这个界面看上去就舒服多了。今天研究了一天这个问题，从最初的不明白第三方分享的原理，到现在可以改变默认样式，我觉得今天收获还是挺多的，对CSS、JS都有了更进一步的理解。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>百度share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript开心消消乐中的迭代算法]]></title>
    <url>%2F2017%2F10%2F22%2FJavaScript%E5%BC%80%E5%BF%83%E6%B6%88%E6%B6%88%E4%B9%90%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客 这两天玩开心消消乐，突然想琢磨一下每次这些小方块的生成算法。不考虑4个相同颜色的情况，理了一下初步的思路，大致如下： 【一、游戏的初始化】1.首先有六种颜色：红、黄、蓝、绿、棕、紫。那么在一个44的矩阵里，要让这六种颜色分布于其中。2.初始化的颜色随机生成，并且每行、每列不能三个相同的颜色相连。3.为了能够进一步的游戏，必须在44的的矩阵中产生两个相连的颜色，并且在前者的左上、右上、左下、右下产生一个相同的颜色，否则整个游戏无法玩。 【二、游戏的模拟点击操作】1.当点击第一个色块，再点击第二个色块，那么，交换这两个色块的颜色。2.如果这两个色块交换之后，并没有产生3个相同颜色相连，那么这种情况就应该保持两个点击色块的原本颜色。 【三、色块消除以后的后续生成*(难点)】1.当三个色块消除后，上面的元素坍塌掉落。并用新的颜色填充坍塌元素的位置，并且还得遵循【一】中的生成原则。 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[好久不见]]></title>
    <url>%2F2020%2F11%2F22%2F%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[很久没有打理博客了，都生灰了。。。今天登录上来，才发现原来的 Valine 评论系统不好使了，白嫖的开发版由于 1 个月没有活跃度，都被 archive 了，惨~遂修好之，希望以后能经常保持输出的频率。]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装 VMWare for MacOS 并使用 随航(Sidecar) 功能]]></title>
    <url>%2F2020%2F03%2F29%2FSidecar%2F</url>
    <content type="text"><![CDATA[本文记录了在 VMWare 下的 MacOS 使用 Sidecar 的种种踩坑记录，希望能对你有所帮助。前置条件科学上网环境一个可以用来 随航 的硬件设备(iPad/iPhone)安装 VMWare for MacOS 并使用 随航(Sidecar) 功能VMWare安装教程这个 up 主讲的比较细，跟着一步一步做就好了 https://www.bilibili.com/video/BV1a7411e7Pq镜像地址MacOS 10.15 镜像：https://www.mediafire.com/file/7wm2251an4c2n64/macOS_Catalina_ISO_By_Techbland.iso/file由于 google drive 上下载镜像比较蛋疼，所以我又找了一个比较 nice 的镜像，可以用迅雷下载（迅雷中打开代理，设置 sockts5 科学代理）速度杠杠的:提前准备VMWare 设置随航 其实支持两种连入方式：同一 wifilightning / type-c 连接由于 VMWare 中，设置的虚拟机网络为继承主机网络，因此，这里采用方式 2首先，硬件设置中，usb 接口调整为 2.0：插入 usb, 看 macOS 能否识别/读取 iPad/iPhone。在插入外部设备的时候，VMWare 会弹出提示，这里要选择连接到虚拟机：如果不能，在 windows 上下载 iTnues 并登陆 iCloud，信任设备，毕竟 VMWare 中的虚拟机也是享用的宿主机的端口，宿主机倘若无法识别，那虚拟机自然也识别不了。如果一切就绪，那么 Mac 上应该显示如下:Sidecar 故障排查可以正常识别后，发现 iPad 只显示控制栏，主要的显示区域是黑的:于是，google 关键词：“vmware cannot use sidecar”得到如下结果：https://forums.macrumors.com/threads/sidecar-has-anyone-got-it-working.2184104/page-11?post=27807001#post-27807001大致意思就是，首先需要关闭苹果的系统完整性保护（SIP）具体的关闭步骤，请看在 VMWare 中启用恢复模式找到 Recvoer 开头的 EFI 文件，回车即可：在 Recover 的命令行中输入:csrutil disable 如果出现下图，那就是 OK 了得到成功的 stout 后，继续输入 reboot 重启。（备注：如果你不能 sudo mount -uw 那么请先 su sudo）关闭以后，发现 System/Library/PrivateFrameworks/SideCarCore.framework/Versions/A/ 不具备写入权限，你 download 下来的 SidecarCore 无法写入到该目录，也无法通过拖拽等方式移入 chown 也不管用，一番 google 后，来到了这里：https://github.com/pookjw/SidecarPatcher#how-to-patch跟着 How To Patch 一步一步做，结果一大堆报错：!11来到 issue 区，发现不止我有这个问题，开发者说了，应该这么去排查 ‘Failed to load module’ 的问题：https://github.com/pookjw/SidecarPatcher/issues/49#issuecomment-604580909安装 XCODE 时，提示无法安装：系统必须是 10.15.2 以上（这个跟 VMWare 安装的镜像版本相关，如果有 10.15.2 以上的镜像，就别用这个镜像了）到了这一步，有两种处理方式：（推荐）直接更新系统, 但确保你的安装盘总空间在 70 G 以上，否则会出现存储空间不足的提示，毕竟一个 update package 得 17 G 左右。更新后的系统： 这时，打开 AppStore 就可以正常的下载 Xcode 了（不推荐）注册海外 apple id，去 https://developer.apple.com/download/more/ 下载 xcode 历史版本难点根据你自己的 Sidecar 设备没选择好对应的 SidecarCore 即可，Apple 是根据 blacklist 来屏蔽一些老设备的，具体请看：https://github.com/ben-z/free-sidecar😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cvm-debug]]></title>
    <url>%2F2020%2F02%2F11%2Fcvm-debug%2F</url>
    <content type="text"><![CDATA[如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信ssh public key当重新 build 了 id_rsa.pub 为什么1$ git clone xxxx@github.git还是会报 permission denied 或者 Please make sure you have the correct access rights and the repository exists 呢？于是，经过尝试:12$ eval "$(ssh-agent -s)"$ ssh-add ~/.ssh/id_rsa发现还是不对。build 的姿势不对首先，在执行 git 相关的命令时，最好不要使用 sudo, github 官方也给出了指导官方建议so, 在 linux 环境下，最好的方式就是直接以 root 的身份来操作目录和 cli：12$ sudo passwd$ su root这样，每次执行任何命令的时候，都不需要烦人的 sudo 了😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base64 encode decode image]]></title>
    <url>%2F2019%2F09%2F06%2Fbase64-encode-decode%2F</url>
    <content type="text"><![CDATA[本文章原始创作地址：https://blog.csdn.net/qq_20264891/article/details/100583761如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信前言最近在修福报，深深觉得，一个程序员或者成年人，最大的敌人就是时间，没有时间，就会陷入焦虑的怪圈，一直出不来。What is Base64Base64 是一组相似的二进制到文本（binary-to-text）的编码规则，使得二进制数据在解释成 radix-64 的表现形式后能够用 ASCII 字符串的格式表示出来。Base64 这个词出自一种 MIME 数据传输编码。 —– from mdn对于前端而言，Base64 使用范围广泛，可以对 ASCII 码进行编码，也是作为 雪碧图 的一种备选方案，即增加运行时的体积，但是减少了静态资源的请求数。对图片的 Base64 编码见 AdvancedHow to use浏览器 API123456789101112// 编码let encodedData = window.btoa("Hello, world"); // 此时 encodedData = 'SGVsbG8sIHdvcmxk'// 解码let decodedData = window.atob(encodedData); // 此时 decodedData = ‘Hello, world’Advanced对于常见的 ASCII 可以解析，那么对于图片，自然有另外的方法：法一： 通过 fetch 图片的 response.arrayBuffer() 来获取二进制缓冲流来进行编码。123456const image = `https://www.xxxxx.xxxx/abc.png`;fetch(image).then(response =&gt; response.buffer()) .then(buffer =&gt; buffer.toString("base64"));目前 NPM 上最活跃的 imageToBase64 中, 是这么写的： imageToBase64法二：通过 Canvas1234// 大致思路:document.querySelector('canvas').getContext('webgl').canvas.toDataURL('image/jpeg', 0.5);第一种，通过图片 url 来获取 base64123456789101112131415161718192021222324252627282930function getUrlBase64(url, ext, callback) &#123; let canvas = document.createElement("canvas"); const ctx = canvas.getContext("2d"); const img = new Image; img.crossOrigin = 'Anonymous'; img.src = url; img.onload = function () &#123; canvas.height = 60; canvas.width = 85; ctx.drawImage(img, 0, 0, 60, 85); const dataURL = canvas.toDataURL("image/" + ext); callback.call(this, dataURL); canvas = null; &#125;;&#125;第二种，parameter 直接是 image1234567891011121314151617181920function getImageBase64(img, ext) &#123; var canvas = document.createElement("canvas"); //创建canvas DOM元素，并设置其宽高和图片一样 canvas.width = img.width; canvas.height = img.height; var ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0, img.width, img.height); //使用画布画图 var dataURL = canvas.toDataURL("image/" + ext); //返回的是一串Base64编码的URL并指定格式 canvas = null; //释放 return dataURL;&#125;]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则复习]]></title>
    <url>%2F2019%2F06%2F20%2FregExp%2F</url>
    <content type="text"><![CDATA[本文章原始创作地址：https://blog.csdn.net/qq_20264891/article/details/92743420如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信前言一直发现我是个野路子，在学完 TS 和 Express 后，才回过头来想巩固一下 正则 的知识，不过话说回来，有了 TS 一些可选参数，以及 后端框架的路由匹配机制后，其实对于正则的理解是有一定作用的。类比这些概念时，发现有太多太多的相似之处，下面将会例举。所以说，贴近标准，跟随标准（世界大厂）是最最最重要的，像小程序这样反 URL 透明可见的精神的产物，站在非商业的角度来看，确实没有任何价值。扯远了。。。下面开始用自己的话来进行盘点：量词我们在匹配字符串中某个 子段 时，需要有足够的数量去进行限制，这样才能保证匹配到的结果足够准确。常见的量词有：? =&gt; 意思为：可选 0 或者 1 ，跟 ts 函数的可选参数一样+ =&gt; 意思为： 1个或者多个* =&gt; 意思为：通配符，0个或者任意个Range 区间例如，我想匹配 1~5 个 ‘a’ ， 用 【量词】中的哪个都不合适，这时候就应该有一个区间的概念来进行约束：12345const reg = /^a&#123;1,5&#125;/i;'a'.match(reg); // 匹配 1 个 a , ["a", index: 0, input: "a", groups: undefined]...reg.test('aaaaa'); // 匹配 5 个 ,["aaaaa", index: 0, input: "aaaaa", groups: undefined]reg.test('aaaaaa'); // 只能匹配到 5 个 ["aaaaa", index: 0, input: "aaaaaaaaa", groups: undefined]可见，{ } 中的边界，是数学定义上的 左右闭合区间。另外，还有一种区间，先看下实例：[a-z] 代表匹配 a-z 的小写字母，[A-Z] 匹配 A 的大写字母。这些用 “-” 来表示的字符集，都是通过 ASCII 码 来进行排序的。举个 🌰：123const reg = /([a-z][A-Z])&#123;1,2&#125;/;reg.test('aZ'); // truereg.test('aBcccadsadsad') // true 匹配到了一个反向字符集例如 [a-z] 是匹配 a-z 的字母， 那么 [^a-z] 相当于不匹配小写字母。举个例子：1234const str = `abcdef`;const reg = /[abcde]/; =&gt; 匹配 `abcde`， 没 `f`const reg2 = /[abcde]/ =&gt; 只匹配 `f`内置特殊匹配器为了不让广大开发者写出太过于雷人的代码，也是内置了许多匹配器：\b 匹配单词边界 \B 匹配非单词边界\w 匹配字母 \W 匹配非字母\d 匹配数字 \D 匹配非数字其他制表符和换行符等,例如 \r, \t ,\v 等贪婪和非贪婪匹配贪婪顾名思义，就是尽可能多的匹配。1234567// 不贪婪const exampleStr = `RegExp is very interesting!`;/[a-zA-Z]+?/ =&gt; 只匹配 'R'// 缺省则为贪婪模式/[a-zA-Z]+/ =&gt; 匹配 'RegExp'四个 flagg 全局m 多行i 不分大小写y 粘性(sticky)😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 decorator 深入探析]]></title>
    <url>%2F2019%2F06%2F13%2FES7%20decorator%20%E6%B7%B1%E5%85%A5%E6%8E%A2%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文章原始创作地址：https://blog.csdn.net/qq_20264891/article/details/91357985如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信起因一直享受着 Anuglar 和 Nest 的红利，上来就是 @Component(...) 或者 @Controller(...)，自己却没有实际的探究过背后的原理。于是今天想好好总结一下，沉淀沉淀。前置条件（es5 原理）之前看过红宝书，第六章提到过，js 对象的属性有几个特性：[[configurable]] 是否可配置[[enumerable]] 是否可枚举[[writeble]] 是否可修改值[[value]] 写入的值是啥四个配置项都为 boolean 类型。这四个配置联合起来有一个名字，叫做对象属性的描述符(descriptor)其中，writeble 和 value 还有另外一个名字， setter 和 getter 访问器）。上代码：123456789101112131415161718192021const obj = &#123; &#125;;Object.defineProperty(obj,'a', &#123;value: 1,writeble: false,&#125;);console.log(obj); // &#123;a: 1&#125;console.log(obj.a) // 1obj.a = 3; // 修改 a 属性的值console.log(obj.a) // 1/**====================另一种写法====================*/const d = &#123;&#125;;Object.defineProperty(d , 'name' &#123;get: function() &#123;return 1&#125;,set: function(value) &#123;return false&#125;&#125;);console.log(d) // &#123;&#125; 注意！！！！这里跟 writeble 和 value 不太一样，这里打印出来的对象，是没有显示 name 属性的！！！但是访问可以访问出来d.name; // 1d.name = 3; // 尝试修改 name 属性 d.name; // 1我们发现，配置了可写入项为 false 时，我们就无法去修改对象属性的值了，有点像冻结的意思。刚好，JS 有个 Object.freeze()， 来看一下1234const c = &#123;name: 1&#125;;Object.freeze(c);c.name = 3;console.log(c) // &#123;a: 1&#125;发现和我们自己去配置 writeble: false 效果相同。不信？来验证一下：12345678910Object.getOwnPropertyDescriptor(c);// 返回： &#123; name: &#123; configurable: false enumerable: true value: 1 writable: false &#125;&#125;ES6 还要这么写吗？不用。直接用装饰器 decorator来写。第一种，直接装饰 class，作用： 给类增加动态属性，该动态属性并不会被继承，只能作为 被装饰类 的 静态属性。注意： 给类添加静态属性的这种行为，是在 编译时 发生的！所以说：装饰器的本质就是编译时运行的函数123456789101112function addFlag(object) &#123;object.flag = true;&#125;@addFlagclass Foo()&#123;&#125;Foo.flag // true// 来个实例const f1 = new Foo();f1.flag // undefined第二种，装饰属性装饰器会在 Object.defineProperty 之前执行，也就是拦截默认的访问修饰符。举个例子:12345678910111213// CSDN markdown 编辑器 为什么不支持 typescript 高亮？无语...function nameEqual3(object, key, descriptor: PropertyDescriptor) &#123; descriptor.value = 3; descriptor.writable = false;&#125;class Person &#123; @nameEqual3 name() &#123; &#125;&#125;const p = new Person();console.log(p.name); // 3可见其效果。也支持传参，如下代码所示，请仔细阅读注释：1234567891011121314151617181920212223242526272829303132333435363738// 装饰器函数 (用闭包来封装一下)function sign(id) &#123; return function (target, name, descriptor) &#123; /** * 这里的 value 在我看来，更像是一个 getter, 所以可以直接被赋值成一个函数 * 类似于： * descriptor = &#123; * get: function()&#123; return this.value &#125; * &#125; */ const oldValue = descriptor.value; /** * 这里的 args 实际上就是装饰器在运行时，挂载的函数的入参，下面的 log 日志会证明 */ descriptor.value = function (...args) &#123; console.log(`args =&gt;`, args); console.log(`标记 $&#123;id&#125;`); return oldValue.apply(this, args); &#125;; return descriptor; &#125;&#125;class Person &#123; @sign(1) method(a, b) &#123; return a + b; &#125;&#125;// 实例化和调用const p1 = new Person();p1.method(2, 4);// 输出： args =&gt; [3,4] 标记 1第三种，装饰器的高级用法（链式调用, combine 以及 mixin)1.链式（连续）首先来看链式（连续）调用，这次多加一个装饰器，并且继续通过打印的方式来查看下调用的顺序：1234567891011121314151617181920212223242526272829// 装饰器函数 再 封装一层function mark(id) &#123; // 真正的装饰器函数以闭包形式返回 return (obj, target, descriptor) =&gt; &#123; // 不破坏原 getter 函数 const old = descriptor.value; console.log(id); return descriptor.value = () =&gt; old.apply(this, id); &#125;&#125;class Person &#123; @mark(1) @mark(2) method() &#123; &#125;&#125;const p1 = new Person();p1.method();// 输出：2 1咦？明明 @mark(1) 在 @mark(2) 之前调用的啊，为什么 2 比 1 先执行了呢？让我们打开 如下地址，跟着我一起分析：Type Script - Play ground%20%7B%0D%0A%20%20%2F%2F%20%E7%9C%9F%E6%AD%A3%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%87%BD%E6%95%B0%E4%BB%A5%E9%97%AD%E5%8C%85%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%0D%0A%20%20return%20(obj%2C%20target%2C%20descriptor)%20%3D%3E%20%7B%0D%0A%20%20%20%20%2F%2F%20%E4%B8%8D%E7%A0%B4%E5%9D%8F%E5%8E%9F%20getter%20%E5%87%BD%E6%95%B0%0D%0A%20%20%20%20const%20old%20%3D%20descriptor.value%3B%0D%0A%20%20%20%20console.log(id)%3B%0D%0A%20%20%20%20return%20descriptor.value%20%3D%20()%20%3D%3E%20old.apply(this%2C%20id)%3B%0D%0A%20%20%7D%0D%0A%7D%0D%0A%0D%0A%0D%0A%0D%0Aclass%20Person%20%7B%0D%0A%0D%0A%20%20%40mark(1)%0D%0A%20%20%40mark(2)%0D%0A%20%20method()%20%7B%20%7D%0D%0A%7D%0D%0A%0D%0A%0D%0Aconst%20p1%20%3D%20new%20Person()%3B%0D%0A%0D%0Ap1.method()%3B%0D%0A%0D%0A%2F%2F%20%E8%BE%93%E5%87%BA%EF%BC%9A%0D%0A2%20%0D%0A1)来看右边编译后的 javascript 代码，只看 var decorator 被编译成了啥，下面的不用看，跟源码差不多。请仔细阅读注释1234567891011121314151617181920212223242526272829303132333435363738var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) &#123;// 判断函数真正的入参，如果小于 3 个，r = target 否则 继续判断 ，在该 对象 的属性（被装饰的属性）上原本的 descriptor 是不是 null ？ 如果是，则 desc 等于 当前对象被装饰属性的 descriptor ，否则 r = 当前对象被装饰属性的 descriptor// 这里的 d 用于缓存 下面遍历时 的 状态 var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; // 这里的 Reflect 是 window 下的 全局对象，我们也知道， Reflect 对象根本没有 decorate 方法，所以， turthy 的分支并不会执行，而是走 falsy 分支. if (typeof Reflect === "object" &amp;&amp; typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); /**********关键步骤************/ // 这里遍历的是入参的装饰器数组，并且，从右倒叙遍历（起始下标为 decorators.length - 1） // d 是每次遍历的 装饰器返回的 descriptor, 通过 判断入参个数，来决定 r 的类型，以及是否通过 d(r) 来装饰某个对象。如果 入参 &lt; 3 个，即 r 为 一个对象，执行 d(r) ； 否则如果 入参 &gt; 3 个，即运行时传入了第四个参数 desc(descriptor) ， 此时的 r 其实就是 desc ，d(target, key, r) 意思是：用 入参的 desc 装饰对象 target 的 key 属性；否则 c &lt; 4 ， 此时的 r 为 object 对象，d(target, key)； else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;&#125;;/*************************下面这些先不用看***********************/// 装饰器函数 再 封装一层function mark(id) &#123; var _this = this; // 真正的装饰器函数以闭包形式返回 return function (obj, target, descriptor) &#123; // 不破坏原 getter 函数 var old = descriptor.value; console.log(id); return descriptor.value = function () &#123; return old.apply(_this, id); &#125;; &#125;;&#125;var Person = /** @class */ (function () &#123; function Person() &#123; &#125; Person.prototype.method = function () &#123; &#125;; __decorate([ mark(1), mark(2) ], Person.prototype, "method", null); return Person;&#125;());var p1 = new Person();p1.method();上面啰里啰唆的注释是啥意思呢？翻译成人话： 装饰器的执行顺序是个 栈， 后进先出。像极了… 爱情？不，像极了 洋葱模型。2. combine (合并)合并指的是装饰器装饰某个类的属性的时候，同时应用多个装饰器的模式。（要跟下面的 @mixin）区分123456789101112131415161718192021222324252627282930313233343536373839function eatApple(count) &#123; return (obj,target,descriptor) =&gt; &#123; const old = descriptor.value; console.log(`吃了 $&#123;count&#125; 个 苹果`); return old.apply(this); &#125;&#125;function runMeter(long) &#123; return (obj,target,descriptor) =&gt; &#123; const old = descriptor.value; console.log(`跑了 $&#123;long&#125; 米`); return old.apply(this); &#125;&#125;function combine(...descriptors) &#123; // 想点办法，让入参的每个函数立马执行！要把自己得到的对象分配给两个小弟 return (obj, target, descriptor) =&gt; descriptors.forEach(d =&gt; d.apply(this, [obj, target, descriptor]));&#125;class Person &#123; @combine(eatApple(1), runMeter(9)) method() &#123; &#125;&#125;const p1 = new Person();p1.method();// 输出：吃了一个苹果跑了 9 米可见，在 @combine() 中传入的参数顺序，竟然跟最终的顺序 是一样的，咦？不是洋葱吗？这压根不是栈啊！脑子里回想一下刚才解析源码的过程，我再次望向了这次的源码：12345678var Person = /** @class */ (function () &#123; function Person() &#123; &#125; Person.prototype.method = function () &#123; &#125;; __decorate([ combine(eatApple(1), runMeter(9)) ], Person.prototype, "method", null); return Person;显而易见，这两个函数，直接是作为结果被传进去的，相当于栈里面只有 mixin 一个函数，无所谓是栈或者队列了，反正两个函数都在我内部执行，我让他怎么执行就怎么执行，为所欲为。所以这里的输出结果是同步的，完全就是因为栈里只有一个 member。不信验证一下：123456789101112131415161718192021222324252627282930313233343536373839404142function eatApple(count) &#123; return (obj,target,descriptor) =&gt; &#123; const old = descriptor.value; console.log(`吃了 $&#123;count&#125; 个 苹果`); return old.apply(this); &#125;&#125;function runMeter(long) &#123; return (obj,target,descriptor) =&gt; &#123; const old = descriptor.value; console.log(`跑了 $&#123;long&#125; 米`); return old.apply(this); &#125;&#125;function combine(...descriptors) &#123; // 想点办法，让入参的每个函数立马执行！要把自己得到的对象分配给两个小弟 return (obj, target, descriptor) =&gt; descriptors.forEach(d =&gt; d.apply(this, [obj, target, descriptor]));&#125;class Person &#123; @combine(eatApple(1), runMeter(9)) @combine(eatApple(5),runMeter(100)) method() &#123; &#125;&#125;const p1 = new Person();p1.method();// 输出：吃了 5 个 苹果跑了 100 米吃了 1 个 苹果跑了 9 米3. mixin (混合)mixin 意为在一个对象之中混入另外一个对象的方法。123456789101112131415function mixins(...list) &#123; return function (target) &#123; // Object.assign 可用于对象，即 编译后的 es3 runtime 指向 class.prototype Object.assign(target.prototype, ...list); &#125;;&#125;const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // "foo"😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>decorator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-sql]]></title>
    <url>%2F2019%2F06%2F11%2Fhello-sql%2F</url>
    <content type="text"><![CDATA[本文章原始创作地址：https://blog.csdn.net/qq_20264891/article/details/91437256如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信前置条件廖雪峰 sql 教程alasql github新建一个项目 $ npm i alasql一、基本语法根据示例 https://github.com/agershun/alasql 学习基本语法1.建表( CREATE TABLE)123alasql(`CREATE TABLE users (age number, name string, money number);`);2. 插入数据(INSERT INTO {table})123alasql(`INSERT INTO users VALUES (25,'张三', 100);`):然后确认一下数据是否真的写入了1234567const mysql = alasql('SELECT *FROM users;');console.log(mysql); // [ &#123; age: 25, name: '张三', money: 100 &#125; ]于是写个遍历，插入更多数据，以供后面操作。123456789101112131415161718...for(let i = 0; i&lt; 100; i++) &#123; const sql = `INSERT INTO users VALUES ($&#123;i&#125;, '张$&#123;i&#125;', $&#123;i&#125;)`; alasql(sql);&#125;const mysql = alasql('SELECT * FROM users;');console.log(mysql);// 输出：[ &#123; age: 25, name: '张三', money: 100 &#125;, &#123; age: 0, name: '张0', money: 0 &#125;, &#123; age: 1, name: '张1', money: 1 &#125;, &#123; age: 2, name: '张2', money: 2 &#125;, &#123; age: 3, name: '张3', money: 3 &#125;, &#123; age: 4, name: '张4', money: 4 &#125;,// ... &#123; age: 99, name: '张99', money: 99 &#125;,3. SELECT 语句望文生义， SELECT 就是选中，命中。选中的对象是啥呢？其实就是表的 “列” column。举例：12345678// 选中 users 表中所有的列SELECT * FROM users;// 只选中 name 这一列SELECT name FROM users;// 选中 name, age 两列 SELECT name,age FROM users;如果希望返回的结果集可以自定义列名（column） ，这种操作称之为 “投影”， 可以使用语法 :1SELECT 列1 别名1, 列2 别名2 FROM users;举个 🌰:12345678910111213141516// 原 column 名为 name...[name]张三李四王麻子...SELECT name '姓名' FROM users;// 输出...[姓名]张三李四王麻子...4. WHERE 语句现在，从表中筛选出 age &gt; 90 的：12345678910111213...const mysql = alasql(`SELECT * FROM users WHERE age&gt;90;`);console.log(mysql);// 输出：[ &#123; age: 91, name: '张91', money: 91 &#125;, &#123; age: 92, name: '张92', money: 92 &#125;, &#123; age: 93, name: '张93', money: 93 &#125;, &#123; age: 94, name: '张94', money: 94 &#125;, &#123; age: 95, name: '张95', money: 95 &#125;, &#123; age: 96, name: '张96', money: 96 &#125;, &#123; age: 97, name: '张97', money: 97 &#125;, &#123; age: 98, name: '张98', money: 98 &#125;, &#123; age: 99, name: '张99', money: 99 &#125; ]5. 联合条件联合条件，即多条件叠加。是为了提高命中数据的准确度，达到准确查找想要数据的目的。AND12345...const mysql = alasql(`SELECT * FROM users WHERE age=60 AND money=60;`);console.log(mysql);// 输出：[ &#123; age: 60, name: '张60', money: 60 &#125; ]OR12345678...const mysql = alasql(`SELECT * FROM users WHERE age=60 OR money=61;`);console.log(mysql);// 输出： [ &#123; age: 60, name: '张60', money: 60 &#125;, &#123; age: 61, name: '张61', money: 61 &#125; ]NOT查询 !(age&gt;=10)1234567891011121314...const mysql = alasql(`SELECT * FROM users WHERE NOT age&gt;=10;`);console.log(mysql);// 输出：[ &#123; age: 0, name: '张0', money: 0 &#125;, &#123; age: 1, name: '张1', money: 1 &#125;, &#123; age: 2, name: '张2', money: 2 &#125;, &#123; age: 3, name: '张3', money: 3 &#125;, &#123; age: 4, name: '张4', money: 4 &#125;, &#123; age: 5, name: '张5', money: 5 &#125;, &#123; age: 6, name: '张6', money: 6 &#125;, &#123; age: 7, name: '张7', money: 7 &#125;, &#123; age: 8, name: '张8', money: 8 &#125;, &#123; age: 9, name: '张9', money: 9 &#125; ]另一种，不等于的写法：123456789101112131415// 又要大，又要小。又想马儿跑，又不想给马吃草const mysql = alasql(`SELECT * FROM users WHERE age&lt;&gt;20;`);console.log(mysql);// 输出： ... [ &#123;age: 0, name: '张0'&#125;, ... &#123; age: 18, name: '张18', money: 18 &#125;, &#123; age: 19, name: '张19', money: 19 &#125;, // 注意，这里 age=20 的数据被 where 语句命中了，因此没有出现在结果集 &#123; age: 21, name: '张21', money: 21 &#125;, ... &#123; age: 99, name: '张99', money: 99 &#125; ]6.模糊查询({field} LIKE)123456789101112131415// 查询名字中以 `张7` 开头的数据，% 代表任意字符。const mysql = alasql(`SELECT * FROM users WHERE name LIKE '张7%';`);console.log(mysql);// 输出：[ &#123; age: 7, name: '张7', money: 7 &#125;, &#123; age: 70, name: '张70', money: 70 &#125;, &#123; age: 71, name: '张71', money: 71 &#125;, &#123; age: 72, name: '张72', money: 72 &#125;, &#123; age: 73, name: '张73', money: 73 &#125;, &#123; age: 74, name: '张74', money: 74 &#125;, &#123; age: 75, name: '张75', money: 75 &#125;, &#123; age: 76, name: '张76', money: 76 &#125;, &#123; age: 77, name: '张77', money: 77 &#125;, &#123; age: 78, name: '张78', money: 78 &#125;, &#123; age: 79, name: '张79', money: 79 &#125; ]7. 排序方式(ORDER BY {field} DESC/ASC)细心的你肯定发现了，前面的数据都是按照顺序（ASC 从小到大）来排序的，那如果我希望 age 或者 money 字段按照倒序（DESC 从大到小）来排布，该怎么操作呢？1234567891011...const mysql = alasql(`SELECT name '姓名' FROM users ORDER BY age DESC;`);console.log(mysql);// 输出:[ &#123; '\'姓名\'': '张99' &#125;, &#123; '\'姓名\'': '张98' &#125;, &#123; '\'姓名\'': '张97' &#125;, &#123; '\'姓名\'': '张96' &#125;, &#123; '\'姓名\'': '张95' &#125;, ... ];这里我按照 age 的 DESC 来排序，结果符合预期。8.分页查询( LIMIT, OFFSET)之前做后台管理的时候，我还纳闷，为什么接口总是定义 offset=0;limit=10;orderBy=’name’ 这样的接口，现在看到这里，应该都豁然开朗了。在上述的例子里，每次返回的结果集都太大，然而这个表只有 100 条数据而已，随着表的规模越来越大，分页查询势在必行。123456789101112131415...// 返回的结果集极限大小为 10 条数据，且从 index=0 的位置向后偏移 4 个const mysql = alasql(`SELECT name FROM users LIMIT 10 OFFSET 4;`);console.log(mysql);// 输出[ &#123; name: '张4' &#125;, &#123; name: '张5' &#125;, &#123; name: '张6' &#125;, &#123; name: '张7' &#125;, &#123; name: '张8' &#125;, &#123; name: '张9' &#125;, &#123; name: '张10' &#125;, &#123; name: '张11' &#125;, &#123; name: '张12' &#125;, &#123; name: '张13' &#125; ]假表中设有无穷多的数据，需要查询第 N 页的数据，默认 LIMIT = 10，问 OFFSET = ？1OFFSET = LIMIT(N-1);偏移量总是等于 = （要查询的页数 - 1）* limit9.聚合查询（SELECT COUNT(*) FROM {table}）123const mysql = alasql(`SELECT COUNT(*) FROM users;`);console.log(mysql);// 输出 ['COUNT(*)': 100]同样可以取别名123const mysql = alasql(`SELECT COUNT(*) total FROM users;`);console.log(mysql);// 输出： [ &#123; total: 100 &#125; ]另外，除了 COUNT 还有几个内置函数：MAX, MIN, AVG, SUM,FLOOR,CELING 等对应最大，最小，平均，总和。123456const mysql = alasql(`SELECT MAX(money) max FROM users;`);console.log(mysql);// 输出 [ &#123; max: 99 &#125; ]const mysql = alasql(`SELECT SUM(money) totalMoney FROM users;`);console.log(mysql);// [ &#123; totalMoney: 4950 &#125; ]10.分组查询（SELECT FROM {table} GROUP BY {field};）123456789101112131415161718192021const alasql = require('alasql');alasql(`CREATE TABLE users (age number, name string, money number)`);for (let i = 0; i &lt; 10; i++) &#123; // build random number as 1~10 const number = Math.ceil(Math.random() * 10); const sql = `INSERT INTO users VALUES ($&#123;i&#125;, '张$&#123;i&#125;', $&#123;number&#125;)`; alasql(sql);&#125;const mysql = alasql(`SELECT * FROM users GROUP BY money ;`);console.log(mysql);// 输出：[ &#123; money: 9 &#125;, &#123; money: 8 &#125;, &#123; money: 4 &#125;, &#123; money: 3 &#125;, &#123; money: 2 &#125;, &#123; money: 7 &#125;, &#123; money: 1 &#125;, &#123; money: 10 &#125; ]11. 连接查询(INNER JOIN … ON…)顾名思义，即多个表连接到一起，统一查询。现在，假设每个 user 需要添加一个 company 字段，代表所处公司。而这个 company 是随时会变动的，因此需要建立一个新表进行单独的维护：123alasql(`CREATE TABLE companies (id numnber, name string);`);companies 表很简单，只有一个字段。如果现在每个 user 的字段都要对应到 companies 的一个成员，即 users 长度 = companies 长度，该如何做映射呢？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const alasql = require('alasql');// 创建两个表，user 表中， company 为数字，对应着 companies 表中的索引 idalasql(`CREATE TABLE users (age number, name string, money number, company number)`);alasql(`CREATE TABLE companies (id number, name string)`);for (let i = 0; i &lt; 10; i++) &#123; // build random number as 1~10 const number = Math.ceil(Math.random() * 10); const sql = `INSERT INTO users VALUES ($&#123;i&#125;, '张$&#123;i&#125;', $&#123;number&#125;, $&#123;number&#125;)`; alasql(sql); // 这里每个 company 的 id 应该与 user 表中的 company 字段 依次 相同 alasql(`INSERT INTO companies VALUES ($&#123;number&#125;, '公司' + $&#123;number&#125;)`);&#125;// 查询时，多加一个 companies 表中的 name 列const mysql = alasql(` SELECT u.age, u.name, u.money, c.name company_name FROM users u INNER JOIN companies c ON u.company=c.id`);console.log(mysql);// 输出：[ &#123; age: 0, name: '张0', money: 1, company_name: '公司1' &#125;, &#123; age: 1, name: '张1', money: 2, company_name: '公司2' &#125;, &#123; age: 1, name: '张1', money: 2, company_name: '公司2' &#125;, &#123; age: 1, name: '张1', money: 2, company_name: '公司2' &#125;, &#123; age: 1, name: '张1', money: 2, company_name: '公司2' &#125;, &#123; age: 2, name: '张2', money: 7, company_name: '公司7' &#125;, &#123; age: 2, name: '张2', money: 7, company_name: '公司7' &#125;, &#123; age: 3, name: '张3', money: 4, company_name: '公司4' &#125;, &#123; age: 3, name: '张3', money: 4, company_name: '公司4' &#125;, &#123; age: 3, name: '张3', money: 4, company_name: '公司4' &#125;, &#123; age: 4, name: '张4', money: 7, company_name: '公司7' &#125;, &#123; age: 4, name: '张4', money: 7, company_name: '公司7' &#125;, &#123; age: 5, name: '张5', money: 2, company_name: '公司2' &#125;, &#123; age: 5, name: '张5', money: 2, company_name: '公司2' &#125;, &#123; age: 5, name: '张5', money: 2, company_name: '公司2' &#125;, &#123; age: 5, name: '张5', money: 2, company_name: '公司2' &#125;, &#123; age: 6, name: '张6', money: 4, company_name: '公司4' &#125;, &#123; age: 6, name: '张6', money: 4, company_name: '公司4' &#125;, &#123; age: 6, name: '张6', money: 4, company_name: '公司4' &#125;, &#123; age: 7, name: '张7', money: 4, company_name: '公司4' &#125;, &#123; age: 7, name: '张7', money: 4, company_name: '公司4' &#125;, &#123; age: 7, name: '张7', money: 4, company_name: '公司4' &#125;, &#123; age: 8, name: '张8', money: 2, company_name: '公司2' &#125;, &#123; age: 8, name: '张8', money: 2, company_name: '公司2' &#125;, &#123; age: 8, name: '张8', money: 2, company_name: '公司2' &#125;, &#123; age: 8, name: '张8', money: 2, company_name: '公司2' &#125;, &#123; age: 9, name: '张9', money: 2, company_name: '公司2' &#125;, &#123; age: 9, name: '张9', money: 2, company_name: '公司2' &#125;, &#123; age: 9, name: '张9', money: 2, company_name: '公司2' &#125;, &#123; age: 9, name: '张9', money: 2, company_name: '公司2' &#125; ]总结一下，这种多表联合查询，就是在 SELECT 阶段选择两个表中的字段，然后通过 INNER JOIN {表名} ON {条件} 来完成的。另外还有 LEFT OUTER JOIN ， RIGHT OUTER JOIN 等，详见廖雪峰大神总结的图示：二、CRUD BOY 的基本素养1. 增语法：1INSERT INTO table (field) VALUES (value1, value2...);12345678910111213141516171819202122232425const alasql = require('alasql');// 建表时可以注明类型alasql(`CREATE TABLE users (age number, name string, money number)`);for(let i = 0; i&lt; 10; i++) &#123; const sql = `INSERT INTO users VALUES ($&#123;i&#125;, '张$&#123;i&#125;', $&#123;i&#125;)`; alasql(sql);&#125;// 插入时不需要标注 field typealasql(`INSERT INTO users (age, name, money) VALUES (1 , '大牛' , 100)`);const mysql = alasql(`SELECT * FROM users;`);console.log(mysql);// 输出：[ &#123; age: 0, name: '张0', money: 0 &#125;, &#123; age: 1, name: '张1', money: 1 &#125;, &#123; age: 2, name: '张2', money: 2 &#125;, &#123; age: 3, name: '张3', money: 3 &#125;, &#123; age: 4, name: '张4', money: 4 &#125;, &#123; age: 5, name: '张5', money: 5 &#125;, &#123; age: 6, name: '张6', money: 6 &#125;, &#123; age: 7, name: '张7', money: 7 &#125;, &#123; age: 8, name: '张8', money: 8 &#125;, &#123; age: 9, name: '张9', money: 9 &#125;, &#123; age: 1, name: '大牛', money: 100 &#125; ]2. 改语法：1UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;12345678910111213141516...// 更新 age=1 的这条数据alasql(`UPDATE users SET age=100000, money=200000 WHERE age=1`);const mysql = alasql(`SELECT * FROM users;`);console.log(mysql);// 输出：[ &#123; age: 0, name: '张0', money: 0 &#125;, &#123; age: 100000, name: '张1', money: 200000 &#125;, &#123; age: 2, name: '张2', money: 2 &#125;, &#123; age: 3, name: '张3', money: 3 &#125;, &#123; age: 4, name: '张4', money: 4 &#125;, &#123; age: 5, name: '张5', money: 5 &#125;, &#123; age: 6, name: '张6', money: 6 &#125;, &#123; age: 7, name: '张7', money: 7 &#125;, &#123; age: 8, name: '张8', money: 8 &#125;, &#123; age: 9, name: '张9', money: 9 &#125; ]3. DELETE语法：1DELETE FROM &lt;表名&gt; WHERE ...;12345678910alasql(`DELETE FROM users WHERE age&gt;5`);const mysql = alasql(`SELECT * FROM users;`);console.log(mysql);// 输出：[ &#123; age: 0, name: '张0', money: 0 &#125;, &#123; age: 1, name: '张1', money: 1 &#125;, &#123; age: 2, name: '张2', money: 2 &#125;, &#123; age: 3, name: '张3', money: 3 &#125;, &#123; age: 4, name: '张4', money: 4 &#125;, &#123; age: 5, name: '张5', money: 5 &#125; ]4. Retrieve语法：1SELECT colume FROM table （WHERE） ...😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http 发展进程 与 编码方式的发展 进程]]></title>
    <url>%2F2019%2F06%2F01%2Fhttp-history%2F</url>
    <content type="text"><![CDATA[本文章原始创作地址：https://blog.csdn.net/qq_20264891/article/details/90734157如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信广义上我们口中的 http我们口中常说的 http 应该是指 http 1.1http0.9中，每次通信完成后，都会断开tcp连接，造成资源浪费。http1.0可以在header中加入keep alive来确保长连接，但还是有点麻烦。于是，http1.1 默认可以 keep alive，并且引入管道机制(pipeline)，客户端可以发送多个请求，但是服务端按照顺序来一一回复。这也是HTTP1.1的设计缺点，多个请求过来时，队列容易被大型缓慢得请求堵塞，尽管前端可以优化请求数量，例如雪碧图，合并脚本和样式表等。后来，谷歌开发出一种新的通信协议，并在Chrome试水成功，名为：spdy(撕破腚眼)，后来大多数 feature 都在 http2 中得到继承，例如 head 头中的元数据信息不再限制为仅支持 ASCII 编码的字符集，并且还支持二进制编码，以便于将来高级应用的解析。并且，每次通信的过程中，不会再有队列堵塞的情况发生，一个请求太大，执行多少就先返回多少，在执行下一个任务，等下一个执行完，接着处理上一个。另外，可以中途取消某个通信帧，还可以给每个请求标注 level 让服务器按照 level优先级处理。还有服务器和客户端都会维护一张表，将重复的头部元数据都塞到表里，每次通信，发送表的索引，提升通信效率。除此以外，服务端可以强推送，例如，客户端请求某个 html，服务器可以显而易见的知道里面有很多图片及脚本文件，不用浏览器请求，就会自动推送给浏览器。前面也说到字符集的编码标准。下面来捋一下:计算机开始普及时，为了让大多数的信息都可以被计算机识别，人们建立了一套 “阿拉伯数字 + 英语 + 常用符号” 的编码标准来映射对应的字符，从而让计算机更好的识别，处理这些字符。这个字符集定义了 从 a-z A-z 0-9 , . ? / [ ] 等常用的字符。该标准成为： ASCII 编码。后来，使用计算机的人越来越多，比如中国，但是 ASCII 码没有定义中文字符，于是，中国有了一套 gb2312 字符编码标准，同理，大多数国家都应该有一套自己的文字编码标准，后来被统一为 unicode 编码。 unicode 编码定义了绝大多数的文字、符号等。utf-8, utf-16 的诞生，是为了提升编码的效率，避免浪费位存。😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa-2]]></title>
    <url>%2F2019%2F05%2F16%2Fkoa-2%2F</url>
    <content type="text"><![CDATA[本文章原始创作地址：https://blog.csdn.net/qq_20264891/article/details/90274428如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信MVC 分层代码地址： https://github.com/ZQ-jhon/koa-starterMVC 是个老生常谈的概念了。M = Model， V = View , C = Controller ， angularjs 就是典型的 MVC 框架。在 Angular （指Angular 2+， 下同） 中，C 被拆分成 ViewModel ，因此称之为 MVVM 框架：M = model 数据，驱动渲染的能源V = View 视图层，指代用户可以看到的前端界面ViewModel = 处理数据和视图之间的关系那么，在 KOA 中， MVC 指代的又是什么呢?C，Controller 层先不急着回答，把上一次的代码捋一捋，进一步优化一下。由于之前所有的对于请求参数和数据的处理都放在 APP.js ，随着需求的增加，导致难以维护，先让我们给代码分层：123456789101112131415161718192021222324252627282930 /** app.js 中新增 `router.js`，专门用来处理路由相关的东西 * router.js * */const router = require('koa-router')();module.exports = (app) =&gt; &#123; app.use(async (ctx, next) =&gt; &#123; ctx.body = ` &lt;form action="/submit" method="post"&gt; &lt;input name="account" type="text"&gt; 账号 &lt;br/&gt; &lt;input name="password" type="password"&gt; 密码 &lt;br/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; `; await next(); &#125;); app.use(async (ctx, next) =&gt; &#123; if (ctx.request.url === '/submit') &#123; ctx.response.type = 'application/json'; ctx.response.body = ctx.request.body; &#125; await next(); &#125;); // add router middleware: app.use(router.routes())&#125;&#125;整个 router 也被编写并导出为一个函数，接受 koa 的实例 app，来进行中间件的使用。还不够完美，router 中仍然存在大量的与路由无关的代码，我们进一步分层:12345678910111213141516171819202122232425262728/*** 新建 index.controller.js* index.controller.js 的职责就是：一旦收到命令，就渲染并返回表单页面*/module.exports = async (ctx, next) =&gt; &#123; ctx.response.type = 'text/html'; ctx.body = ` &lt;form action="/submit" method="post"&gt; &lt;input name="account" type="text"&gt; 账号 &lt;br/&gt; &lt;input name="password" type="password"&gt; 密码 &lt;br/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; `; await next();&#125;/*** 同理，新建 post.controller.js* post.controller.js 的职责是：收到命令，就解析 body 中传来的数据，并渲染返回给前端*/module.exports = async (ctx, next) =&gt; &#123; ctx.response.type = 'application/json'; ctx.response.body = ctx.request.body;&#125;现在的文件结构应该如下：123456|--node_modules|--package.json|--app.js|--index.controller.js|--post.controller.js|--router.controller.js（如果读者嫌乱，可以增加 controllers 文件夹 和 routers 文件夹，将对应后缀的文件丢到对应的目录，并更新文件的引用路径。）我们现在更新目录：12345678|--node_modules|--package.json|--app.js|--contollers |--index.controller.js |--post.controller.js|--routers |--routers.controller.jsVSCODE 提示更新引用，NICE。通过上面的代码可以看到，两个新建的 controller 文件，都是在处理自己的业务职责，即渲染并返回对应的数据，他们不关心路由是不是命中了自己，做到了职责单一。我们现在在 CMD 中输入 node app.js 发现程序还是按照预期来执行，这里就不贴图了。现在，按照 MVC 框架的思想来理解，业务处理的部分就是 C =&gt; controller ，我们已经完成了。下面来看 View 层是啥？假设我们现在有 100 个不同的路由来处理请求，并且每个路由要返回不同的页面，我们肯定不希望手写 100 个 html ，代码量太大了。为了解放生产力，我们不得不使用模板引擎，例如 ejs , jade，nunjucks 等等，由于 nunjucks 是 mozilla 开发的，就用它吧！（官方文档支持中文：官方文档）123456// 安装 及 使用// 随便在哪新建一个 js 文件const nunjucks = require(&apos;nunjucks&apos;);const result = nunjucks.renderString(`hello, $&#123;name&#125;`, &#123;name: 123&#125;);// fuck, 这里 双花括号跟 hexo 模板语法冲突了，意思大家明白就行console.log(result);// 通过 node.js 执行如果你写过 Angular，Nunjucks 的东西简直是跟 Angular 的模板语法一毛一样支持管道，双花括号取值 ,逻辑判断，循环，继承，还有：防止 XSS 攻击，支持可配置的转义 消毒(sanitizer)123const nunjucks = require('nunjucks');nunjucks.configure('./', &#123;autoescape: true&#125;);// 默认对当前文件夹下的文件进行转义过滤，消毒处理脏活都被 nunjucks 干完了。使用 nunjucks下面，我们将 默认 路由下，返回 post 页面的代码，用 nunjucks 来进行重构在 controller 层同级下，新建 views 目录，然后新建 from.html 模板文件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;form&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--注意，这里使用了 name 变量，看看待会怎么使用它！ // fuck, 这里 双花括号跟 hexo 模板语法冲突了，意思大家明白就行 --&gt; &lt;h1&gt;&#123;fuck&#123; name &#125;fuck&#125;&lt;/h1&gt; &lt;form action="/submit" method="post"&gt; &lt;input name="account" type="text"&gt; 账号 &lt;br/&gt; &lt;input name="password" type="password"&gt; 密码 &lt;br/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;接着在 renderers 下新建 renderForm.js1234const nunjucks = require('nunjucks');nunjucks.configure('views', &#123; autoescape: true &#125;);const htmlRenderFn = (object) =&gt; nunjucks.render(`form.html`, object);module.exports = htmlRenderFn;接着，修改原本在 index.controller.js 中渲染的函数123456const renderForm = require('../views/renderForm');module.exports = async (ctx, next) =&gt; &#123; ctx.response.type = 'text/html'; ctx.body = renderForm(&#123;name: 'Hello, nunjucks'&#125;); await next();&#125;回到第二个标题抛出的问题，我的理解是，KOA 中的 MVC ：M = 泛指整个通信过程中所有的数据，包括但不限于 http 请求中传递的数据或者路由参数、query 参数、post body 体，甚至 view 层 中 nunjucks 渲染的数据来源。V = view，返回给前端的视图C = controller 控制器未完待续…😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa-1]]></title>
    <url>%2F2019%2F05%2F14%2Fkoa-1%2F</url>
    <content type="text"><![CDATA[本文章原始创作地址：https://blog.csdn.net/qq_20264891/article/details/90216585如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信为什么要学 Koa，不学 Express ？因为不想写回调，日常开发习惯 async await 处理异步流程，因此选择 Koa 2。(以下简称 Koa)Koa2 核心概念洋葱模型 其实就是 async await 执行流程，在 koa 每次调用中间件时，回调函数中 next 会吧执行权递交给下一个回调函数。按笔者通俗的解释为：洋葱先从外侧切到内侧，再从内测切到另一边的外侧。其实也就是回调函数被 async await 化了而已。ctx(context) 上下文，request, response 都被合并封装到 ctx 中，方便每个中间件进行操作，调用。打印一下 ctx，可见，ctx 描述的是，每个完整的 http 所包含的信息，包括但不限于 请求方法(method)，url(request url)，响应码(status), 响应信息 message, header 等。路由 路由的处理也是包含在中间件中的。路由的概念并不陌生，Angular 中除了基本的 Router 路由器让你处理跳转路由之外，还有 Activeted 路由，来处理不同的 Url 和接受 query 等。 在我看来，这里 Koa 的路由，其实跟 Angular Activeted 的概念很像。代码：1234567891011121314151617// 根路由app.use(async (ctx, next) =&gt; &#123; if (ctx.request.path === "/") &#123; ctx.response.body = "&lt;h1&gt;index Router&lt;/h1&gt;"; &#125; else &#123; await next(); &#125;&#125;);// todo 路由app.use(async (ctx, next) =&gt; &#123; if (ctx.request.path === "/todo") &#123; ctx.response.body = "&lt;h1&gt;Todo Router&lt;/h1&gt;"; &#125; else &#123; await next(); &#125;&#125;);完事。 Demo:但官方已经有更好的中间件了：koa-router123456789101112131415const Koa = require("koa");const app = new Koa();const router = require("koa-router")();// 根路由router.get("/", async (ctx, next) =&gt; &#123; ctx.response.body = "&lt;h1&gt;index Router&lt;/h1&gt;";&#125;);// todo 路由router.get("/todo", async (ctx, next) =&gt; &#123; ctx.response.body = "&lt;h1&gt;Todo Router&lt;/h1&gt;";&#125;);app.use(router.routes());具名路由：12345// 给路由起个名字，便于复用router.get("user", "users/:id", async (ctx, next) =&gt; &#123; ctx.response.body = `你要访问的是 ： $&#123;ctx.response.path&#125;`;&#125;);query param 以及 param 对象123456789101112// paramsrouter.get('/home/:id', async (ctx,next) =&gt; &#123;ctx.response.type = 'application/json';ctx.response.body = ctx.params;&#125;);// query-paramsrouter.get('/home' async (ctx, next) =&gt; &#123;ctx.response.type = 'application/json';ctx.response.body = `$&#123;ctx.request.query&#125;`;&#125;);params:-object:query-params:拿 Angular 中的路由做一下类比：12345// 形如 /home/:idthis.activitedRoute.paramMap.subscribe(param =&gt; console.log(param)); // &#123;"id": "4"&#125;// 形如 /home?a=1&amp;b=2this.route.queryParamMap.subscribe(res =&gt; console.log(res)); // map&lt;string,number&gt; = new Map(&#123;a: 1, b:2&#125;);都是根据浏览器的 urlParamsMap 来实现的。body-parser上述的所有请求， 都是基于 GET 请求的，那么如果客户端发来 post 请求，怎么解析 send 过来的数据呢？通过路由吗？做不到啊！所以还是得借助 ctx 上挂着的的对象来进行解析，因为 post 请求接受 form Data 也是异步的，所以要给 ctx.request 绑定监听：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const Koa = require("koa");const router = require("koa-router")();const app = new Koa();// 通用路由，直接给出 form 表单，诱导进一步的 post 操作app.use(async (ctx, next) =&gt; &#123; ctx.body = ` &lt;form action="/submit" method="post"&gt; &lt;input name="account" type="text"&gt; 账号 &lt;br/&gt; &lt;input name="password" type="password"&gt; 密码 &lt;br/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; `; await next();&#125;);// 进行 post 操作时的 middlewareapp.use(async (ctx, next) =&gt; &#123; if (ctx.request.url === "/submit") &#123; // ctx.response.type = 'application/json'; const data = await parseData(ctx); ctx.response.body = data; &#125; await next();&#125;);// 接收上下文，通过 事件监听 和 promise 来达到解析数据的目的function parseData(ctx) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let str = ""; ctx.req.on("data", data =&gt; &#123; str += data; &#125;); ctx.req.addListener("end", () =&gt; &#123; resolve(str); &#125;); &#125; catch (err) &#123; reject(err); &#125; &#125;);&#125;// add router middleware:app.use(router.routes());app.listen(3000, () =&gt; &#123; console.log("server is running at http://localhost:3000");&#125;);Demo: But， 不用这么麻烦，有对应的轮子了: koa-bodyparser 该中间件，会将 post 的数据，全部解析进 ctx.request.body 中核心代码：12345678910111213141516171819202122232425const bodyparser = require("koa-bodyparser");// 直接使用中间件app.use(bodyparser());app.use(async (ctx, next) =&gt; &#123; ctx.body = ` &lt;form action="/submit" method="post"&gt; &lt;input name="account" type="text"&gt; 账号 &lt;br/&gt; &lt;input name="password" type="password"&gt; 密码 &lt;br/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; `; await next();&#125;);app.use(async (ctx, next) =&gt; &#123; if (ctx.request.url === "/submit") &#123; // ctx.response.type = 'application/json'; ctx.response.body = ctx.request.body; &#125; await next();&#125;);来试试效果吧！搞定了。😘 觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公告]]></title>
    <url>%2F2019%2F04%2F11%2FNotice%2F</url>
    <content type="text"><![CDATA[如您有其他建议，可以通过左上角的 QQ 发起回话，或者在 https://zq-jhon.github.io/about/ 中添加我的微信notice今天打开 learnClound 发现，我的博客其实还是有人看的，还有人反映很多图片挂掉：comment之前的图片都是在 CSDN 上写完以后，直接 Copy 过来的， CSDN 不允许外链，因此挂了。于是直接上了 hexo 的文章图片同步构建功能，直接使用文件名，就可以引用图片了，我只能说，GIHUB，等着扩容吧，哈哈，真香！😘觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>notice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeCodeCamp JavaScript 基础算法练习]]></title>
    <url>%2F2019%2F04%2F06%2FFreeCodeCamp%20JavaScript%20%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[起由最近由于 996.icu 事件，才知道 GitHub 排行前十的 repo 中有这样一个项目。于是就刷起来了题 &amp; 解1. 找出最长单词 在句子中找出最长的单词，并返回它的长度。函数的返回值应该是一个数字。1234567// 测试用例 (test case): findLongestWord("The quick brown fox jumped over the lazy dog") 应该返回一个数字findLongestWord("The quick brown fox jumped over the lazy dog") 应该返回 6.findLongestWord("May the force be with you") 应该返回 5.findLongestWord("Google do a barrel roll") 应该返回 6.findLongestWord("What is the average airspeed velocity of an unladen swallow") 应该返回 8.findLongestWord("What if we try a super-long word such as otorhinolaryngology") 应该返回 19.解答：12345function findLongestWord(str) &#123; // 直接根据空格分割, 映射成 word 的长度，再使用 Math API 选出最大的 const arr = str.split(' ').map(word =&gt; word.length); return Math.max(...arr);&#125;2. 句中单词首字母大写 确保字符串的每个单词首字母都大写，其余部分小写。像’the’和’of’这样的连接符同理。12345// 测试用例 (test case): titleCase("I'm a little tea pot") 应该返回一个字符串titleCase("I'm a little tea pot") 应该返回 "I'm A Little Tea Pot".titleCase("sHoRt AnD sToUt") 应该返回 "Short And Stout".titleCase("HERE IS MY HANDLE HERE IS MY SPOUT") 应该返回 "Here Is My Handle Here Is My Spout".解答：1234function titleCase(str) &#123; // 字符串处理的步骤和顺序至关重要 return str.toLowerCase().split(' ').map(word =&gt; word.replace(word[0], word[0].toUpperCase())).join(' ');&#125;3. 找出多个数组中的最大数 右边大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。1234// 测试用例 (test case): largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]) 应该返回一个数组largestOfFour([[13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1]]) 应该返回 [27,5,39,1001].largestOfFour([[4, 9, 1, 3], [13, 35, 18, 26], [32, 35, 97, 39], [1000000, 1001, 857, 1]]) 应该返回 [9, 35, 97, 1000000].解答：12345function largestOfFour(arr) &#123; const result = []; arr.forEach(child =&gt; result.push(Math.max.call(...child))); return result;&#125;你以为对了吗？？？？呵呵12345678910111213141516171819202122232425262728293031323334353637383940// 举个例子const array= [1000000,1001];Math.max.call(...array);// output is 1001所以，解答的结果中为： [9, 35, 97, 1001]，与预期 [9, 35, 97, 1000000] 不符// WTF! WHY?// 因为，在调用 `Math.max.call() ` 时，第一个参数传递 This 指针，实际上传入的却是一个数字，因此，该函数的运行时应该是这样的Math.max.call(null, 1001) 等价于 Math.max(1001) // 实际上，参数只进去一个，自己跟自己没啥好比的。因此，当数组只有两个参数时，实际的输出结果完全取决于第二个参数是啥。// 正确解法一：function largestOfFour(arr) &#123; const result = []; arr.forEach(child =&gt; result.push(Math.max(...child))); return result;&#125;// 正确解法二function largestOfFour(arr) &#123; const result = []; arr.forEach(child =&gt; &#123; if(child.length &gt; 1) &#123; result.push(Math.max(...child)) &#125; if(child.length === 1) &#123; result.push(child); &#125; if(result.length === 0) &#123; // 入参的时候应该不会传空数组，但还是防一手 return ; &#125;&#125;); return result;&#125;4. 检查字符串结尾 判断一个字符串(str)是否以指定的字符串(target)结尾。 如果是，返回true;如果不是，返回false。12345678// 测试用例 (test case): confirmEnding("Bastian", "n") 应该返回 true.confirmEnding("Connor", "n") 应该返回 false.confirmEnding("Walking on water and developing software from a specification are easy if both are frozen", "specification") 应该返回 false.confirmEnding("He has to give me a new name", "name") 应该返回 true.confirmEnding("He has to give me a new name", "me") 应该返回 true.confirmEnding("He has to give me a new name", "na") 应该返回 false.confirmEnding("If you want to save our world, you must hurry. We dont know how much longer we can withstand the nothing", "mountain") 应该返回 false.解答：12345678function confirmEnding(str, target) &#123; if(target.length === 1) &#123; return str[str.length-1] === target; &#125; // 分割母字符串 const arr = str.split(' '); return (arr[arr.length-1].indexOf(target) &gt; 0) || arr[arr.length-1] === target;&#125;5. 重复输出字符串 （重要的事情说3遍）重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。1234567// 测试用例 (test case): repeat("*", 3) 应该返回 "***".repeat("abc", 3) 应该返回 "abcabcabc".repeat("abc", 4) 应该返回 "abcabcabcabc".repeat("abc", 1) 应该返回 "abc".repeat("*", 8) 应该返回 "********".repeat("abc", -2) 应该返回 "".解答：1234567891011121314151617// ES6function repeat(str, num) &#123; // 请把你的代码写在这里 return num &gt; 0 ? str.repeat(num) : '';&#125;// ES5function repeat(str, num) &#123; if(num &gt; 0) &#123; let result = ''; for(var i = 0;i&lt; num;i++) &#123; result += str; &#125; return result; &#125; else &#123;return ''&#125;&#125;6. 截断字符串 （用瑞兹来截断对面的退路） 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。 切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。1234567// 测试用例 (test case): truncate("A-tisket a-tasket A green and yellow basket", 11) 应该返回 "A-tisket...".truncate("Peter Piper picked a peck of pickled peppers", 14) 应该返回 "Peter Piper...".truncate("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length) 应该返回 "A-tisket a-tasket A green and yellow basket".truncate("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length + 2) 应该返回 "A-tisket a-tasket A green and yellow basket".truncate("A-", 1) 应该返回 "A...".truncate("Absolutely Longer", 2) 应该返回 "Ab...".解答：123456789function truncate() &#123; if(str.length &gt; num) &#123; return str.substr(0,num-3) + `...`; &#125; if(num &lt;= 3) &#123; return str.substr(0,num) + '...'; &#125;&#125;7. 猴子吃香蕉, 分割数组 （猴子吃香蕉可是掰成好几段来吃哦） 把一个数组arr按照指定的数组大小size分割成若干个数组块例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]];1234567// 测试用例 (test case): chunk(["a", "b", "c", "d"], 2) 应该返回 [["a", "b"], ["c", "d"]].chunk([0, 1, 2, 3, 4, 5], 3) 应该返回 [[0, 1, 2], [3, 4, 5]].chunk([0, 1, 2, 3, 4, 5], 2) 应该返回 [[0, 1], [2, 3], [4, 5]].chunk([0, 1, 2, 3, 4, 5], 4) 应该返回 [[0, 1, 2, 3], [4, 5]].chunk([0, 1, 2, 3, 4, 5, 6], 3) 应该返回 [[0, 1, 2], [3, 4, 5], [6]].chunk([0, 1, 2, 3, 4, 5, 6, 7, 8], 4) 应该返回 [[0, 1, 2, 3], [4, 5, 6, 7], [8]].解答123456789101112function chunk(arr, size) &#123; if(arr.length &lt; size) &#123; return arr; &#125; // 请把你的代码写在这里 const result = []; for(var i=0;i&lt; arr.length;i=i+size) &#123; result.push(arr.slice(i,i+size)) &#125; return result;&#125;这道题一时半会我也没有思路，网上搜索的答案。针对该类问题，大概的思路就是: 通过迭代不断简化问题的复杂度，在每次迭代中处理细化后的小 casetake a case:12345678910111213141516const arr = [1,2,3];const size = 2;// 第一次迭代时: i = 0; i + size = 0 + 2 = 2;// 因此 ( slice 操作是半闭半开区间 )arr.slice(0,2) =&gt; [1,2] // 第二次迭代时：i = 之前循环末尾语句的计算结果i = 2; i + size = 2 + 2 = 4;arr.slice(2,4) =&gt; [3]// 第三次迭代时， i = 4, 已经无法通过循环条件 i &lt; arr.length( 4 &gt; 3 )，退出循环体// 此时， result 的结果为 [[1,2],[3]]*/8. 截断数组 返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。1234567// test case: slasher([1, 2, 3], 2) 应该返回 [3].slasher([1, 2, 3], 0) 应该返回 [1, 2, 3].slasher([1, 2, 3], 9) 应该返回 [].slasher([1, 2, 3], 4) 应该返回 [].slasher(["burgers", "fries", "shake"], 1) 应该返回 ["fries", "shake"].slasher([1, 2, "chicken", 3, "potatoes", "cheese", 4], 5) 应该返回 ["cheese", 4].解答：1234567891011121314151617function slasher(arr, howMany) &#123; if(arr.length &lt; howMany) &#123; return []; &#125; arr.splice(0, howMany); return arr;&#125;// 没啥好说的，splice 不是一个 pure function, 每次经过 splice 操作，都会改变原始数组// 另外，数组的非纯方法还有: - Array.prototype.push() - Array.prototype.unshift() - Array.prototype.pop() - Array.prototype.shift() - Array.prototype.sort()9. 比较字符串 （蛤蟆可以吃队友，也可以吃对手）如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。[“Alien”, “line”]应该返回true，因为”line”中所有字符都可以在”Alien”找到。123456789// test casemutation(["hello", "hey"]) 应该返回 false.mutation(["hello", "Hello"]) 应该返回 true.mutation(["zyxwvutsrqponmlkjihgfedcba", "qrstu"]) 应该返回 true.mutation(["Mary", "Army"]) 应该返回 true.mutation(["Mary", "Aarmy"]) 应该返回 true.mutation(["Alien", "line"]) 应该返回 true.mutation(["floor", "for"]) 应该返回 true.mutation(["hello", "neo"]) 应该返回 false.10. 比较字符串（蛤蟆可以吃队友，也可以吃对手）如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。[“Alien”, “line”]应该返回true，因为”line”中所有字符都可以在”Alien”找到。123456789// test casemutation(["hello", "hey"]) 应该返回 false.mutation(["hello", "Hello"]) 应该返回 true.mutation(["zyxwvutsrqponmlkjihgfedcba", "qrstu"]) 应该返回 true.mutation(["Mary", "Army"]) 应该返回 true.mutation(["Mary", "Aarmy"]) 应该返回 true.mutation(["Alien", "line"]) 应该返回 true.mutation(["floor", "for"]) 应该返回 true.mutation(["hello", "neo"]) 应该返回 false.解答：12345678910111213141516171819202122232425262728293031323334// 啰里啰唆的写法function mutation(arr) &#123; const prev = arr[0].toLowerCase().split('').sort().join(''); const next = arr[1].toLowerCase().split('').sort().join(''); let result = true; for(var i =0;i&lt;next.length;i++) &#123; if(!prev.includes(next[i])) &#123; result = false; &#125; &#125; return result;&#125;// 装逼写法function mutation(arr) &#123; const accumulator = (acc, prev, index, arr) =&gt; &#123; // 如果只有一个成员，或者遍历不到下一个成员 if (arr[index + 1]) &#123; // 相比较的两个成员都进行转为小写操作 prev = prev.toLowerCase(); const next = arr[index + 1].toLowerCase(); for (var i = 0; i &lt; next.length; i++) &#123; // 找不到后面字符串中的某个字符时，直接 return if(!prev.includes(next[i])) &#123; return false; &#125; acc = true; &#125; &#125; return acc; &#125;; return arr.reduce(accumulator, true);&#125;11. 过滤数组假值 （真假美猴王）删除数组中的所有假值。在JavaScript中，假值有false、null、0、””、undefined 和 NaN。12345// test casebouncer([7, "ate", "", false, 9]) 应该返回 [7, "ate", 9].bouncer(["a", "b", "c"]) 应该返回 ["a", "b", "c"].bouncer([false, null, 0, NaN, undefined, ""]) 应该返回 [].bouncer([1, null, NaN, 2, undefined]) 应该返回 [1, 2].解答：12345function bouncer(arr) &#123; // 请把你的代码写在这里 return arr.filter(member =&gt; Boolean(member));&#125;// API 背的熟练， Easy摧毁数组 金克斯的迫击炮！实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。1234567// 垃圾 撸啊撸，还金克斯，垃圾游戏，抄袭我 Dota// test casedestroyer([1, 2, 3, 1, 2, 3], 2, 3) 应该返回 [1, 1].destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3) 应该返回 [1, 5, 1].destroyer([3, 5, 1, 2, 2], 2, 3, 5) 应该返回 [1].destroyer([2, 3, 2, 3], 2, 3) 应该返回 [].destroyer(["tree", "hamburger", 53], "tree", 53) 应该返回 ["hamburger"].解答：1234567891011121314151617181920function destroyer(arr, ...rest) &#123; // 请把你的代码写在这里 const params = Array.from(rest); params.map(member =&gt; &#123; arr = arr.filter(item =&gt; item !== member); &#125;); return arr;&#125;// 原文中， destoryer 函数只接受一个参数，想要考察 arguments, 可改造如下：function destoryer(arr) &#123;// 深拷贝一下const brr = JSON.parse(JSON.stringfy(arr));// 把默认的数组过滤掉brr.shift();const params = Array.from(brr); params.map(member =&gt; &#123; arr = arr.filter(item =&gt; item !== member); &#125;); return arr;&#125;13. 数组排序并找出元素索引我身在何处？先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。12345678// test casewhere([10, 20, 30, 40, 50], 35) 应该返回 3.where([10, 20, 30, 40, 50], 30) 应该返回 2.where([40, 60], 50) 应该返回 1.where([3, 10, 5], 3) 应该返回 0.where([5, 3, 20, 3], 5) 应该返回 2.where([2, 20, 10], 19) 应该返回 2.where([2, 5, 10], 15) 应该返回 3.解答1234567891011121314151617181920212223242526272829function where(arr, num) &#123; // 为什么不适用默认的 sort 参数呢？可以测试一下 [1,100,1000,1001,10000,10001 ].sort() 的结果 // 进行非纯排序 arr.sort((a,b) =&gt; a-b); // let 个变量，用于缓存最终插入的下标 let insetIndex = 0 ; // 当所有成员都小于等于给定值，那么插入的位置为最后一个 if(arr.every(member =&gt; member &lt;= num)) &#123; insetIndex = arr.length; &#125; // 当所有成员都大于等于给定值，那么插入位置为第一个 else if(arr.every(member =&gt; member &gt;= num)) &#123; insetIndex = 0; &#125; // 如果都不是，那么，找到比他大的那个数的下标，将此下标作为最终的插入下标 else &#123; insetIndex = arr.findIndex(member =&gt; member &gt;= num); &#125; return insetIndex;&#125;/** PS： 在 else &#123; insetIndex = arr.findIndex(member =&gt; member &gt;= num); &#125; 逻辑中，我本来判断的是 member =&gt; member &lt;= num 这样是不对的，因为可能有多个数比他小，返回第一个比他小的数，位置不准确*/14. 凯撒密码 （让上帝的归上帝，凯撒的归凯撒）下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。移位密码也就是密码中的字母会按照指定的数量来做移位。 一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔ ‘O’，以此类推。写一个ROT13函数，实现输入加密字符串，输出解密字符串。什么是凯撒密码？一张图说明：下图搬运自：https://img-blog.csdn.net/20180826085456567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70图片搬运自https://img-blog.csdn.net/20180826085456567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70我的理解： 简单来说，凯撒密码的规则就是，加密和揭秘双方以一个数字作为密钥，来约定每个字母的位移顺序。例如，密钥为3时，A =&gt; D, B=&gt; E … X =&gt; A (因为X的 charCodeAt +3 已经超过了 Z，不符合规则，因此需要 先减去一个 循环的周期 26，再按照密钥+3)不 BB 了， show you code1234`X`.charCodeAt(0) = 88;String.fromCharCode(88+3); // '[' 不符合凯撒加密规则，因此需要先往回撤回一个密码表周期, 即 26 ，再按照密钥位移 +3String.fromCharCode(88-26+3); // 'A' this is right!解答：123456789101112131415161718192021222324252627282930function rot13(str) &#123; // 将一段话，转换为可以被处理的二维数组 eg: `hello, my wolrd!` =&gt; [`hello,`,`my` ,`world`]; const stringArrays = str.split(' ').filter(member =&gt; !!member); // 再分别处理每一个 "单词" const parseResult = stringArrays.map(word =&gt; &#123; // 将每个单词转换为数组，对每个字符进行处理 return Array.from(word).map(charator =&gt; &#123; // A 对应的 ASCII =&gt; 65 , N 对应的 ASCII =&gt; 78 const ZCode = 'Z'.charCodeAt(0); let current = charator.charCodeAt(0); // 非字母的处理方法 if(current &lt; 65 || current &gt; ZCode) &#123; return charator; &#125; // else &#123; const dest = (charator.charCodeAt(0) + 13) &gt; ZCode ? (charator.charCodeAt(0) -26 + 13): charator.charCodeAt(0) + 13; return String.fromCharCode(dest); &#125; &#125;).join(''); //单词中的每个字母拼接，不用空格 &#125;).join(' '); //多个单词拼接，需要空格 return parseResult; &#125;// 另外，这里的 if(current &lt; 65 || current &gt; ZCode) &#123; return charator; &#125; 可以使用 String.match(/\w/g) 来命中为数组，从而过滤掉非字母的标点符号总结这些算法都是最最最最最基本的算法，然而在解决这些问题中，还是出现了卡壳的地方。算法还是得多练，人脑的逻辑思维，就得靠大量算法来优化和调教~keep moving !😘觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css位移属性导致像素模糊问题解决办法]]></title>
    <url>%2F2019%2F02%2F22%2FCss%E4%BD%8D%E7%A7%BB%E5%B1%9E%E6%80%A7%E5%AF%BC%E8%87%B4%E5%83%8F%E7%B4%A0%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、抛出问题12345678910111213.modal-container &#123; position: fixed; width: 100vw; height: 100vh; z-index: 999;&#125;.modal &#123; position: absolute; top: 50%; right: 50%; margin: auto; transform: translat(-50%,-50%);&#125;以上代码，是做一个模态框，该模态框使用 Hack 方法来垂直竖直两个方向居中，但是在实际操作中，会发现，整个模态框的边缘，会出现模糊的现象，仿佛打了马赛克一样。马赛克版：高清版:可能上传的图片质量不高，但在我的电脑上差异非常明显二、分析原因经过查阅资料和一通分析，发现是CSS 的 transform： translate 属性在作元素位移时，极有可能发生像素点无法对其的情况，从而导致显示模糊的问题，画个灵魂示例图：如图，正常情况下，元素的边缘应该和像素点对齐，但是经过 CSS translate 后，计算的结果并非整数的像素点，导致本来一个像素能渲染的内容，没有完全归纳在其像素点内，导致出现模糊的情况。翻译成人话： css transform:translate(-50%,-50%) 计算后的结果很可能是 transform: translate( 100.5px, 100.5px)，就因为 0.5 所以模糊三、解决方案方式有二第一种： 在 transfrom 时，使用 calc 函数 加上0.5 px ，具体代码 :123456789.modal &#123; position: absolute; top: 50%; right: 50%; margin: auto; /** 这 0.5px加或者减都可以 */ transform: translat(calc(-50% + 0.5 px), calc(-50% + 0.5 px));&#125;第二种，别 transform 了，直接父元素弄成 Flex 布局，两条轴都设置居中，也能达到效果。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron设置-webkit-app-region 后无法响应鼠标点击事件的解决方式]]></title>
    <url>%2F2019%2F02%2F19%2FElectron%E8%AE%BE%E7%BD%AE-webkit-app-region%20%E5%90%8E%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、抛出问题在开发 Electron 应用的过程中，想要使得窗口在普通大小可以拖动，于是设置给 title-bar css 如下：1234.title-bar &#123;-webkit-app-region: drag;&#125;但是设置了这个属性后，发现在 title-bar 上双击全屏和 restore size 的功能又废了，现象如图：怎么办呢？二、网上现有的方案通过搜索不难发现，有如下方案：拖动不要用 -webkit-app-region 了，自己监听 mouseDown 和 mouseUp 来实现吧父元素设置 -webkit-app-region： drag, 子元素 -webkit-app-region： no-drag 即可但是，本项目在实际开发过程中有点特殊，即：要实现拖拽和双击放大/缩小的所著元素为同一个 DOM三、最终解决方案在宿主 Dom 中嵌套一个等宽，等高，但设置了-webkit-app-region： no-drag 属性的 div 即可，上代码：1234&lt;!-- 拖拽使用 --&gt;&lt;div [ngClass]="&#123;'title-bar__drag': !isMax&#125;"&gt; &lt;div style="-webkit-app-region: no-drag; width: 100%;height: 100%"&gt;&lt;/div&gt;&lt;/div&gt;现在，一切都正常啦！]]></content>
      <tags>
        <tag>css</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rx.js将二维数据拍扁(平)]]></title>
    <url>%2F2018%2F09%2F26%2Frx.js%E5%B0%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%8B%8D%E6%89%81(%E5%B9%B3)%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客12345678910111213141516171819202122 /** * 从后台返回如下格式数据 * * 期望数据结构： [...&#123; index:'', name: '', age: '' &#125;] 该数据类型的长度为 9 (所有数据拆开的总长度) */ const response = &#123; content: [ [&#123; index: 0, name: 'aa1', age: 11 &#125;, &#123; index: 0, name: 'aa2', age: 11 &#125;, &#123; index: 0, name: 'aa3', age: 11 &#125;], [&#123; index: 1, name: 'bb1', age: 12 &#125;, &#123; index: 1, name: 'bb2', age: 12 &#125;, &#123; index: 1, name: 'bb3', age: 12 &#125;], [&#123; index: 2, name: 'cc1', age: 13 &#125;, &#123; index: 2, name: 'cc2', age: 13 &#125;, &#123; index: 2, name: 'cc3', age: 13 &#125;] ], &#125;; // 使用 Rx.js of(response).pipe( map(res =&gt; res.content), mergeMap(arr =&gt; from(arr)), mergeMap(arr =&gt; from(arr)), toArray(), ).subscribe(res =&gt; console.log(res));最终结果：说明：无论嵌套多复杂，嵌套几层，都能用 opreator 给拍平，这就是纯函数强大的地方，指责单一，功能明确，代码量小。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>rxjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Travis-CI 持续集成部署 HEXO 博客项目]]></title>
    <url>%2F2018%2F08%2F29%2F%E4%BD%BF%E7%94%A8%20Travis-CI%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%20HEXO%20%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客持续集成的概念现在前端项目都是模块化开发，需要大量的 npm install ,编译等环节，除去在开发环节中使用诸如 webpack 这样的自动化工具，在部署的时候，也可以使用 Travis 来提升部署效率。持续集成，相当于将环境搭建在云端，每次只需提交代码到对应的分支，就会触发 CI 自动构建，其中构建过程中的指令都可以指定。准备工作已经有 HEXO 搭建的博客，并且源码存放在 HEXO 项目的分支上(分支名字随便起，不是 master 就行)。如图：熟悉 HEXO 的用法及基本指令，例如123$ hexo g // 构建$ hexo clean // 清除已构建的资源$ hexo s // 起服务持续集成部署登录https://travis-ci.org/，使用github账号登录。找到自己的 HEXO 项目：设置选项在github添加Access Token，在右上角账号的settings-&gt;Personal access tokens.点击generate new token来生成新token选择仓库权限就可以。get token除了 “删库”。其他权限都给上：权限分配(生成之后一定要保存好，因为只会出现一次，丢失了就只能再重新生成了。)回到Travis官网，在设置中填入刚复制的token，取一个名字，这个名字需要写到下面的配置文件中添加 token在你的hexo项目的 分支中 添加配置文件.travis.yml，并且放在 HEXO 源码分支的根目录下如下：123456789101112131415161718192021222324language: node_jsnode_js: stableinstall: - npm installscript: - hexo gafter_script: - cd ./public - git init - git config user.name &quot;ZQ-jhon&quot; - git config user.email &quot;350037310@qq.com&quot; - git add . - git commit -m &quot;Update docs with TRAVIS-CI.&quot; - `git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master` branches: only: - hexoenv: global: - GH_REF: github.com/ZQ-jhon/ZQ-jhon.github.io.git你需要修改的是 user.name，user.email，以及在 GH_REF 中填写你自己的仓库中该项目的地址( 浏览器 url 自己找规律 )。要使用https协议的仓库地址，使用ssh仓库地址会失败。注意这一行git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot; 中的githubblog就是你刚在token那里取的 Token 字段，key 要对应上。配置完成后推送到仓库中，我们就能看到网站中在部署了。展示：我push了一个新文件，触发了自动构建，这里可以看到构建过程，其实跟我们本地跑 npm install … 那些流程是一样的：部署成功参考：https://www.jianshu.com/p/5691815b81b6[https://blog.csdn.net/woblog/article/details/51319364](https://blog.csdn.net/woblog/article/details觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>Travis-CI</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、Session、Token]]></title>
    <url>%2F2018%2F08%2F26%2Fcookie%2Csession%2Ctoken%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客Cookie 是比较早的服务端和客户端验证身份的方法。因为 http 是无状态的，因此，每次 http 请求，服务端不知道是谁在来访，因此，对于每次来访，回传字段中会设置 set-cookie 字段，浏览器会将 cookie 保存在本地，等下次 http 请求，再发送给这个域名的服务器。Cookie 可以由服务端来设置生命周期。Cookie 存储在客户端本地 。Cookie 挂载在 Document 对象下，可以用 js 修改，因此有安全风险，所以后面又引入 Session 来补全不足。一般情况， cookie 直接写入请求头。For eg:1234567891011121314// 首次访问client =&gt; 访问 www.example.comserver =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：&#123; set-cookie: username=uuidtest123;Domail=.example.com ... &#125;// 第二次访问client =&gt; 判断访问的域名，检查是否存在该域名的 cookie, 有的话就带上一起请求server =&gt; 收到来访，并含有 cookie ，回传不用再加新 cookie 了。Session 一般通过 set-cookie 一起传过来，配合 cookie 保存会话信息。Session 的出现是为了保持用户的连接状态而做出的努力。比如有一个场景，用户登录了 a.com ，如果登陆 a.com/profile ，查看一下个人资料，难道还要用户重新登陆吗?不合适吧？用户判断 Cookie 所在的客户端是否还“在线”，每次客户端进行请求(动作)，都会刷新 Session 的时间值。For eg:12345678910111213141516// 首次访问client =&gt; 访问 www.example.comserver =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：&#123; set-cookie: username=uuidtest123;Domail=.example.com;sessionId=xxx;sessionFresh=30min;&#125;// 第二次访问client =&gt; 访问 www.example.com ，并自动携带 sessionserver =&gt; 收到来访，刷新 session 的新鲜值，并通过 set-cookie 回传给客户端。如果在限定的时间内（此处是30分钟）， session 新鲜值没有被刷新，就会被销毁。其中 cookie 的作用就是为了解决HTTP协议无状态的现状所作出的努力。至于 session 机制则是又一种在客户端与服务器之间保持状态的解决方案。简而言之， cookie 是辨别来访者，session 是看该来访者是否保持连接​​​​​token 和 session 很像，也是为了保持状态，一般是登陆以后，后端会返回 sessinId ,其实就是 token=&gt; 用户唯一标识，通过 Cookie 来传给后台。token 在前端传给后端时，直接写入请求体，当做普通参数缀在后面即可。参考： https://zhuanlan.zhihu.com/p/27736893觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程与响应式编程之己见]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B7%B1%E8%A7%81%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客1. what is 函数式编程？函数，在编程中，通常体现为： 输入 =&gt; 执行 =&gt; 结果。他不是命令式的，而是对一段操作进行逻辑封装，拿到输入，就能产出结果。通常来说，满足函数式编程的特性的“函数”应该有如下特点:函数必须有入参，并且函数的产出会根据入参的不同而变化。函数执行的整个流程中，不会对全局变量、外部属性等产生影响。函数式编程代码量小，干净。举个例子：123456789101112var arr = [1,2,3,4,5];function addOne (array) &#123; for(var i=0;i&lt;array.length;i++)&#123; array[i] += 1; &#125; return array;&#125;addOne(arr); // 2,3,4,5,6写了一个方法，接受一个数组，产出数组每个成员+1，但这段代码的不足之处在于：难以复用，如果需求提出 addTwo,addThree方法，需要不断修改函数名和内部逻辑。内部的代码很啰嗦， for 循环很low。·函数式编程改进版：12let arr = [1,2,3,4,5];arr.map(item=&gt; item+1); // 3,4,5,6,7这里，改进使用了原生的 Array.prototype.map 方法，代码量缩小了很多不说，而且复用性进一步提升。整个函数做的事情现在非常直观，入参 =&gt; 每项参数 + 1 =&gt; 返回新数组，由此，可以说，map()方法是一个纯函数(pure function)。2. 响应式编程前端中也有一个概念叫响应式，bootstrap 。这里当然说的不是这个，对于响应式编程的概念，我想提及Vue或者 angular的双向绑定来阐述：1234567// template: i'am &#123;&#123; name &#125;&#125;// js:name = 'jhon';在前端MVVM的框架中，都有一个数据双向绑定的概念，这里的模版中的变量，实时反映了数据中的 name 变量的 value，而且，如果此时我修改了 name 的值，那么模版中对应的值也会跟着修改。数据 &lt;=&gt; 视图 是同时发生，同时改变的，因为模版就是对数据的一个映射。再举个例子：c的值，是通过 a + b 来赋值的，如果ab不是固定的，而是变化的值，那么 c 的值也不会固定为3。123let a = 1,b=2;let c = a + b; // 3不难看出，响应式编程特点：同步发生，结果会随着修改参数而实时、动态地变化。存在固定的映射关系。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeBB搭建过程（windows+Redis）+ 科学上网方法]]></title>
    <url>%2F2018%2F06%2F22%2FNodeBB%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%88windows%2BRedis%EF%BC%89%2B%20%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客1.首先去 github 把项目 clone 下来：https://github.com/NodeBB/NodeBB然后cd到nodebb，安装依赖 cnpm i依赖在安装的时候，由于没有 package.json ，会自动 clone ，整个以来安装完成后，应该是这样：install2.环境配置附上中文文档：https://docs.nodebb-cn.org/1.Chocolatey 可以下载离线包，之后通过 Chocolatey 安装一些环境：1choco install -y imagemagick github python2 nodejs-lts git这里的 github , nodejs ，git 可以选择不安装，跳过。2.数据库（database）选择 RedisRedis 可以在菜鸟教程上面找到安装教程：http://www.runoob.com/redis/redis-install.html安装完成以后，WINDOWS + R 打开 services.msc ，找到 Redis 服务，启动之：Redis3.Hello World Running首先，使用命令 ./nodebb build 构建静态资源，构建完如下：helloworld此时打开监听的 127.0.0.1:4567 (默认配置的端口)，如图所示：installer上面的直接填写，下面的数据库配置如下：database点击最下面的 install NodeBB 后，整个项目总算 Running 了：running4 . use LANTERN to cross wall (使用lantern 科学上网)下载lantern安装包 =&gt; 一路next安装，并启动 =&gt; 右下角图标右键 ，连接 =&gt; OK依赖环境 .net FrameWork 4.0 +我都打包好了 :链接：https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow 密码：yyfg觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈一谈来北京后的工作节奏以及对前端的看法]]></title>
    <url>%2F2018%2F05%2F23%2F%E8%B0%88%E4%B8%80%E8%B0%88%E6%9D%A5%E5%8C%97%E4%BA%AC%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%8A%82%E5%A5%8F%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%9C%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客为什么来北京这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。工作因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。前端别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于：熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。生活来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。很久没有写东西，思路比较乱，想到哪写到哪。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于bootstrap特殊分辨率页面的实现思路]]></title>
    <url>%2F2018%2F04%2F14%2F%E5%9F%BA%E4%BA%8Ebootstrap%E7%89%B9%E6%AE%8A%E5%88%86%E8%BE%A8%E7%8E%87%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言很久没更新博客，这段时间刚刚找到工作，会立即（从今天起）恢复更新博客的频率。罗马不是一天建成的，希望自己保持良好的学习和做笔记的习惯，笔耕不缀，他日可期！1.Boostrap重构传统固定px的页面在第一次接手重构任务后，有点懵逼。可能是因为自己很久没有写代码了，忘了以前做的响应式的一些细节，所以又开始不断的调试，总算是把坑补上了，于是在此做一下记录。PSD需求图：这里写图片描述整个需求其实蛮简单的，就是一个固定1122px的页面，里面有些图片，图片在pc端需要留出固定margin（需要像素级还原PSD稿）。想了想，自己以前做的响应式都是根据 .container类的默认宽度来写的，于是想了一会便有答案，整体思路如下：给整个页面给一个 container类，并且限制 max-width 为1122px。页面中右侧的小兔，因为所有图片都是从后台接口调取，一旦设定img-responsive，那么默认的max-width就是100%(想象一下，如果后台传来一个1000宽的图，用户网络慢点，基本上就GG了)，只能按照原图比例来缩放，何况每个图片的容器都是动态高度的…所以，每张图片的宽高，尽可能的去用js动态设定。尽量使用Rem，设定好body的font-size，然后各部分的font-size都根据rem去取，例如 0.8rem,0.6rem等等。布局方面，左侧的长图固定的，非接口调取，宽高固定的。在整个页面中，缩放的比例完全是以此图片作为参照物。因此给此图片加上img-responsive以及col-lg-3 col-md-3 col-sm-6 col-xs-6类，然后动态的让单个盒子容器的高度取 左侧长图的高度，这样会让盒子完美的呈现，不会留有内边距，也不会让box-shadow很难看。右侧的6张小图，每纵向的两个图使用一个列容器来包裹，设定 col-lg-3 col-md-3 col-sm-6 col-xs-6，这样就可以达到在手机端的显示效果，如图所示：这里写图片描述2.核心逻辑代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//动态设置每个box-shadow 容器的高度，为imgLong的高度var h = $(&apos;#imgLong&apos;).first().height();$(&apos;.box&apos;).each(function()&#123; $(this).css(&#123; height:h &#125;);&#125;);$(window).resize(function()&#123; var h=$(&quot;#imgLong&quot;).first().height();$(&quot;.box&quot;).each(function()&#123;$(this).css(&#123;height:h&#125;)&#125;);&#125;); //限制h4标签文本长度 $(&apos;.imgTitle&apos;).each(function()&#123; //这里由于后台Trs模版获取的标题，前面有N个空格，因此需要前端来消化一下字数，故进行“空格剔除”，所以用 .split(&apos; &apos;).join(&apos;&apos;) var txt = $(this).text().split(&apos; &apos;).join(&apos;&apos;); if(txt.length&gt;20)&#123; //其实真正的标题就10个字，但是前面有10个空格 $(this).text(txt.substring(0,19)+&apos;...&apos;); &#125; &#125;); //为所有调用的imgShort图片增加CLASS $(&apos;.imgShortParent img&apos;).each(function()&#123; $(this).addClass(&apos;imgShort&apos;);&#125;); //动态设定每个单列容器的宽度 = imgLong的宽度，高度 = imgLong的高度，以此来保证图片不会溢出 box-shadow。var h = $(&apos;.imgLong&apos;).first().height();var w = $(&apos;.imgLong&apos;).first().width();$(&apos;.col-box&apos;).each(function()&#123; $(this).width(w).height(h);&#125;);$(window).resize(function()&#123;//页面缩放时，动态获取宽高，并赋值给 col-box 列容器。 $(&apos;.col-box&apos;).each(function()&#123; $(this).width(w).height(h);&#125;)&#125;)3.不足与改进思路3.1 页面性能不足，重绘过多，网速慢的时候，会有一瞬间发生：【图片突然很大，然后被缩放到正常比例】的恐怖现象。。。解决方案：可以为每张小图(250*165)包裹一层div，设置max-height与max-width，overflow:hidden，来解决。3.2 实际上，整个项目我写了两套html骨架（由于项目紧，刚接手，长时间没写代码比较陌生），pc一套，mobile一套，感到非常罪过，不配成为一个前端工程师。。。但是话说回来，原先的项目也写的太TM乱了，一个注释都没有，而且一个页面中script标签不下20个。。。解决方案：用我上述的思路去实现觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单/双向绑定、组件通讯]]></title>
    <url>%2F2018%2F03%2F25%2Fng%E8%8B%B1%E9%9B%84%E5%88%97%E8%A1%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E6%A6%82%E5%BF%B5%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8D%95%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客为什么要学angualr(4.0+)？无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。微软收购了github，还不赶紧学ts？本文参考博客/资料：1.https://blog.csdn.net/u012967849/article/details/78767294/ （ng父子组件如何传值）2.https://www.angular.cn/ （ng中文官网）3.https://www.jianshu.com/p/a2b625a99c8d （ng的class和interface区别）本篇笔记所用环境及NG版本一览：NG版本文件目录1.组件的文件形式/结构：形如：components跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。2.打包入口：app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。moudle如图：在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。在@NgMoudle中，import则声明了使用的第三方库。在 declarations 中注册了子组件。app目录不仅作为整个项目的打包入口，其本身也是一个根组件。3.模块划分：根组件/模块 appMoudle英雄列表 =&gt; heroes 组件当前选择的英雄=&gt; hero-detail组件新的ng语法ng新语法:1234*代表ng指令 不用ng-if,ng-for，类似于驼峰 ngFor ngIf ()代表绑定事件 原生事件绑定直接写在括号里 (click) (keydown)[]单向绑定 代表绑定属性 [name] = &apos;jobs&apos; [()] 双向绑定&lt;input [(value=&quot;someValue&quot;)] type=&quot;text&quot;/&gt;官方称双向绑定写法叫盒子里的香蕉？？？？？？？父子组件状态传递Step1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。Step2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。Step2如图所示：Step2Step3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。Step3如图所示：Step3在Vue中，通常是这样做的：子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。angular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。组件 运作/执行流程 的文字描述列表组件渲染出Mock的数组 (列表组件 heroes 负责)为每一个渲染出的项，绑定事件，并传参 (同上)在列表组件heroes 的模版加入&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;，这样父组件的值已经通过单向绑定至子组件，但接收与使用，决定权在于子组件。（同上）hero-detail组件接收父组件传递过来的数值，并在内部import {Input} from &#39;@angular/core&#39;（hero-detail组件负责）接着在export语句中，使用装饰器来声明+初始化 得到的属性@Input() hero: Hero;然后就可以用啦！ （hero-detail组件负责）整体逻辑代码 步骤Step 1创建列表组件，使用*ngFor来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。12345&lt;li *ngFor=&quot;let thisHero of heroes&quot; (click)=&quot;onSelect(thisHero)&quot;&gt;&lt;/li&gt;在对应的.ts文件中，这个方法为：123456789101112131415161718192021//方法 /*定义参数类型为Hero类型，即从hero.ts导出的类： export class Hero &#123; id: number; name: string; &#125; 并且，设定该方法没有返回值。 */onSelect(hero: Hero): void &#123; //动态赋值 this.selectedHero = hero; //业务逻辑相关 this.bool = !this.bool; this.isSelected = &#123; &apos;badge&apos;:!this.bool, &apos;selected&apos;:this.bool &#125;&#125;这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。Step 2在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：1&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;把值绑定到子组件模版，这样，父组件的使命就结束了。Step 3子组件如何接收并使用父组件传来的值呢？首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）import {Input} from &#39;@angular/core&#39;接着，装饰器来申请接收传进来值，声明+初始化二连：1@Input() hero: Hero;哦，完事了。此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记]]></title>
    <url>%2F2018%2F03%2F11%2Ftypescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言TypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8…提前为将来的ES标准打下基础。学习tsc，不亏!环境搭建1$ cnpm install -g typescript完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下：12$ cd your File_path$ tsc File_name.tsOK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。tsc类型检测1.基本类型检测在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如：12345let a:number = 1; //OKlet a:string = 1; //error类型检测的语法，就是在变量屁股后面缀上 :类型2.数组的类型检测：123let arr:number[]=[1,2,3]; //ok 类型+[] let brr:Array&lt;number&gt;=[4,5,6]; //OK 数组泛型+尖括号&lt; 类型 &gt;3.元组类型 Tupe1234let X:[number,string];x=[1,&apos;hello&apos;]; //OKx=[1,2]; //type error元组类型适用于已知个数和元素类型的数组。字符串拼接及字符串模板拼接：跟ES6一样，通过（`）来实现，【】为Tab上面的按键。for eg :123456let hi= (`hello,wrold!`);//输出 hello,world!字符串模板：提供一种更优雅的书写方式：${ 变量名}for eg:123456789let names:string = &apos;xiaoming&apos;;let age:number = 23;let sentence:string = (`hello,my name is $&#123;names&#125;,my age is $&#123;age&#125;`);编译后的js文件为:1234567var names = &apos;xiaoming&apos;;var age = 23;var sentence = (&quot;\nhello,my name is &quot; + names + &quot;,my age is &quot; + age + &quot;\n&quot;);document.body.innerHTML = sentence;枚举类型12345enum flower &#123;a,b,c,d,e,f,g&#125;; //enum关键字，后跟枚举类型的命名let rouse:flower = flower.a; //定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性alert(rouse); // 0 表明rouse映射的对象，在flower中的index为0Any类型有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。let不能重复定义，我就用var来演示。Any类型也可以像数组的第一种定义方法一样，形如：1234567891011121314151617181920Array:let arr:number[]=[1,2,3]; // OK数字的组合，可不就是数组吗？字符串组、布尔值组...let brr:string[] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];let crr:boolean[] = [true,false];Any:let drr:any[]=[1,&apos;2&apos;,true]; // OK只知道是个类似于数组的数据类型，但是对元素的类型不做限制。Void类型void类型表示空。常用在函数返回值，形如：123456//注意函数返回值类型检测的写法function foo():void&#123;alert(&apos;123&apos;);&#125;;其实，void包含两种数据类型，就是null和undefind。触类旁通，其实还有两个类型是null和undefind，如图所示：null&undefind如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。类型断言作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。写法一：123let a:number =1; let b:any = &lt;number&gt;a ; //赋值第二种写法:类型断言Let来看这样一段代码：for循环实例在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？运行结果可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果将上述代码的var i改为let i这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。因此，代码结果如下图所示：let执行结果再来看一个对比：使用var声明将var 改为let可见，两种声明，是一摸一样的输出，为什么呢？var的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次for(let i=0;i&lt;5;i++)的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。因为这里没有异步函数，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。Const定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。eg:123const a = 1 ;const a = 2 ; //error结构赋值普通结构赋值：普通结构赋值函数参数结构赋值：函数结构赋值注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。数组中的【…】解构语法数组解构输出：输出可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。对象解构直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。下图是错误示范：那么同理，如果在一个方法中返回对象，同样也可以被解构。函数返回的对象也可以解构赋值如果对象存在嵌套现象，可以使用冒号表达式：嵌套的对象，使用冒号表达式来嵌套化结构展开还是使用…语法，进行数组或者对象的浅拷贝。数组展开，形如：数组展开对象展开，形如：对象展开对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。可选参数、默认参数12345678function test(a:string,b?:string,c=&quot;wang&quot;)&#123;console.log(a)console.log(b)console.log(c)&#125;a为string类型，b为可选参数(string类型)，c是有默认值的参数确定的参数要现在第一个，不能把可选参数写在第一位。函数断点Yield在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。1234567891011121314151617181920212223function* foo()&#123; console.log(1); yield; //设置断点，下同 console.log(2); yield; console.log(3); yield;&#125;;/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。 *必须重新赋值，再调用。 */let zoo = foo(); //这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。zoo.next();//1zoo.next();//2zoo.next();//3箭头函数作用一：主要用于声明匿名函数，简化代码。123456var sum = (a,b)=&gt;a+b上式等价于：var sum = function (a,b)&#123;retrun a+b;&#125;;作用二：消除this指针带来的歧义,优化执行上下文。1234567function getName (name) &#123; this.name = name ; setInterval(function () &#123; console.log(&apos;name is &apos;+this.name)&#125;,1000)&#125;;var john = new getName(&apos;jhon&apos;);console.log(john) // 打印 name is (空)这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。使用箭头函数改造：1234567function getName (name) &#123; this.name = name ; setInterval(() =&gt; console.log(&apos;name is &apos;+this.name)),1000)&#125;;var john = new getName(&apos;jhon&apos;);console.log(john) // 打印 name is jhonFor…of循环for…in 循环对象的下标1234567var arr = [1, 2, 3, 4];arr.name = &apos;myArr&apos;;for (var n in arr) &#123; console.log(n+&apos;==&apos;+arr[n])&#125;//输出0=1,1=2,2=3,3=4,name=myArrfor of 循环对象的key12345678910111213141516var arr = [1, 2, 3, 4];arr.name = &apos;myArr&apos;;for (var n of arr) &#123; console.log(n+&apos;==&apos;+arr[n])&#125;//输出0=1,1=2,2=3,3=4,undefind//还可以循环字符串var arr =&apos;hello,world!&apos;for (var n of arr) &#123; console.log(n)&#125;//h,e,l,l,o,，w,o,r,l,d,!;forEach 循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性1234567var arr = [1, 2, 3, 4];arr.name = &apos;myArr&apos;;arr.forEach(function (n,v) &#123; console.log(n,v)&#125;)//输出1,2,3,4，但是没有输出我们定义的name总结：for…in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for…of有点鸡肋，但是胜在使用场景广泛。interface接口interface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。interface当然，接口中预先定义的变量，也可以规定/限制函数中的参数：限制函数中的参数基于Class的继承在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script!基于Class的继承访问权限关键字：public 公共成员。 子类、父类内部都可以访问到。private 私有成员。只允许在类中访问。protected 超类的私有成员。但是在子类中仍然可以访问。构造器Construcor：1234//形如：constructor()&#123; name?string;&#125;;在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。举例说明：这时候，只要在构造器的name上增加关键字public，即可在class中全局访问：类的继承真的比基于原型链的继承更加优雅和简便。通过extends关键字实现继承觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>typescript</tag>
        <tag>编译</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IONIC3 打包安卓apk详细过程（大量图文）]]></title>
    <url>%2F2018%2F03%2F06%2FIONIC3%20%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A4%A7%E9%87%8F%E5%9B%BE%E6%96%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客本文写于2018年2月12日 22:25:59。如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。1.基本依赖环境nodejs环境 (作为一个前端相信你已经有了)nodejs最好提前配置好node的环境变量，便于全局访问jdk(下面细说)JDKSDK(下面细说，其实主要难就难在SDK配置了)SDKgradle(下面细说)gradle2. 基本工具gitbash(就是用来替代windows自带的丑陋的CMD)gitbash下载：我都打包了！链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6mwindows自带的CMD(window+R输入CMD，管理员身份运行)CMDVSCode(微软爸爸开发的前端IDE)VSCode下载：请自行去微软爸爸官网下载。3.环境配置3.1 nodejs (需要配置环境变量)前端必会，跳过。3.2 jdk (无需配置环境变量)下载：已经上传网盘↓链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m请自行根据系统安装32/64位的版本。安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\Program Files\JavaOK，jdk安装完成，在cmd中，输入$ java -version验证是否安装成功。jdk安装成功OK。3.3 sdk (需要配置环境变量)下载：跟上面的一样，我都打包了。链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\Program Files\SDK接着配置环境变量，我的电脑——右键属性——-高级系统设置——-环境变量。在下面的系统变量(s)中，新建，键值对如下：name: ANDROID_HOMEkey: C:\Program Files\SDK如图所示：SDK环境变量然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\bin缀在最后面，前面有【;】分隔符。然后运行CMD，输入$ android -h，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。ANDROID环境配置验证现在，打开SDK目录下的SDK Manager.exe打开界面上的Tools,选择options，先配置国内镜像：域名千万不要输入http或者https协议前缀，谁输谁哭。配置镜像下面记得勾选。回到主界面，点packages再点reload先勾选如下图的三个Tools:分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools]Tools别急，还没完，下面还有一个：[SDK platform]SDK platform全部选中后，点右下角 install packages 来安装，耐心等待即可。3.4 gradle安装(需要配置环境变量)打开：http://services.gradle.org/distributions/下载：gradle-4.1-bin.zip同样安装在JDK,SDK的目录下，便于查找。同样的配置环境变量：GRADLE_HOME=C:\Program Files\SDK\gradle-4.1;%GRADLE_HOME%\bin测试命令（查看版本）：gradle -v3.基本流程1.安装ionic和cordova打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）1$ cnpm install -g ionic cordova安装ionic和cordova2.创建ionic项目桌面右键，在此处gitbash1$ ionic start app tabs耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后1$ ionic serveionic serve稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示：如果做到这一步没问题，说明：1.nodejs与gitbash没有问题。2.ionic和cordova没有问题。4.打包确保SDK,JDK没问题以后，使用指令1$ ionic cordova build android --release(如果这条命令有问题，可以去掉–release然后debug编译，编译完成Dos会显示apk目录位置)如若你聪慧的双眼发现如下字眼：Build Success! 即可关闭本网页，说明你已经成功打包了。OK，此时你已经有了debug的包，但是这个包没有签名，不能发布。此时，我们应该：First：在JDK目录下的bin文件夹下（C:\Program Files\Java\jdk1.8.0_71\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。Second：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。执行完命令1，继续执行命令2即可完成签名打包。命令1：生成签名密钥123/*使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！*/keytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000命令2：给文件签名使用刚才生成的zhangqiang.keystore -signedjar 签名后的apk 签名之前的apk 签名包别jarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore签名完成如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！后续的软件压缩打包可以百度：jarsigner打包5.疑难杂症5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to undefined to prevent this warning.出现这个提示，说明配置不正确。解决方法：在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下：12345var postcssOptions = &#123; from: undefined, to: path_1.basename(sassConfig.outFile), map: autoPrefixerMapOptions &#125;;5.2 安卓SDK组件缺失/缺少/不匹配报文：123A problem occurred configuring project &apos;:CordovaLib&apos;.&gt; You have not accepted the license agreements of the following SDK components: [Android SDK Build-Tools 26.0.2].原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。5.3 缺少安卓构建/打包工具报错报文：1234Unhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,or on your system to install the gradle wrapper. Please include gradlein your path, or install Android Studio(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。解决办法：去http://services.gradle.org/distributions/ 下载 gradle-4.1-bin.zip配置相应的环境变量：GRADLE_HOME=E:\software\gradle-3.0PATH=%PATH%;%GRADLE_HOME%\bin测试命令（查看版本）：gradle -v完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。)感谢收看。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>android</tag>
        <tag>SDK</tag>
        <tag>JDK</tag>
        <tag>APP</tag>
        <tag>IONIC</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript Dom拖动 插件 putThere.js]]></title>
    <url>%2F2018%2F03%2F06%2Fjavascript%20Dom%E6%8B%96%E5%8A%A8%20%E6%8F%92%E4%BB%B6%20putThere.js%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客开源地址：跪求各位看官给我点star吧 T.T，谢谢！https://github.com/ZQ-jhon/putThere.js原理及构想关于拖动，如果不用html5的原生事件，怎样实现呢？不妨先设想一下整个拖动的流程：点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值)当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。代码想好其中的原理，代码也就不那么难写了。1234567891011121314151617181920212223242526272829303132333435363738394041424344//window监听 window.onmousedown=function(obj)&#123; /*鼠标按下，dom元素脱离位置，变成绝对定位*/ obj.style.position='absolute'; &#125;window.onmouseup=function(event)&#123; var event = window.event||event; //获取鼠标距离浏览器边界的距离 var x = event.clientX; var y = event.clientY; console.log('鼠标距离浏览器边界(0,0)的距离('+x+','+y+')') /*获取dom元素距离浏览器边界的x,y值*/ var left = obj.style.left; var top = obj.style.top; console.log('Dom元素距离浏览器边界(0,0)的距离('+left+','+top+')') /*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/ if(left&gt;x||top&gt;y)&#123; x=-x; y=-y; &#125; obj.style.left = x+'px'; obj.style.top = y+'px'; &#125;&#125;;&#125;我将它封装成一个函数，调用的时候，形式如下：12345var div = document.getElementById('div');putThere(div);此时，div元素可以在document中任意的拖动，改变位置。效果预览：鼠标拖动div效果如下：Demo效果预览可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。兼容程度实测 兼容 IE9及以上觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>plug-in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下]]></title>
    <url>%2F2018%2F02%2F01%2F%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客6. 简单说一说盒模型，W3C和IE怪异盒模型。W3C标准的盒模型：width == content_width(不包括padding+border+margin)IE怪异盒模型： width == content_width+padding+border参考我之前的博客：http://blog.csdn.net/qq_20264891/article/details/790197247.简要阐述XSS和CSRF攻击及防范7.1 XSS攻击与防范注入攻击。简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。例如:1&lt;input type=&quot;text&quot; value=&quot;&lt;script&gt;alert(123)&lt;/script&gt;&quot; name=&quot;input&quot;&gt;&lt;/input&gt;显然，正常的用户，不会再输入框里面输入形如&lt;script&gt;alert(123)&lt;/script&gt;的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。7.2 CSRF攻击与防范CSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。参考文章：https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/这篇文章写的很好。8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个_proto_对象，构造函数则有一个prototype对象，该对象上挂载的是可以继承的方法、属性等等。8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。9.页面性能优化有哪些方式？a.文件(css,js,img)压缩、合并（雪碧图）b.减少请求数量c.减少页面重排/重绘d.使用懒加载，按需加载e.CSS3动画有限保持帧率f.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值g.减少代码冗余量，精简代码h.静态资源部署到CDN节点9.1 重绘/重排是怎么回事？有什么区别？网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的重排。当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是重绘。重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。也就是说，重排一定会引发重绘。重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。也就是说，重绘现象的发生，有可能是以重排作为前提。9.2 请举例说明重绘，什么情况下会重绘？重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。9.3 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？是的。color,background等属性会引发重绘。浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。10. 浏览器如何知道一个css文件,js文件需要缓存？首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。在https://www.cnblogs.com/shixiaomiao1122/p/7591556.html看到一个缓存原理图，侵删，图注的很详细：缓存机制原理图11.HTTP状态码304,502,503304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。502：服务器作为网关或代理，从上游服务器收到无效响应。503：服务器停机维护。http状态码：1XX：临时响应。并继续等待客户端的请求2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？任何项目只有未发现 bug 和已经发现 bug 两种情况不存在没有 bug 的情况即便是测试人员也不可能覆盖 100% 的可能性但是测试表中的要求必须 100%覆盖如果测试通过上线后产生的 bug如果是测试表中未覆盖的则编制测试表的人员背锅如果是不可抗力福利彩票背锅作者：王小明链接：https://www.zhihu.com/question/65688799/answer/233725228开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>原理</tag>
        <tag>重绘</tag>
        <tag>冲排</tag>
        <tag>腾讯面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94(%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE)%20%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客这篇博客同步更新于我的GitHub博客：我的GitHub博客面试回顾：腾讯面试回顾1.js中ajax发送请求的步骤在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下: ①创建XMLHttpRequest对象（标准浏览器）：123if(window.XMLHttpRequest)&#123; var xhr = new XMLHttpRequest();&#125;IE7及以下，这个对象为：ActiveXObject：123if(window.ActiveXObject)&#123;var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)&#125;② 初始化请求1xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com&apos;,是否异步?true:false);③发送请求/传递数据1xhr.send();请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：12//数据xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com/index.html&apos;,true);如果是POST方法，直接写 xhr.send(&#39;数据&#39;) 中。④设置异步回调callback()先给个错误示范：12345//xhr.readyState 本地的请求状态//xhr.status 服务器返回的请求状态码if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123; do something...&#125;这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1这里的异步方式主要通过一个事件来完成：1234567xhr.onreadystatechange()=function()&#123;if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123; do something...&#125;&#125;如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。扩展：既然 readyState==4 &amp;&amp; status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~参考文章 ，我以前的博客：Ajax初探上一次的面试中，xhr.open()初始化 xhr.send()发送请求 xhr.onreadystatechange=function(){}回调函数 这三点都忘记答了，一定要注意。2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？事件捕获、事件响应、事件冒泡。如图：事件捕获和冒泡不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。一句话概括这种机制：捕获：自外而内，从根到叶，从大到小 。冒泡：自内而外，从叶到根，从小到大。来做个实验，有如下的html结构 和 js代码：123456789101112131415161718192021222324&lt;!--HTML结构--&gt;&lt;div id=&quot;div1&quot;&gt; 我是DIV1 &lt;div id=&quot;div2&quot;&gt; 我是DIV2 &lt;button id=&quot;btn&quot;&gt; i am a button &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;//script代码var div1 = document.getElementById(&apos;div1&apos;);var div2 = document.getElementById(&apos;div2&apos;);var btn = document.getElementById(&apos;btn&apos;);btn.addEventListener(&apos;click&apos;, function() &#123;console.log(this.id)&#125;,false);div2.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);div1.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);HTML结构如图：HTML结构当点击最里面的button，会依次出现这种情况：控制台输出可以看到，事件是在冒泡阶段被触发的。当改变js API中最后一个Boolean值为true时，又会产生另外一种景观：这里写图片描述这次是从外向内依次触发的。总结：1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。3.闭包是怎么回事？用在什么场景？简而言之：1、闭包就是可以访问局部作用域的变量。并且： 2、 可以使局部变量常驻内存参考阮一峰老师的闭包博客： 阮一峰—-闭包Q:闭包的内部函数为什么变量不会被销毁？A：12345678910function a()&#123;var a =1;function b()&#123;a+=1;return a;&#125;return b();&#125;因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）A：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；Q3.2：如何避免内存泄漏的问题？A：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。4.CALL和Apply是干嘛的？二者都是为了更改function 的this指针，举个例子CALL(新的this对象，原先的参数1，原先的参数2…);Apply(新的this对象，[原先的参数1，原先的参数2…]);先传入新的this对象，再传入旧方法的传参。5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？1.jsonp跨域利用&lt;script&gt;标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：12345678910111213141516171819202122//在js预先定义好callback()函数 function fun(data)&#123; //use data to do somethings. &#125;//动态创建script标签，并在url中说明请求地址var body = document.getElementsByTagName(&apos;body&apos;)[0];var script = document.createElement(&apos;script&apos;);script.type = &apos;text/javasctipt&apos;;script.src = &apos;require.php?callback=fun&apos;;body.appendChild(script);//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。 //假设传回的值是 fun(&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。这样，通过script不受跨域访问的特性，实现了跨域访问。2.CORS跨域（主流浏览器及IE10+）对于客户端，我们还是正常使用xhr对象发送ajax请求。唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;对于服务器端，需要在 response header中设置如下两个字段:Access-Control-Allow-Origin: http://www.yourhost.comAccess-Control-Allow-Credentials:true这样，我们就可以跨域请求接口了。3.返回的json和jsonp有什么区别？返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：1callback(&#123;&quot;name&quot;:&quot;HanMeiMei&quot;&#125;)觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>ajax</tag>
        <tag>javascript</tag>
        <tag>腾讯</tag>
        <tag>面试</tag>
        <tag>浏览器兼容</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用原生js制作一个动态简历(多动症简历)及在线预览部署过程]]></title>
    <url>%2F2018%2F01%2F29%2F%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86(%E5%A4%9A%E5%8A%A8%E7%97%87%E7%AE%80%E5%8E%86)%E5%8F%8A%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客本项目Fork地址(欢迎Star)：https://github.com/ZQ-jhon/resume本项目预览地址(Preview Address)Preview : 多动症简历项目起因因为在网上看到一个大神做的动态简历，如连接所示：http://strml.net/炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。引用的第三方库1.jQuery 实际用到的地方只有1%2.prism 代码高亮库。用到30%3.marked.js markdown语法转html的库，实际用到20%技术概要通篇中使用的技术难度并不大，主要有：核心原理：同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。字符串提取、拼接。setInterval定时器控制整个代码的吞吐节奏/速率。在setInterval中设定一些if，用来控制总字符串的吞吐位置。避坑指南1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释//，要对/进行转义，如下`\/这里填写你的内容\/。**2.字符串的命名一定要切实合理： 如图所示：字符串的命名3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n&gt;123&amp;&amp;n&lt;321)这种方法来进行区域渲染。prism的渲染代码如下：123456官方js库地址：[http://prismjs.com/](http://prismjs.com/)语法:prism.heihlight(渲染的字符串,渲染的代码格式)Prism.highlight(str.substring(0,n), Prism.languages.css);4.MarkDown ⇒ HTML渲染 ： 同样根据n的值，来使用if()来进行循环。marked.js官方库地址：https://www.npmjs.com/package/marked渲染代码如下:drawBoard.innerHTML =marked(str.substring(929,1885));5.动态创建Pre标签（id=”drawBoard”） ： CSS代码版是一开始写在HTML的，但是之后的简历板子（id=”drawBoard”，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：动态创建drawBoard6.已经创建的元素无法在另外的循环中获取 ：在刚才的【5】中，动态创建的pre标签(id=”drawBoard”)会在if()的区域内无法document.getElementById(‘drawBoard’)，此时需要在if里面再次获取并且赋值，如图所示：7.动态下拉 同样通过n的值来让元素的溢出自动下拉如图：动态下拉8. 动态简历最后的魔术环节 ： 还是通过n的值来进行判断，从而渲染其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。代码如图：核心原理代码1234567891011121314151617181920//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义var styleTag = document.getElementById(&apos;styleTag&apos;);var sourceBoard = document.getElementById(&apos;sourceBoard&apos;);var str = &apos;\/*大家好...今天我给大家做一个在线简历...\/*&apos;;var n = 0;window.setInterval(function()&#123; n++; styleTag.innerHTML = str.substring(0,n); sourceBoard.innerHTML = str.substring(0,n);&#125;,100);//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。 Demo部署到GitHub详细过程本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：gh-pages预览项目在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。整个部署的环节大致如下：在本地的项目根目录下，$ git init加入当前所有文件到暂存区 $ git add .(后面有个“·”，代表全部文件)连接远程仓库 $ git remote add origin &quot;your repository address&quot;提交所有文件到git版本控制系统 $ git commit -m &quot;create Demo resume&quot;push到你的远程仓库 $ git push origin master打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub反思与不足在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：http://strml.net/的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>动态简历</tag>
        <tag>Github部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录]]></title>
    <url>%2F2018%2F01%2F25%2F2018%E5%B9%B41%E6%9C%8823%E6%97%A5%E8%85%BE%E8%AE%AFSNG-IMWeb%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%20%E7%94%B5%E8%AF%9D%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言2018年1月18日，突然接到一个来自深圳的电话，对方说从拉勾网上看到我投递腾讯SNG部门的IMWEB团队前端，简单询问了一下我的具体情况，包括前端的就职年限，过去的工作经历。其中有一点比较有意思的是，对方问我为什么2016年7月毕业直到2017年2月入职中国XX网，这之间的简历是空缺的？我回答他说因为刚毕业没有太好的就业选择和机会，错过了很多校招，所以在毕业的时候去一个艺术培训学校当了半年的吉他老师，因为觉得和前端的职业经历没有关系，因此没有把这段经历写在简历上。对方说，我觉得你应该把这段经历也写在简历上，我说好的谢谢。接着问了他招聘的是什么职位，对方说是前端工程师，我说主要负责什么工作？他说主要负责腾讯课堂的一些前端工作，我跟对方说，我目前还在老家，可能无法及时的去深圳那边面试，问了他可不可以远程面试，遂对方跟我说，可以采用电话面试，并且约定了电话一面的时间，2018年1月23日。面试的过程及结果从接到电话直到第一次面试的这段时间，我在网上大量的检索了关于腾讯电面的经验，并且深入的针对一些常用的考点，进行梳理和总结，例如：闭包、原型、作用域链、Ajax、http协议、盒模型、兼容问题、xss/csrf攻击、浏览器渲染（重绘重排）等。在1月23日的当天，5点多回家，还一直在看复习资料，饭也顾不上吃。7点，从深圳打来了一个熟悉的电话。整个电话持续了40分钟之久，基本上问的都是基本的原理，而后可能我的回答让面试官也比较满意，之后是1个半小时的远程监控编程环节，三道程序设计题，给一个半小时的时间，腾讯面试官远程QQ协助监控你的桌面，只允许用浏览器的console以及本地编辑器，不允许查询资料，在编程过程中，面试官还会试图针对一些有问题的地方给予提示。最后，我还是很遗憾的没有通过，因为三道编程题目，我磕磕巴巴基本上没做出来，所以挂了，把文件打包发送给面试官后。我问面试官，像我这样经历不丰富，简历不突出的，为什么会考虑我呢？面试官说，我们什么阶段的人选都会考虑，你入行前端一年，基础还是不错的，就是编码能力需要提高。。。面试完以后，大概有几个小时，一直沉浸在刚才的面试里，晚饭也忘了吃了，一直在反思自己哪些地方答的不够好，这几天的复习哪些地方有疏漏。我的互联网公司处女面就以失败告终了。但是回头想想，这次失败的经历是一面镜子，让我清楚的认识到自己几斤几两，督促我在今后的学习中一步一个脚印，脚踏实地，再去仰望星空。电话里问到的题目接下来，根据我当天的通话录音，来对所问到的题目进行穷举：1.接你现在的工作主要是偏前端还是偏后端？我看你大学的课程主要是偏后端一点？A:大学课程修完以后，出来没找到工作，干了半年吉他老师，对自己就业比较迷茫。回 到老家以后，干前端、运维都有，但是主要是前端。2.接触前端多久了？接触/学习的渠道是什么？A：满打满算一年。刚开始是同事辅导，慢慢入手以后，在W3CSCHOOL、网易云课堂、腾讯课堂、慕课网学习。3.Ajax发送请求的步骤？3.1 xhr.open()3.2 xhr.send()3.3 callback()4.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？5.事件代理，事件委托是什么意思？6.闭包是怎么回事？用在什么场景？6.1 变量常驻内存会带来什么问题？6.2 如何避免这种问题？6.3 怎么销毁？7.CALL和Apply是干嘛的？8.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？8.1.如何进行CORS跨域？需要什么条件？8.2 对服务器来说，返回json数据和JSONP数据有什么不一样？8.3 还有其他跨域方式吗？9.简单说一说盒模型，W3C和IE怪异盒模型。10.简要阐述XSS和CSRF攻击及防范10.1 XSS脚本劫持，如何截获？(ps.这里居然把CSRF的概念当做XSS的来回答….)10.2 CSRF域名劫持11.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)11.1 例如构造函数有一个test()方法，prototype上也有一个test()，这两个方法有区别吗？12.页面性能优化有哪些方式？12.1 文件、脚本合并是如何优化的呢？12.2 重绘，重排是怎么回事？有什么区别？12.3 请举例说明重绘，什么情况下会重绘？12.4 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？13.浏览器如何知道一个文件资源是否需要缓存？14.HTTP状态码304,502,50314.1 1,2,3,4,5 开头的状态码都表示什么？15.Node、Vim、angular简述15.1 Node上如何处理异常情况？（Ps.我回答的是开发调试。。。找js文件）15.2 已经上线的项目，出问题，怎么样去处理异常？16.构建工具除了Webpack，还接触过其他的吗？16.1 Webpack的优点和应用场景？编程大题1、页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。2、实现超出整数存储范围的两个大正整数相加 function add(a, b) 。注意：参数 a 和 b 以及函数的返回值都是字符串。3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。这个环节基本上就知道自己GG了。。。第一题考基本功，DOM、事件、定位、jsAPI第二题考算法，基本逻辑第三题考原理，基础不得不说面试官的技术确实比较全面，腾讯的远程面试也是好狠，直接远程监控写代码的。。。鼠标和界面都不敢静止，静止可能就会被认为作弊（不知道他们是不是这样来判断的，反正我没有停下来过）。以下是做完所有题目后跟面试官的沟通记录。天真的我以为会被眷顾招入鹅厂，然鹅我想多了。。图1图2图3图4觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>腾讯SNG-IMWeb面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于HEXO的个人博客图文搭建详尽过程，看不懂算我输]]></title>
    <url>%2F2018%2F01%2F18%2F%E5%9F%BA%E4%BA%8EHEXO%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%96%87%E6%90%AD%E5%BB%BA%E8%AF%A6%E5%B0%BD%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%9C%8B%E4%B8%8D%E6%87%82%E7%AE%97%E6%88%91%E8%BE%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言须知：1.最终生成的博客地址必须是： ZQ-jhon.github.io 即用户名.github.io2.本地的HEXO仓库，命名必须也为 ZQ-jhon.github.io ，HEXO项目放置于该目录之下。昨天经过一番折腾，终于将HEXO部署上线了，以下对于昨天整个搭建的过程做一个详细的回顾。HEXO是基于NODE的一款博客框架，有很多丰富的主题可以选择，配合GIT来使用。Git回顾：本地仓、远程仓安装整个安装过程我是参考一位博主：HEXO系列教程以下用自己的理解来做一番梳理与归纳：*先介绍HEXO中的4个命令：1234$ hexo g #完整命令为hexo generate，用于生成静态文件 $ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览 $ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上 $ hexo n #完整命令为hexo new，用于新建一篇文章首先，确保本地Git公钥与Github公钥相匹配，参照：Git本地仓确认匹配后，新建Repository，命名的时候，规范为：github名字.github.io因此，这里的新仓库名字应该为： ZQ-jhon.github.io这里写图片描述同样的，在本地新建一个同名的目录：ZQ-jhon.github.io ，然后打开目录，文件夹是空的此时，在项目目录下右键打开Gitbash here1.$ cnpm install hexo-cli -g&nbsp; &nbsp; &nbsp; 使用淘宝镜像安装hexo-cli2.npm install hexo-deployer-git --save&nbsp;&nbsp;&nbsp; 模块安装到开发目录3.$ hexo init&nbsp;&nbsp;&nbsp;初始化4.$cnpm install&nbsp;&nbsp;&nbsp;安装依赖（PS：中途如果出现问题，可以 cnpm install hexo-deployer-git --save 安装GIT的PUSH插件）5.$hexo g &amp;&amp; hexo s 构建(genereater)并启动服务(server)，在locallhost:4000下即可预览效果这里写图片描述远程部署本地的文件我们已经在locallhost:4000端口预览的非常满意了，如何部署到站点(github)上呢？1.首先，找到HEXO目录下的 __yml文件，在最下面修改如下：1234deploy: type: git repository: git@github.com:ZQ-jhon/ZQ-jhon.github.io.git branch: master注意：如下图所示，这里的repository地址就是Github download时弹出的项目地址，但是最好不要用HTTPS协议，走SSH协议，昨天因为这个问题，调试了一下午！！！这里写图片描述2.布置好以后，我们来Ping一下Github，看能否有响应：1$ ssh -T git@github.com这里写图片描述欢迎了一波，很稳。此时，直接把Server Ctrl + C然后 $HEXO D&nbsp;&nbsp;&nbsp;直接推送，稍等片刻，打开Github仓库，看看文件是否上传成功如果上传成功，大功告成，打开 https:ZQ-jhon.github.io即可访问博客页面了。文章新建与MarkDown语法新建文章 $hexo n filename这个比较简单，建完文件，也别秀骚操作了，老老实实去source文件夹的_post文件夹里面，去用一个好点的编辑器，修改文本文档，保存为UTF-8格式，并且修改后缀名为.md，保存类型为所有类型，否则上线部署会产生乱码。值得一提的是，CSDN的在线文档编辑器就采用的是MarkDown语法，而且该种语法与标签语言完全兼容，因此，可以将HTML代码原封不动的全被拷贝近.md文件。##主题更换与配置##在我们HEXO根目录下，有一个themes文件夹，里面存放的都是各式各样的主题，默认的是landscape，我们可以去官网，HEXO的THEME分类下下载更多精美的主题，然后解压缩，将文件夹放在themes下，另外稍微修改 __yml文件下，theme:lanscape 即可。这里写图片描述相关的配置，我们可以follow官方推荐作者的github去看看人家的wiki或者code，都有详尽的说明，甚至可以加QQ咨询……这里写图片描述最终效果与总结Welcome to the ZQ-jhon.github.io wiki!基本效果预览文章详情预览搜索模块预览不得不说GITHUB开源生态真的非常强大，感谢这些开发者带来的精美主题。感谢主题作者Miachel.LuHEXO-Mellow-theme 点击查看该项目觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>HEXO</tag>
        <tag>动态部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular搭建后台人员管理系统 1.1.0]]></title>
    <url>%2F2018%2F01%2F17%2FAngular%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-1-1-0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客今天基于原来的DEMO，将功能进行了调整。这里写图片描述如图所示，增加了一个新的controller，完成了增删改查的最后一步：查。step1中还是使用ng-repeat遍历出的options，然后这个select又绑定了一个model，可以在controller用于判定用户的选项，然后根据这个选项，在users的数组中进行查找，最后，显示在查询结果的框中。今天遇到的几个问题：1.数据可视化和canvas视图留了一个坑。2.突然发现controller之间的方法、变量不可以共享，例如我在下面的控制器中创建的用户数组：123456$scope.users=[&#123;...&#125;,&#123;...&#125;,&#123;...&#125;,&#123;...&#125;]在上面查询控制器中无法访问，网上查询之，得到结果，原因是作用域无法访问，这点跟js比较像，两个在树形结构上是兄弟层级关系的节点，不能访问对方的内部变量。但是angular 可以像js一样，变量继承，因此，可以吧users挂到 相对比较高的祖先节点上，这样，其子控制器就可以访问到了。3.在Step1的位置，出现了F5以后，默认出现一个空白options的现象，查看元素，得知该元素：1&lt;option value=&quot; undefind!&quot;&gt;&lt;/option&gt;于是采用了一个笨办法，手动添加一个&lt;option value=&quot;&quot; selected=&quot;&quot;&gt;&lt;/option&gt;然后，在ng-repeat的原始option选项中，也添加selected=&quot;selected&quot;，这样就OK了！4.今天对各个控制器进行合理的切分，达到模块化的效果，例如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*********根控制器的数据*********/ app.controller(&apos;rootctrl&apos;,function($scope)&#123; $scope.users = [ &#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;, &#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;, &#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;, &#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;, &#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;, &#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125; ]; &#125;)/**********增加用户 控制器*************/ $scope.addUser = function()&#123; var index = $scope.users.length-1; $scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;); &#125; /**********查询 控制器************ / $scope.jiansuo = function()&#123; var a = $scope.selectValue; $scope.result = a; if(a==&quot;&quot;||null||undefined)&#123; document.getElementById(&apos;sp&apos;).innerHTML=&quot;未选择/未输入!&quot;; document.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请先选择分类&apos;) &#125; else&#123; document.getElementById(&apos;sp&apos;).innerHTML=&quot;您要查询的&quot;+$scope.infos[a].name+&quot;是:&quot;+$scope.input; document.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请输入具体的&apos;+$scope.infos[a].name+&quot;！&quot;); &#125; &#125;; /********删除 控制器***********/ $scope.remove = function(index)&#123; // if($scope.users.length&lt;=1)&#123;// $scope.users.splice(index,1)// &#125;// else&#123;&#125; $scope.users.splice(index,1) &#125;;在切分这些控制器的过程中，一定要注意各个控制器的作用域，以及能否访问到调用数据。GitHub:https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack打包工具学习笔记]]></title>
    <url>%2F2018%2F01%2F17%2FWebpack%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言：Webpack是一款基于node的前端打包工具，它可以将很多静态文件打包起来，自动处理依赖关系后，生成一个.js文件，然后让html来引用，不仅可以做到按需加载，而且可以减少HTTP请求，节约带宽。1.配置与安装在node已经安装完成的前提下，全局安装webpack123456789$ cd d:$ mkdir test &amp;&amp; cd test //创建test ，并进入$ npm install -g webpack //等待100s，安装完成，也可以使用淘宝镜像$ npm init //初始化package.json文件$ npm install --save-dev webpack //添加依赖 ，在package.json中声明依赖,等待安装完成2.基本操作$webpack main.js webpack.js当前目录下创建如下工作结构:1234567/---------test ----app ----main.js ----index.js ----index.html项目目录下，app文件夹含有两个js文件，修改如下：1234567891011121314151617181920212223//main.js ，这是Webpack主要的入口文件 require(&apos;./index.js&apos;);//index.js ，这是被主文件引用的文件document.write(&apos;Hello,world!&apos;);//index.html ，供浏览器解读&lt;html&gt;...&lt;script src=&quot;./webpack.js&quot;&gt; // 引用同目录下的webpack.js...&lt;/html&gt;webpack.js是哪来的呢？就是通过webpack打包生成的js文件，接下来，开始生成webpack.js文件：1$ webpack main.js webpack.js这里写图片描述可以看到已经打包成功了，此时查看IDE中的项目目录，根目录下已经多了一个webpack.js文件。然后用浏览器打开index.html，效果如下：这里写图片描述此时查看网页源代码：这里写图片描述66666666666！3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）每次在命令行敲目录调试，是很痛苦的，因此需要一次配置，多次使用的方法。在根目录下新建文件： webpack.config.js (名字就是这样，规定，不能改)，内容如下：123456789101112module.exports = &#123;//入口文件位置 entry:__dirname+&apos;/app/main.js&apos;,//出口 output:&#123; //路径 path:__dirname, filename:&apos;webpack.js&apos; &#125;&#125;这里的 __dirname是一个node的全局变量，用于指向当前的工作目录，调皮的我console.log了一下这个变量：这里写图片描述确认无疑。这样，我们的webpack.js写完以后，可以直接在命令行中敲：1$ webpack可以发现，项目中也同样的会生成目标js文件，也就是webpack.js，这样非常方便，省事。还有一种配置方法，将package.json文件中”scripts”里面添加键值对：这里写图片描述这样同样可以在项目目录生成目标js文件，直接在 命令行里敲1$ npm start //因为webpack是全局安装的，直接value给webpack，而不用跟路径如果start被占用了/冲突了，也可以在scripts下面自定义一个键值对：123&quot;zq&quot;:&quot;webpack&quot;$ npm run zq //稍作修改cmd 命令最后还是可以生成。4.webpack服务器监听代码变动，自动刷新及source-map4.1关于source-map，也就是在webpack.config.js中配置 devtool (develpment tool)的值，例如我这样配置：这里写图片描述在webpack完成文件打包后，会自动生成一个与目标文件相同名的 .map文件，用来说明打包文件的每个地方对应的是哪些文件，简而言之，让你能知道源码是在哪里错的，帮你刨根问底，而不用开发者自己去Debug。参考文章1：入门WEBPACK，看这篇文章就够了—-简书参考文章2：Webpack中的sourcemap4.2 webpack服务器首先单独安装 server 包 ：1$ npm install --save-dev webpack-dev-server同样的，在webpack.config.js中做出相应的配置：123456789101112131415161718module.exports = &#123; devtool: &apos;source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, module: &#123; &#125;, devServer: &#123; contentBase: &quot;./&quot;,//本地服务器加载index.html页面所在的目录，这里写的是根目录 historyApiFallback: true,//不跳转 inline: true//实时刷新, &#125; &#125;配置好config后，还得配置一下package.json，在scirpts里面添加server：123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot;, &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;,接着，在命令行运行123456789$ npm run server /*届时服务器会自动启动， 并且打开浏览器,默认端口为8080，也可以devServer:&#123;port:4040 //自己配置端口为4040&#125;下面是一个服务器跑起来后的演示结果，我不断的修改work.js 中 document.write的值，从而服务器会自动检测并刷新页面：5.非JS文件的操作(img,json,css……),猪脚：Loaders5.0 基本概念前面都在说js文件，官网说什么文件都可以当做模块打包，下面就来试试非js文件。首先要明确的是，webpack只能识别js文件，如果要识别非js文件，就需要loader来解析这些文件。loaders 需要单独安装，并且在webpack.config.js中的modules关键字下进行配置。Webpck2以上已经支持对json的解析打包，不需要额外的loaders，可以在main.js中123var json = require(&apos;../package.json&apos;)//json在它的上级目录document.write(json.scripts.server);运行结果 ：这里写图片描述可见，网页中，没有通过任何第三方loader，即可将json解析并打包成bundle.js。5.1 BableBable可以使得开发者使用最新的ECMAscript标准来书写代码，而不用管新标准是否被当前使用的浏览器完全支持。还是需要单独安装Bable的包：123$ npm install --save-dev babel-core babel-loader babel-preset-env /安装完成后，在webpack.config.js下的module关键字下进行配置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859module.exports = &#123; devtool: &apos;source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, devtool: &apos;eval-source-map&apos;, devServer: &#123; contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;, module: &#123; rules: [ &#123; test: /\.js$/, //正则匹配，必须 use: &#123; //使用到的loader loader: &quot;babel-loader&quot;, //loader名 options: &#123; //选项 presets: [ //预先配置 &quot;env&quot; ] &#125; &#125;, exclude: /node_modules/ //不包含的目录或文件 &#125; ] &#125; &#125;;5.2 CSS文件处理webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。同样先安装两个包 style-loader和css-loader1$ npm install --save-dev style-loader css-loader123456789101112131415161718192021 module: &#123; rules: [ &#123;.......&#125;， &#123; test: /\.css$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125;也可以简写：&#123;test:/\.css$/.use:[&#123;loader:&quot;style!css&quot; //这里的执行顺序是从右往左，css应该在style之前执行&#125;]&#125;根目录下新建 ./src/index.css，写一个body的背景为green，然后在入口文件main.js中,require(‘../src/index.css’)，接着通过命令行$ webpack此时查看index.html，发现页面背景已经变成绿色这里写图片描述6.插件plugins先安装插件的包：1cnpm install html-webpack-plugin在webpack.config.js中 头部，引入依赖：1let webpack = require(&apos;webpack&apos;);然后在webpack.config.js中配置根键值对：123plugins: [ new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;) ],这里写图片描述觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3原理，结合jquery复习]]></title>
    <url>%2F2018%2F01%2F17%2Fcss3%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BB%93%E5%90%88jquery%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客0.怪异盒模型非IE及IE9及以上， 盒模型的构成为:content老IE，IE8及以下， 盒模型为 content+border+padding如果有这样一个DIV：1div&#123;width:100px;height:100px;border:1px solid black;padding:10px;&#125;在非IE下，盒模型为：这里写图片描述在老IE下，盒模型为：这里写图片描述由此可见，老IE在计算盒模型时，加入了两个padding和border的值。1.background-size规定背景的位置。eg:12#div&#123;background-size:cover;&#125;//覆盖整个div#div&#123;background:url(img/123.png) no-repeat;background-size:10% 10%;&#125;//背景图片宽高为原始图片宽高的10%，且不重复2.background-orgin://可以选择的值为：content-box、margin-box、padding-boxcontent-box、margin-box、padding-box的区别①content-box，即采用W3C标准渲染方法，不计算padding和border及margin，得出的盒子②padding-box，渲染盒子的时候，把padding当做盒子宽高的组成部分，即在标准盒子模型的基础上，宽高都增加padding px。③margin-box，同理，宽高都增加margin-box3.border-radius 圆角边框，假如DIV 的 宽 = 高，即正方形，此时，如果border-radius = div 的宽/高，那么此时的div是一个圆形。如果border-radius远远大于div的宽/高，那么还是一个圆形，不会变化。因此，background-origin的值，就取决于背景图从哪个盒子模型开始渲染。4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色1234&#123;text-shadow: 225px 0px 0px #FF0000; /*水平偏移225，垂直不偏移 z-index为0 颜色为红色*/&#125;最终效果：这里写图片描述5.font-face 自定义字体兼容度：IE及IE8以下不支持，主流浏览器都支持。关于自定义字体，请参见我之前的一篇博客：自定义图标与百度Share API6.Css3 之 2D转换 (transform)释义：transform 改变;变换兼容度：IE9及以上，主流浏览器都兼容。下面列举的方法，都位于transform属性之下，例如：transform:rotate()、transform:translate()主要的2D转换属性：6.1 位移： translate() 方法1div&#123;transform：translate(100px,100px)&#125; /*在原来位置的基础上，x轴移动10px，y轴移动10px*/如图所示：这里写图片描述原本处于空白位置的DIV，现在x,y轴都平移了正的100px6.2 旋转 rotate() 方法1234```img&#123;transform：rotate(30deg)&#125; /*图片顺时针旋转30度，当然，也可以和css伪类配合完成一些效果 ，例如 ：*/ img:hover&#123;transform:rotate(30deg)&#125; /*鼠标悬停，方可旋转*/这里写图片描述由此可见，这个效果在一些圆形的图片上最为适用6.3 比例/缩放 scale(x轴比例，y轴比例) 方法跟刚才的旋转同理，我们也可以给一个图片设定一:hover伪类，然后来观察效果12345/*文档结构：父div包含着一个图片，父div标准盒子模型100x100，原始图片100x100 */div&#123;width:101px;height:101px;overflow:hidden;border:1px solid black;&#125;img:hover&#123;transform: scale(1.5,1.5);&#125;这里写图片描述这个效果也很常见。鼠标放进去放大，鼠标离开变成原始比例。关于这一点，可以参照之前的博客：关于CSS3呼吸效果的探究6.4 偏斜/歪斜 skew(x轴偏斜,y轴偏斜)以前见过很多用CSS3做的留言墙，skew属性用的比较多。1img:hover&#123;transform:skew(30deg,30deg)&#125;鉴于这个方法比较扭曲，就不上图了，值得注意的一点是，这个偏移量貌似根据tan来计算的，当我给这个方法传入90deg时，图片会不存在。6.5 矩阵/汇总方法 matrixmartrix()接受6个参数，其实就是对于 平移、旋转、缩放、偏斜的汇总简写。具体请参见张鑫旭大神的博客：理解CSS3 transform中的Matrix(矩阵)7. Css3之3D转换 ##（Oprea不支持3D转换）7.1 3D旋转 rotateY()1div:hover&#123;transform: rotateY(180deg)&#125;这里写图片描述框中的文字，其本身围绕Y轴旋转180°8.Transition 过渡效果兼容度：IE9及以下不支持该属性，需要优雅降级12div&#123;width:100px;height:100px;background:yellow;transition:width:width 2s;&#125;div:hover&#123;width:300px;&#125;效果如图（鼠标移入，DIV变宽，鼠标移出，自动复原）：鼠标移入，DIV变宽此时，我们在div:hover中重写了属性width，那么，在原始的div{transition}中，我们要说明，那个属性需要过渡效果，并注明过渡时间，此时肯定是transition:width 2s，如果有多个属性需要过渡效果，那么，就应该给出如下说明：1transition:all 2s //所有属性都需要过渡效果，并且所有效果同步过渡的总时长为2s.如此一来，就可以实现类似于jquery的效果：1$(&apos;div&apos;).animate(&#123;width:&apos;101px&apos;;height:&apos;101px&apos;;background:&apos;green&apos;;&#125;)这里写图片描述甚至可以规定过渡的delay延时：1transition-delay:0.5s; //0.5秒延时以后开始动画效果。效果与上图大同小异，不过有0.5s的移入和移出延时。其实，在transition里有4个属性，分别是：1.过渡的属性名称2.过渡的总时长3.过渡的方式:线性，缓慢等等4.过渡的延时，即多少s以后才开始过渡例如：123456div&#123; transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s;&#125;可以简写为：1div&#123;transition:width 2s linear 2s&#125;9.CSS3 动画之前一篇帖子对于动画部分做了一些探究：关于CSS3呼吸效果的探究如果对于动画的需求比较复杂，需要持续重复的完成，可以考虑动画效果，如果只是简单的一些效果，完全可以采用transform来自己实现。10.CSS 3 多列123456div&#123;-moz-column-count:3; /* Firefox */-webkit-column-count:3; /* Safari and Chrome */column-count:3;&#125;/*将一个DIV分为三列*/这里写图片描述以及最后的最后，有一个允许用户自定义元素大小(可拖拽拉伸)的属性12345678div&#123;border:2px solid;padding:10px 40px; width:300px;resize:both;overflow:auto;&#125;这里写图片描述觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS3呼吸效果的探究]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%85%B3%E4%BA%8ECSS3%E5%91%BC%E5%90%B8%E6%95%88%E6%9E%9C%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客一、效果预览这里写图片描述如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。二、方案选择刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。这个效果的实现，如果采用jquery的方案，直接写个动画即可。12//先设定好position:relative;$(&apos;img:hover&apos;).animate(&#123;&apos;left&apos;:&apos;10px&apos;,&apos;bottom&apos;:&apos;10px&apos;&#125;);假如追根溯源，还是使用的CSS3的动画。首先自定义一个动画：1234567@keyframes testAnimate&#123;from&#123;position: relative;bottom: 0;left: 0;&#125;to&#123;position: relative;bottom: 20px;left: 30px;border: 5px solid #999;&#125;&#125;这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。接着，我们在测试的图片用例上来引入动画：12345678img:hover&#123;animation:testAnimate 1s;-webkit-animation:testAnimate 1s;-moz-animation:testAnimate 1s;-o-animation:testAnimate 1s;-ms-animation:testAnimate 1s;&#125;//整个动画1s完成，并设置了浏览器兼容效果如下：这里写图片描述可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案：1234567img:hover&#123;animation-fill-mode: forwards;-ms-animation-fill-mode:forwards;//兼容IE xxxxxx -webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx-o-animation-fill-mode:forwards;//兼容opear xxxxxx&#125;这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。三、分析归纳众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5回顾总结]]></title>
    <url>%2F2018%2F01%2F12%2FHtml5%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客1.新标签1.1 &lt;vedio&gt;12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;Your browser does not support the video tag.&lt;/video&gt;两个video source源是为了最大程度的兼容所有浏览器，该标签IE8及以下不支持。比较重要的属性：123预加载 preload:preload自动播放 autoplay:autoplay循环播放 loop:loop常见的高大上的背景视频上嵌套文字的效果可以这样实现：12345678910111213141516171819202122&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; video&#123;z-index:-99999;float:left;position: relative;left:300px;&#125; h4&#123;color:white&#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;video width=&quot;320&quot; height=&quot;240&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt; &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/mp4&quot;&gt;Your browser does not support the video tag.&lt;/video&gt;&lt;div style=&quot;float:left;width:320px;height:240px;z-index:999&quot;&gt; &lt;h4&gt;震惊！野生棕熊竟然对猎物熟视无睹&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;给video给z-index：负数 ，给嵌套层的文字给 z-index：正数，然后相对定位，接着取消video 的controls属性，这样会隐藏音量条，播放/暂停按钮等控件。这里写图片描述类似于该网站的页头：英雄之刃官网在js中，可以把&lt;video&gt; 完全当做一个Dom节点，操作他的相关属性。例如：12345678910document.getElementById(&apos;video&apos;).pause()//暂停document.getElementById(&apos;video&apos;).play()//播放document.getElementById(&quot;video&quot;).currentSrc;//获得原始播放地址document.getElementById(&quot;video&quot;).currentTime//获得播放器当前播放位置，单位为sdocument.getElementById(&quot;video&quot;).duration //获得视频的整个播放时长......还有特别多的API，例 如 EVENT：刚开始播放、结束播放、视频的网络状态等等，甚至可以结合播放时间，来控制插入广告。。。1.2 audio与上述视频同理。兼容度更狭隘：IE9及以上1.3 拖放 Drag 和 drop兼容度：IE9、IE9+示例：W3C拖放示例1.4 Canvas“始于苹果的一项技术，使得Javascript具有图像绘制的能力”。123456789101112//HTML:&lt;canvas id=&quot;cvs&quot; height=&quot;200&quot; width=&quot;200&quot;&gt; 您的浏览器不支持&lt;canvas&gt;标签&lt;/canvas&gt;//JS:&lt;script type=&quot;text/javascript&quot;&gt;var c=document.getElementById(&quot;cvs&quot;); //获取var cxt=c.getContext(&quot;2d&quot;); //canvas对象特有的方法，目前仅仅支持到2D，未来可能会支持3D...cxt.fillStyle=&quot;green&quot;; //填充颜色 cxt.fillRect(0,0,150,75); //（x,y,width,height）绘制起始点坐标，绘制的宽高&lt;/script&gt;贴上自己做的demo这里写图片描述未完待续。。。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express快速构建应用(一)]]></title>
    <url>%2F2017%2F12%2F25%2FExpress%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客Express是基于Nodejs的前端应用构建工具，可以快速开发基于Node的前端SPA，在Nodejs的基础上，又进行一些功能的扩充，使得应用的构建流程非常简单高效，应用也足够健壮。1.安装与 环境配置首先使用IDE建一个工程目录，放在Nodejs.exe 的同域目录下。然后打开Git bash,输入，然后进入工程目录，接着 $npm init 表明我们要创建一个应用，最后疯狂回车，可以看到，在工程目录里自动生成了package.json文件。这里写图片描述接下来安装Express，命令行敲：$npm install express --save将express包存放到我们的工程目录里，甚至还可以将其在json文件中声明依赖关系，只需要多加一个-dev：1$npm install express --save-dev接着会看到工程目录里出现了modules子目录，并且已经为我们下载好了express及其依赖的包（看上图）。接下来，我们创建一个app.js，放在工程子目录，app.js代码如下：12345678910111213//app.jsvar express = require(&apos;express&apos;); //require进来我们的Expressvar app = express(); //实例化//匹配任意路由，都返回下面这句：first test successapp.get(&apos;/&apos;,function(req,res)&#123;res.send(&apos;first test success!&apos;);&#125;);//接着配置servervar server = app.listen(3000,function()&#123;console.log(&apos;绑定到了3000端口&apos;)&#125;);在命令行敲：$node app.js，打开浏览器输入127.0.0.1:3000 可以看到”first test success”这里写图片描述2.路由功能在进入一些网页的时候，会看到后面的url坠着 index.html，这是网站的homepage，如果去列表页，则后缀会变成: list.html，这个其实就是路由，根据请求的url不同，服务器返回不同的路径。而express可以很好的胜任这个功能。下面来看在刚才的app.js中加入一些代码，并创建新的index.html文件：1234567891011121314151617181920//app.js//使用get请求到index.html时，会向页面吐出一个index.html的文件app.get(&apos;/index.html&apos;,function(req,res)&#123; res.sendfile(&apos;./index.html&apos;) &#125;);//index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;gekki&lt;/h1&gt; &lt;h2&gt;hello&lt;/h2&gt; &lt;h3&gt;ke;llt&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt;接着，继续运行$node app.js，网页中输入URL：127.0.0.1:3000/index.html效果如图：这里写图片描述成功了！在命令行中，会提示这里写图片描述提示我们 : res.sendfile不太赞成使用，应该使用驼峰式命名 res.sendFile。。。粗心了。由上述例子可知，express对于路由的配置非常之简单。设想一下，在一些需要密码和表单操作密集的地方，可以采用post请求来进行路由的配置。那么同理，如果想要加载图片或者加载其他问价，则可以：123456789101112//表单的htmlapp.post(&apos;/form.html&apos;,function(req,res)&#123;res.sendFile(&apos;./form.html&apos;);&#125;);//访问路由的某个图片//all方法用于 匹配所有的请求类型，不管是post,get,put,delete等等都给他返回指定的东西，一视同仁。app.all(&apos;./longzhu.png&apos;,function(req,res)&#123; res.sendFile(&apos;./img/longzhu.png&apos;);&#125;);3.静态资源所谓的静态资源，就是一旦网页生成，就不会再被改变了。例如：图片，CSS,JS文件等。我们可以将这些文件放置在一个统一的文件夹里面，命名为：public这里写图片描述现在，在public下粘贴一张图片，接下来，我们来看这些静态资源应该如何配置以及访问：12//app.jsapp.use(express.static(&apos;./public&apos;));//一句话就完成了静态资源的配置接着，在浏览器中输入:127.0.0.1:3000/xxx.png ，我们可以得到效果：这里写图片描述说明静态资源配置成功，同理，我们在来试试其他类型的文件:这里写图片描述这里写图片描述都OK。有时候，可以在一个路由请求中写多个callback函数，来不断的匹配用户输入的需求路由：123//app.jsapp.get(&apos;/123.error&apos;,callback1,callback2);此时，如果第一个callback捕获不到路由，则将皮球提给第二个callback函数来执行，不过要在第一个callback中写明白参数:123456789function(req,res,next)&#123;console.log(&apos;对不起，我没找到，现在请下一个回调函数帮你找&apos;)next();&#125;,function (req,res)&#123;console.log(&apos;find it!&apos;);res.sendFile(&apos;123.error&apos;);&#125;整个回调函数甚至可以组成一个数组，来对用户的请求进行匹配：12345678910111213141516171819202122回调函数1: var a = function(req,res,next)&#123;....next();&#125;;回调函数2:var b = function(req,res,next)&#123;....next();&#125;;回调函数3:var b = function(req,res)&#123;....console.log(&apos;找到了!&apos;);&#125;;app.get(&apos;/123.error&apos;,[a,b,c]); //这样写很美观当然也可以使用数组和function(){}的混合写法，但是这样写我想不出来哪个地方有好处？在访问不同的路由时，不必从新restar server，因为服务器是在返回本地的目录，这个状态是一直轮询的，如果有就返回，没有就老老实实报错404 .当然，整个路由匹配的时候，甚至可以使用正则魔法，以防止用户的误输入行为，防患于未然。4.API走马观花1.res.download() 提示下载文件。 //res.download(‘文件名’)，2.res.end() 终结响应处理流程。3.res.json() 发送一个 JSON 格式的响应。4.res.jsonp() 发送一个支持 JSONP 的 JSON 格式的响应。5.res.redirect() 重定向请求。 //更改用于在根url之后的路由，例如用户输入了:127.0.0.1:3000/index.html我们可以res.redirect(&#39;error.html&#39;);，此时浏览器的url会自动变成：127.0.0.1:3000/error.html6.res.render() 渲染视图模板。7.res.send() 发送各种类型的响应。8.res.sendFile 以八位字节流的形式发送文件。9.res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。//express预设好了，我就试了两个:res.sendStatus(200)//页面显示：OK1res.sendStatus(404)//页面显示：Not Found留坑。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular1.4.6 & Bootstrap3.3.7搭建后台人员管理系统 1.0.0]]></title>
    <url>%2F2017%2F12%2F19%2FAngular1-4-6-Bootstrap3-3-7%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-1-0-0%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客前言：接触前端快1满一年了，从什么都不会，一步步摸索，走到现在，觉得前方的路还是很迷茫，但是每天感觉自己都在进步，这是最好的！希望自己能坚持下去，也跟各位同仁共勉！1234567@important message!&#123; &quot;name&quot;:&quot;Manage-system-By-AngularJs&quot;, &quot;version&quot;:&quot;1.0.0&quot;, &quot;author&quot;:&quot;ZQ-jhon&quot;, &quot;connect&quot;:&quot;QQ:350037310&quot;&#125;直接上全部效果的演示图：Let’s view together:GIF加载中，请耐心等待... ...1.Angualr和Bootstrap的火花Angular是开发SPA的得力框架，其数据双向绑定和指令系统能够最大程度的保持页面的整洁干净，而Bootstrap作为一个UI库，也能够很好的满足本系统的需求。2.思路2.1 在后台人员管理系统中，需要有以下功能：增、删、改、查。为了实现这些功能，就必须在项目中留好数据接口，方便跟后台数据进行I/O操作。2.2 为了实现部分功能的 toggle()，例如：点击编辑，文本框的可编辑状态会来回在: 可编辑/不可编辑 切换。点击编辑，删除button的 show 与 hidden。必须使用一个ng-show = bool/ng-disabled = !bool，bool的具体方法每次访问，会更改布尔值为对立值：12345678910//初始化:$scope.bool = true;//调用改变自身布尔值$scope.toggle = function()&#123; $scope.bool = !$scope.bool; //谁调谁改变 &#125;而这个$scope的bool()方法，应该位于$rootscope是最好的解决方式，所有的局部controller都可以访问到根作用域。因此，改写如下：123456$rootscope.toggle = function()&#123; $rootscope.bool = !$scope.bool; //谁调谁改变 &#125;3.实现3.1 框架搭建 ：使用bootstrap搭建框架3.2 初始数据展示：为了让用户有一个直观的展示，当前界面上会mock一些假的数据上去，仅供参考(当然这些数据也可以删除)，mock的方法为，在$scope上绑定一个数组，该数组是对象数组，然后用过ng-repeat来展现在我们的bootstrap表格中。3.3 框架代码：123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;h1 class=&quot;text-center&quot;&gt;增删改查后台管理系统&lt;/h1&gt; &lt;table class=&quot;table table-responsive table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;职务&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot;&gt;编辑&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;button class=&quot;btn btn-success&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/i&gt;创建新用户&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;3.4 ng指令系统的控制原理与规划过程3.4.1 指令构建首先在表格上声明 `ng-app =&quot;myapp&quot;` 并且声明控制器`ng-controller=&quot;ctrl&quot;` 接着，在需要toggle切换的地方赋值，如果默认要false,可以使用 ng-show=&quot;!bool&quot;或者 ng-disabled=&quot;bool&quot; 这里因为初始值是： `$scope.bool = true` 然后，在$scope上绑定初始数据，即一个对象组：1234567891011 var app=angular.module(&apos;myApp&apos;,[]);app.controller(&apos;ctrl&apos;,function($scope)&#123; $scope.users = [ &#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;, &#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;, &#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;, &#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;, &#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;, &#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125; ];有了元数据，就可以为所欲为了，在需要的位置，例如 table 中的 tr 进行ng - repeat循环，循环的结果是对象数组中每一个对象！然后在对应的&lt;td&gt;&lt;/td&gt;中使用或者balalala进行取值为了完成自动化序号排列以及删除功能，需要$index服务，不需要依赖注入。当每个删除按钮点击的一瞬间，Angular如何判断该删除哪个呢？ 我们为每一个删除按钮button添加一个指令 `ng-click = &apos;remove($index)&apos;` 这里，Angular就是通过$index来自行判定当前的行序。来看这一块的代码：1234567891011121314151617181920&lt;tr ng-repeat=&quot;user in users&quot;&gt; &lt;td&gt; &lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot; ng-click=&quot;toggle()&quot;&gt;编辑&lt;/span&gt; &lt;/td&gt; &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.name&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.age&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.job&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;button class=&quot;btn btn-danger&quot; ng-click=&quot;remove($index)&quot; ng-show=&quot;!bool&quot;&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;OK，删除，排序，Toggle功能都完成了，还有一个增加新用户怎么完成呢？这个更简单了，直接往Object Array 里 push 对象即可：1234567891011/****这是增加用户按钮的指令*****/ng-click = &quot;addUser()&quot;/*****以下是js*****/ $scope.addUser = function()&#123; var index = $scope.users.length-1; //确定当前最大的行序（ps.本来想自己实现 $index 功能的。。。） $scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;); &#125;以上，就完成了一个后台管理系统，这是初始版本，后续我会增加新的功能在里面。4.初步完成alpha版本，觉得还是有很多不足之处：1.数据很糙，很杂，controller中的东西太过冗杂，而我并没有选择使用构建工具来模块化、打包、合并，这不是一个好习惯。2.所有的输入框没有加入过滤器，例如：姓名的位置我们可以用filter或者正则来强行限定只能输英文，而不是数字或者标点。 这是一个细节不够完善的地方。3.在点下编辑的时候，文本框变得可以编辑，再次点下编辑，文本框变成了丑丑的不可编辑，我在想：**如何可以使得文字在不可编辑的状态下自动切换为&lt;p&gt;标签，而在可编辑的状态下变成&lt;input&gt;表单？**4.自学了这么久ajax,nodejs，然而并没有从后端拉任何数据，所有数据都是angular来进行操作的，这样也不好，我希望尽快精通express，来进行项目的全栈构建。以上问题留给自己去解决。最后，附上我的Github地址，fork 或者 download都可以地址：https://github.com/ZQ-jhon/Manage-system-By-AngularJs注意：将 index.html中的1&lt;script&gt;以及&lt;link&gt;的src 及 href 替换 成本地目录觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于jQuery中scrollTop中的一些兼容问题。]]></title>
    <url>%2F2017%2F12%2F13%2F%E5%85%B3%E4%BA%8EjQuery%E4%B8%ADscrollTop%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客最近在做一个响应式的页面，需要有按钮来实现点击回到页头及点击回到页尾的功能。在使用1234567$(&apos;#btn&apos;).click(function()&#123; $(body).animate(&#123; scrollTop:0 &#125;,speed);&#125;);//发现，该功能只在IE与FireFox下有用，Chrome内核无效。这里写图片描述即：选择器为body时：FireFox无效，Chrome有效选择器为html时：Chrome有效，FireFox无效因此，在编写代码的时候，只要进行双重选择即可兼容：1234567$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123; var speed = 400; //滑动的速度 $(&apos;html,body&apos;).animate(&#123; scrollTop: 0 &#125;, speed); return false; &#125;);经测试，在IE(9及以上),FireFox及Chome浏览器下，均能正常使用该功能。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs基础配置、核心概念与学习路线回顾]]></title>
    <url>%2F2017%2F12%2F12%2FNodeJs%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客Nodejs把前端开发带入一个全新的阶段，他使得js能够跑在服务端上，大大强化了js这门语言的可塑性。OK，环境配置不提，配置好了以后，直接来跑一些简单的demo以前一直没搞懂nodejs复杂的目录（其实是不懂linux），老把文件目录和运行时的目录搞错。在gitbash下，先进入对应的目录，例如我的js文件在 D:\node\nodejs下，那么应该：12$ cd d:$ cd node/nodejs这样就OK啦，如果想跟IDE进行配合也不是不行，步骤如下：1.在node.exe同级下建立project，命名为 nodejs ：这里写图片描述2.在IDE中添加新建项目，添加刚才的文件夹路径：这里写图片描述欧~~尅！接着，在IDE里面新建几个js文件，然后在我们的Node上面跑一跑(CreateServer那个DEMO就不做了)。建立第一个文件:hello.js （null文件）建立第二个文件:world.js（null文件）两个文件可以在同级目录，也可以不在。将下列代码填入hello.js：1234function hello()&#123; console.log(&quot;hello&quot;)&#125;exports.hello =hello();打开gitBash,找到IDE中工程的目录(最好把js文件放在工程目录下即可，或者单独建一个js文件夹)：然后输入：$ node hello.js这里写图片描述然后将下列代码填入 world.js :12var world = require(&quot;./hello.js&quot;);world.hello运行之，得出下图：这里写图片描述可以看到，两次的运行结果一样。hello.js的运行结果为hello不足为奇，那么world.js为什么也输出hello呢？这是因为在hello.js中，打包出来一个公共模块，exports.hello =function(){....}而在world.js中，引入了这个模块，并且赋值给变量world:123456789var world = require(&apos;./hello.js&apos;) /*引入【hello.js里面打包的模块】*//*此时，world相当于拥有共有模块的所有属性和方法了，那么此时，这个world有一个方法为hello,我们调用这个hello方法，world.hello ，自然而然输出hello*/如果将hello.js改进一下，12345var i=0 ; function hello()&#123;++i;console.log(&quot;hello for &quot; + i)&#125;;运行 node hello.js 输出: //hello for 1同时更改world.js:1234var world = require(&apos;./hello.js&apos;)var world1 = require(&apos;./hello.js&apos;)world.helloworld1.hello运行 $node world.js 输出//hello for 1甭管运行几次，都是这个结果这说明，引入模块时，只有第一次引入时会初始化模块。模块的集合：包(package)所谓的包，就是内部集成了好多模块，主要使用一个入口文件作为包的入口，该文件的导出对象作为包的公有模块：1234567一 ---nodejs|一 ----js | -----main.js | ------head.js | ------body.js | ------footer.js|一 ------package.json此时，main.js是包的入口和导出对象模块，在main.js中，很有可能引入了head.js、body.js、footer.js的导出模块，然后写入一些功能和方法，最后导出一个公有方法，供其他的包或者模块使用。当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。当引用包的入口文件时，require(‘./node/nodejs/main.js’)这样给人感觉仿佛在引用一个模块，而不是整个包。解决方法是，将Main.js命名为index.js，这样，在引入包的入口文件时，直接填写包入口文件的路径：1234var cat = require(&apos;./js/index.js&apos;);var cat = require(&apos;/js&apos;);//上面两条语句等价这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。也可以用json文件来声明入口：123｛ &apos;main&apos;:&apos;./main.js&apos;｝这样，在引入包的入口文件时 require(‘./node/nodejs’)时，会优先查找json文件，并从中读取入口配置，注意，此时的json一定要在引用的路径之下。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax回顾]]></title>
    <url>%2F2017%2F12%2F12%2Fajax%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客jq与原生以及angular中的ajax（长文）http://blog.csdn.net/qq_20264891/article/details/78457021上面是之前写的一篇关于ajax的帖子，里面的集成包xampp的配置方法有点不太科学，虽然这样可以运行，但感觉不是很美滋滋。感谢新浪博主@期待下一站幸福具体参考原文地址：http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html配置外部服务器，运行后端代码php？对于完全是小白的我而言，实在是想都不敢想。因为得学习Ajax，就必须得给服务器的发送请求和等待服务器响。所以就在老师的带领下，开始了服务器的配置。首先介绍一下，我用的IDE:​HBuilder. 后端语言是php。我使用的是模拟服务器的软件：XAMPP​(下载地址：https://www.apachefriends.org/download.html)然后说一下，我要做什么样的效果：让一个PHP文件在本地服务器上运行。（对！就是这么简单，我捣鼓了一个多小时…）​好了，接下来我们来看看吧。​1,安装一个模拟的服务器。如果你和我一样，没有任何的​Apache，MySQL，tomcat等WEB服务器。那就下载一个XAMPP.【好用于部署一个本地服务器】​安装完成后，打开的界面是这样子的：这里写图片描述我们可以先点击“start”启动，这时候需要注意的是：可能出现错误。【错误是：端口被占用】。引用块内容解决方法是：点击config–进入Apache（httpd.conf）–找到listen（监听的端口号）进行修改。如图：这里写图片描述好了，可以重新启动Apache啦。2.打开HBuilder，然后新建一个项目。注意：新建的项目—一定要在我们刚刚打开的XMAPP安装目录下的​htdocs文件夹下面。（不要问为啥，这是我一晚上调试出来的经验）​这里写图片描述在安装目录下的htdocs，新建文件3.在HBuilder中的快捷工具栏中找到【浏览器】，打开它的下拉菜单，点击【设置web服务器】。进入页面点击”外置web服务器“​–选择”新建“这里写图片描述这里写图片描述添加本地服务器4.把你写的PHP文件可以在浏览器中，打开了。这是我的源文件：这里写图片描述这里写图片描述OK,接下来才是正文：一、javaScript原生Ajax1.浏览器自带的与服务器交互的对象及附带API该对象是一个全局对象，即位于window对象下。IE与非IE，该对象不同非IE &amp;&amp; IE7+ : XMLHttpRequestIE5,IE6: ActiveXObject2.兼容创建大法123456789101112var xhr=null;//初始化变量if(window.XMLHttpRequest)&#123;//非IE&amp;&amp;IE7+xhr = new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123;xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//不同的IE版本，里面写的东西不一样，具体请自行baidu&#125;3.创建好之后的后续步骤xhr.open() //该方法用于 创建 连接服务端的请求。xhr.send(); //所有的事情完毕，正式发送请求。注意：xhr.open(method,url,async) 请求方式，请求地址，是否异步？(ps:默认为true,异步执行)设置好open中的传参，接着执行xhr.send()。4.如何知道请求与相应成功不成功？？这里，xhr对象自带 一个方法，用来检测连接是否成功，以及对xhr创建过程进行监听，为什么这样说呢？直接看代码：123456789101112131415 xhr.onreadystatechange=function()&#123; if(xhr.readyState=4&amp;&amp;xhr.status==200)&#123; document.getElementById(&apos;box&apos;).innerHTML = xhr.responseText; &#125; &#125;***************上面界定了，请求成功以后，将响应的内容放在我们的box盒子里******** xhr.open(&quot;GET&quot;,&quot;01.php?a=5&amp;b=1&quot;,true);//传参a=5,b=1 xhr.send(); //因为上面的方法是异步执行的，因此不用纠结，xhr.open()和send()的位置。&#125;运行结果:这里写图片描述附上php的代码：123&lt;?phpecho &quot;a为&#123;$_GET[&apos;a&apos;]&#125;,那么b为&#123;$_GET[&apos;b&apos;]&#125;&quot; ?&gt;这里php代码看不懂的话， 可以去http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP 的基本语法。作为一个前端，后端语言要了解其接口和语法，这是最起码的(这个B装的66666)。说好的监听xhr对象的创建过程呢？123456xhr.onreadystatechange = function()&#123;//这里加上一句话 :console.log(&quot;当前的XMLHttpRequest对象的创建进度为&quot;+xhr.readyState)...... &#125;来看打印结果:这里写图片描述可见，每次xhr对象自身状态值改变，都会调用函数，因此导致我们打印的结果发生变化。 由此可得，ajax的创建是分步进行的，查询资料可得：0 对象未创建1 已与服务器连接2 服务器已经接受请求3 服务器正在处理请求4 服务器将请求下发同时，status也需要有响应的返回值，从服务器传递回来，有个状态值(xhr.status)：如果响应成功，就返回200如果没找到，返回404其他还有403,5系列等等，不再赘述。二、jQuery中的ajax1.load方法1234567891011121314151617181920兹有按钮与容器各一个：&lt;input type=&quot;button&quot; value=&quot;点我加载&quot; id=&quot;btn&quot;/&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;//js如下 &lt;script type=&quot;text/javascript&quot;&gt; $(&apos;#btn&apos;).click(function()&#123; $(&apos;#box&apos;).load(&apos;03.php&apos;) &lt;/script&gt; //php如下&lt;?phpecho &quot;hello,world!&lt;br/&gt;a = &#123;$_POST[&apos;a&apos;]&#125;&lt;br/&gt;b = &#123;$_POST[&apos;b&apos;]&#125;&quot;?&gt;这里，点击按钮，box载入响应值，这个方法是get方法。如图：这里写图片描述如果，在load()多传一个json对象:1234$(&apos;#box&apos;).load(&apos;03.php&apos;,&#123; a:5, b:1 &#125;)那么这个请求会自动 变成post请求。这里写图片描述在 Ajax数据载入完毕之后，就能执行回调函数 callback，也就是第三个参数。回调函数也可以传递三个可选参数：responseText（请求返回）、textStatus（请求状态)、XMLHttpRequest对象。123456789$(&apos;#btn&apos;).click(function () &#123; $(&apos;#box&apos;).load(&apos;03.php&apos;, &#123; a:5, b:1 &#125;, function (response, status, xhr) &#123; alert(&apos;返回的值为：&apos; + response + &apos;，状态为：&apos; + status + &apos;， 状态是：&apos; + xhr.statusText); &#125;);&#125;);运行结果：这里写图片描述这里的status和xhr.statusText都是经过jQuery进行处理的，原本的值应该对应为：2002.$.get()和$.post().load()方法是局部方法，因为他需要一个包含元素的 jQuery对象作为前缀。而$.get()和$.post()是全局方法，无须指定某个元素。对于用途而言，.load()适合做静态文件的异步获取，而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。123456$(&apos;#btn&apos;).click($.get(url,&#123;json.data&#125;,callback(),type)&#123;&#125;)/*GET方法与load()方法相比，多了最后一个参数，返回类型，可以设置为xml,html,json,text等，一般不需要设置，都是jQuery智能判断返回的。第一个参数：请求地址，是必须的，后面的都是可选参数。*/$.post()方法的使用和$.get()基本上一致，他们之间的区别也比较隐晦，基本都是背后的不同，在用户使用上体现不出。具体区别如下：1.GET请求是通过 URL提交的，而 POST请求则是 HTTP消息实体提交的；2.GET提交有大小限制（2KB），而 POST方式不受限制；3.GET方式会被缓存下来，可能有安全性问题，而 POST没有这个问题；4.GET方式通过$_GET[]获取，POST方式通过$_POST[]获取。3.load(),$.get(),$.post() 的集合：$.ajax12345678910111213//ajax是jQuery封装的最底层的方法 $(&apos;btn[submit]&apos;)[0].click(function()&#123; $.ajax(&#123; type:&quot;get&quot;, //请求方式 url:&quot;02.php&quot;, //地址 async:true, //异步 success:function(response,status,xhr)&#123;alert(response)&#125;, //成功回调函数 error:function()&#123;&#125;,//失败回调 data:$(&apos;form&apos;).serialize()//表单序列化 &#125;); &#125;)三、AngularJs中的ajax1234567891011121314151617181920212223在任一一个控制器中注入http依赖var app = angular.module(&apos;myApp&apos;,[]);//http模块注入到任一一个控制器中app.controller(&apos;ctrl1&apos;,function($scope,$http)&#123;$http(&#123; method: &apos;GET&apos;, //选择请求方式 url: &apos;02.php&apos; //请求地址 &#125;).then(function successCallback(response) &#123; // 请求成功执行代码 &#125;, function errorCallback(response) &#123; // 请求失败执行代码//语法为：$http.then(success(),fail())&#125;);声明：v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代。因此千万不要1$http.success().error()//错误写法！z不能跟jQuery混淆总结：Js/jq/angularjs 中ajax的：相同点1.都是异步的请求，都支持get,post方法,jq,angular支持(put)。不同点：1.jq中，对于ajax请求的写法非常简单，非常直观。angular中，通过$http模块也进行相应的封装，非常方便。2.普通的javaScript AJAX请求，如果需要GET方法传参，只能强行用”？”追加到url后面，并且不同参数连接要用&amp;进行，非常繁琐。3.所谓jq的success(),error()，以及angular的then方法，都是对原生ajax的status的不同返回值进行封装,例如：200就会执行success函数，404就执行error函数。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git与GitHub之远程仓库]]></title>
    <url>%2F2017%2F12%2F11%2FGit%E4%B8%8EGitHub%E4%B9%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客在GitHub上创建一个repository。1.首先，生成私钥和公钥：$ ssh-keygen -t rsa -C “350037310@qq.com“ (最好填写gitHub的注册邮箱)这里有个关键的地方：SSH，待会会用到。这里写图片描述2.将本地的Git关联到GitHub在本地命令行中：git remote add origin git@github.com:ZQ-jhon/test.git即可关联远程仓库(这里的git@github.com对应上图。)狂敲回车，然后在C：/Administrator下会生成一个.ssh文件夹，找到里面_pub的文件，记事本打开，全部ctrl+c，来到:gitHub—–&gt;Settings——&gt;SSH and GPG keys ,点New SSH Key ，title随便取个名字，底下内容粘贴刚才复制的_pub文件，OK。OK，至此，两个库已经关联起来了。关联的GitHub项目库仅仅是名为test的这个库。3.将本地库推到GitHub中。$ git push -u origin master4.提示信息第一次关联推送时，提示：123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?输入yes，回车，OK，现在远程仓库和本地仓目录一摸一样了。以后每次推送，只需要$git push origin master就行。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git与GitHub之本地仓库]]></title>
    <url>%2F2017%2F12%2F11%2FGit%E4%B8%8EGitHub%E4%B9%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客马上就要到年底了，再复习一下Git的相关知识，还有20天，再拼拼命！概念Git:分布式版本管理系统。GitHub:全球最大同性交友平台。(匿)1.本地的版本库1.1环境搭建首先确保已经安装了Nodejs的环境。首先，下载GitBash命令工具。https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit运行之。命令行中敲入1234$cd g:$mkdir git$cd gitg盘下创建git目录，并且进入该目录1.2 建仓库1.创建本地仓库1$git init //创建OK，g:\目录下多了一个 .git的文件夹然后，在桌面上手动新建一个test.txt文本，里面输入 “hllo,world”，然后将该文本放到git目录下(就是刚才创建的那个目录)这里写图片描述2.现在，将文件读取至工作区1$ git add test.txt这样，就完成了工作流的初步设置3.对txt文件暗中做手脚在test.txt文件中，将”hello,world”改为”hey,boy”，然后ctrl+s，ctrl+F4二连。4.再次commit至暂存区再次提交至暂存区（如果不再次提交，那么刚才的改变只是在仓库里改变了，而并非在我们的暂存区进行记录。）1$ git add test.txt5.然后读取暂存区文件的状态：1$ git status6.接着上传到本地版本库:123$git commit -m &quot;first change&quot; //回车***************注意:!!!每次commit都会生成一个版本******OK,这样，系统就记录下了这次改变。当然也可以随时$git status ，来查看当前的暂存区是否干净 (clean)。7.要查看历次的修改记录，或者回滚到任一一个版本，可以:12$git log或者$git reflog //reflog可以显示每次迭代的文件值，并进行排序如果想要项目升级或降级到某一个版本，可以这样：1$git reflog //查看变更记录，与对应的入口文件值(自动生成)想去哪里就去那里：123$git reset --hard &quot;对应的文件入口，例如35s421&quot;/*这里的入口文件值，可以写5位，4位甚至更少，因为计算机会自动根据名字来遍历检索，因此为了效率和不必要的麻烦，尽量写7位左右。*/8.撤销修改改到一半发现还不如不改？如果没有commit，那么可以使用“一键还原”123$git checkout --test.txt//这会使test.txt回到版本库中的状态，即：还没有bei $git add test.txt的时候如果已经commit了，那么只能回到最后一次commit的状态。123$git rm test.txt //做完测试，顺手清理觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP初体验]]></title>
    <url>%2F2017%2F12%2F09%2FPHP%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客1.连接符1234567$color = &apos;red&apos;第一种连接方式: echo &quot;my color is $color&quot;第二种连接方式: echo &quot;my color is&quot;. $color .&quot;&lt;br&gt;&quot;//（VB是&amp;链接，js+链接，这个.链接真的反人类）第三种连接方式: echo&quot;my colo is&#123;$color&#125;&quot;//花括号包住变量第四种连接方式(相当于js字符串的+=):$a=&quot;hello&quot;;echo $a.=&quot;world&quot;; //hello,world2.变量Scope1.全局作用域定义的变量只能在全局读取，函数内部都无法读取。2.局部作用域定义的变量只能在局部读取，全局无法读取。（js的变量是：父域的变量可以让子域读取，反过来则不能。）如果局部子域想要访问Global变量，则需要提前声明：爸爸，我要用你的变量：12345678$a = 5;function son()&#123;global $a ;$b = 1;return a+b&#125;son();//6更或通过所有全局变量的数组来访问全局变量，因此上述的表达式1global $a等价于： $GLOBAL[&apos;a&apos;] (下标注意，有引号)如果想要局部变量的函数在函数执行完成以后不被销毁，即继续在全局域下使用，那么应该提前声明static(静态的)关键字：12345678910111213&lt;?phpfunction myTest() &#123; static $x=2; echo &quot;结果是:$x&quot;; $x=$x*$x;&#125;myTest();//2myTest();//4myTest();//16?&gt;3.常量(真·全局量)相当于全局的变量，但是值不可更改或者撤销定义定义方法：define(name,value,bool)，参数很简单，关键在第三个参数，对大小写不敏感吗？默认flase，对大小写敏感，如果强行设置第三个参数为true,则对常量名字大小写不敏感。4.运算符+，-，*，/，% ,==,=== 大同小异。唯一和js不同的是，不等于可以写成 &lt;&gt;，啊哈哈，和vb有点像5.超全局变量PHP 超全局变量1$_GET 和 $_POST用于收集表单数据（form-data）。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记3]]></title>
    <url>%2F2017%2F12%2F05%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客eg13.依赖注入故事要从js说起，在js的function(){}中，参数可以传递为另外一个函数。举个例子：1234567891011121314151617function first()&#123; return 3&#125;//参数函数1function second()&#123; return 5 &#125;//参数函数2function add(a,b)&#123; var a_ = a(); var b_= b(); alert(a_+b_)&#125;//总函数add(first,second);//调用总函数，其参数为first和second的返回值，弹出 8不光如此，在回调函数中，大致也是这样的思路：12345678function callback(result)&#123; console.log(&quot;您的计算结果为:&quot;+result)&#125;function fn(num,callback)&#123; num = num*num callback(num);&#125;fn(10,callback);//控制台：您的计算结果为100简短回忆后，发现javaScript函数的特点，函数定义时的参数个数是定死的，但是如果传入的参数不达标/超出/太少，那么函数体就会报错。例如上面的add(first,second)只传入add(first)就会报错：b is not a function普通函数的参数往往是由调用它的人时候来决定的回到angular中，依赖注入与javaScript函数正好相反，函数体一旦定义了参数，调用它的人就得老老实实的传入指定数量/类型的参数。for eg1:123456&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;c&apos;,function()&#123; alert(arguments.length);//这里打印出0，因为没参数，这个OK，接着往下看 &#125;);&lt;/script&gt;12345678 &lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;c&apos;,function(s,b)&#123; alert(arguments.length); &#125;); &lt;/script&gt;这里我们发现，虽然传入了s,b两个参数，但是压根连弹窗都没有，只能说明，传入的参数不合法，函数不认。1234567for eg3:&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;c&apos;,function()&#123; alert(arguments.length); &#125;);&lt;/script&gt;`觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax初探]]></title>
    <url>%2F2017%2F11%2F06%2FAjax%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客Ajax初探1.环境搭建与配置这两天在捣鼓Ajax,期初用的都是开发工具自己集成的apache服务器，但是因为我太蠢，找不到相关的设置项和说明，又或者是我懒得找把，于是搜了一款数据库和Apache服务器集成好的本地站点包：【XAMPP】，百度下载好，按照相关说明进行配置。2.基本设置与文件索引目录这里写图片描述如图所示，只需要将Apache与MySQL打钩，并且star，就OK。打开浏览器，输入站点ip与端口（默认是127.0.0.1）然后在安装目录下的,安装盘:\xampp\htdocs 看到有个.html的文件，该就是刚才在浏览器中看到的。可以将这个.html的文件删除，刷新浏览器，可以直接看到浏览器中的目录索引。这里写图片描述现在网页上127.0.0.1的目录就是文件库中的映射。以后我们可以将服务器端需要响应的asp/php/txt文件，都放在 安装盘:\xampp\htdocs下即可，环境搭建完成。3.喜闻乐见敲代码环节3.1 javascript原生Ajax所谓Ajax： A:async 异步加载 ja: javascript 脚本语言 x:xml 前后台通信的数据载体，文本 （鉴与json的出现，XML正在被逐渐取代，大有&quot;Ajaj&quot;的趋势） 3.2 目的目的是为了提高用户体验，更新局部数据时不用刷新整个网页，就可以完成数据交互。3.3 对象(API)1. 在IE7+/Chrome/Opera/Safari 中，对象为XMLHttpRequest，该对象属于window下的子对象;创建方法为1var xhr = new XMLHttpRequest;2.在IE7以下， 对象为ActiveXObject,该对象属于window下的子对象;创建方法为12var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);//括号中的必须有。3.4 浏览器兼容判断12345678910 var xhr =; //var 一个空对象 if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest; &#125; //非IE7以下 else if(window.ActiveXObject)&#123;xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125;//IE7以下else&#123;alert(&quot;您的浏览器过于先进，请降级到合适的版本！&quot;)&#125;3.5 方法这个xhr对象，自带了一些方法。1.open（规定请求的类型，地址，是否异步）方法1xhr.open(method,url,async)2.send(string)方法，用于发送请求该方法中的string，只要在method=”post”时，才可以使用。3.当method==true,那么要设定就绪时执行的函数，跟回调函数有点像:先说两个属性：(1)xhr.responseText //······························· 返回字符串形式的相应数据(2)xhr.responseXML //································ 返回XML形式的相应数据1234567891011xhr.onreadystateChange=function&#123;if(xhr.readystate==4&amp;&amp;xhr.status==200)&#123; //这里写下要回调的方法 document.getElementById(&apos;div&apos;).innerHTML=xhr.responseText; //获取返回的文本，这里也可以写xhr.responseXML &#125;&#125;xhr.open(&apos;get&apos;,&apos;123.php&apos;,true);xhr.send();OK,这是默认的异步处理，要执行一个就绪时的函数。那么，在同步模式下，即async=false时，应该这么写请求：xhr.open(“GET”,”/try/ajax/ajax_info.txt”,false);xh.send();document.getElementById(“Div”).innerHTML=xhr.responseText;3.6 onreadystatechange 存储函数onreadystatechange 存储着xhr的好几种状态：0：初始化未就绪 (想找老板要工资，但没准备好)1：已经与服务器连接 （已经走进老板办公室）2：服务器已经接受（老板已经听到你的诉求）3：正在处理请求（老板在苦思冥想给不给你钱）4：请求已经完成，并且响应也已经下发（想了半天给你了）每当 readyState 改变时，就会触发 onreadystatechange 事件。同时，status也需要有响应的返回值，从服务器传递回来，有两个值：200 响应就绪，成功下发（会计接到老板的电话，立马爽快的给了你工资）404 未找到 （会计跑路了，尽管老板同意，你还是没拿到钱）觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于百度集成API bd_share的一些窥探]]></title>
    <url>%2F2017%2F11%2F03%2F%E5%85%B3%E4%BA%8E%E7%99%BE%E5%BA%A6%E9%9B%86%E6%88%90API-bd-share%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AA%A5%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客最近在做一个项目因为要用bootstrap，需要对第三方分享的图标设计两个款式，最终需求的效果如下：一、需求分析1.在PC端，要求用font字符来实现第三方分享的图标,并且鼠标经过时，设定hover效果：这里写图片描述2.在小屏幕设备上，需要设定另外一种款式：这里写图片描述二、思路分析理清需求以后，下面来看是如何实现的：首先，需要点击这些第三方应用的图片或者字符，来实现相应的跳转，例如点击QQ，进入QQ的分享界面。如果要完成这一步，需要去每个平台的官网获取分享组件，其实就是人家官方定义好的js API接口。整个页面如果只需要1个2个分享图标还好，要是十几个，20个图标，估计页面会乱七八糟自己看着都糟心。于是这里安利百度share，集成了大多数的第三方share API,非常的方便，省事，复制，粘贴，一气呵成，但是效果可能就不尽人意了。看到这里，我以为我打开了二零零年的一张网页，真的，这图标，这32*32的icon清晰度，真的让我很难受。首先推荐一几个icon库，这些icon非常精美，并且实时更新：1.阿里妈妈icon库：http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&amp;manage_type=myicons&amp;icontype=histories&amp;keyword=2.Easyiconhttp://www.easyicon.net/在这里可以下载相应的icon，推荐下载SVG，这个格式的图片制作字体很方便。看一下百度官方的代码12345678910111213141516171819202122232425262728293031&lt;div class=&quot;bdsharebuttonbox&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_tqq&quot; data-cmd=&quot;tqq&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_renren&quot; data-cmd=&quot;renren&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;script&gt; window._bd_share_config = &#123; &quot;common&quot;: &#123; &quot;bdSnsKey&quot;: &#123;&#125;, &quot;bdText&quot;: &quot;&quot;, &quot;bdMini&quot;: &quot;2&quot;, &quot;bdPic&quot;: &quot;&quot;, &quot;bdStyle&quot;: &quot;0&quot;, &quot;bdSize&quot;: &quot;16&quot; &#125;, &quot;share&quot;: &#123;&#125;, &quot;image&quot;: &#123; &quot;viewList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;], &quot;viewText&quot;: &quot;分享到：&quot;, &quot;viewSize&quot;: &quot;16&quot; &#125;, &quot;selectShare&quot;: &#123; &quot;bdContainerClass&quot;: null, &quot;bdSelectMiniList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;] &#125; &#125;; with(document) 0[(getElementsByTagName(&apos;head&apos;)[0] || body).appendChild(createElement(&apos;script&apos;)).src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5)];&lt;/script&gt;不难发现，其实a标签的父div：bdsharebuttonbox已经提前为a标签设置好了样式和背景图了。这里我们下载好图标，能否直接插入到&lt;a&gt; 标签中，然后 实现对应图片的替换呢？显然不行，因为百度通过class类设定好的背景图片，不会被框架内的图片所覆盖，给大家演示一下错误的示范：这是错误的示范不仅没有变美，反而更丑了。三、功能实现3.1 将原始图标替换为图片图标怎么办呢？其实我们应该直接设定对应class类的背景图，并且加权!important，就可以完美实现背景图的替换了。12.bd_qzone&#123;background:url(./img/qq.png) !important&#125;.bd_tsina&#123;background:url(./img/sina.png) !important&#125;这里要说明一下，百度的Share api第三方的图标，全部都是32*32的，因此如果你的图片过于清晰（分辨率太高），应该增加backgrond-size:cover !important ，来填充。12.bd_qzone&#123;background:url(./img/qq.png) !important;backgrond-size:cover !important &#125;.bd_tsina&#123;background:url(./img/sina.png) !important;backgrond-size:cover !important &#125;这样，可以实现一个比较好看的图标分享小模块了：这里写图片描述这里我用的图标是128*128的，即便将网页放大10倍，也没有锯齿感。3.2字符图标完成Share 功能的实现字符图标相比于图片图标，更加节省资源，而且兼容性更棒！(IE4+都支持字符图标)。我们首先去阿里妈妈或者easyicon下载好对应的透明的svg文件，接着到：https://icomoon.io/app/#/select这个网站很牛逼，可以将图片转为各种浏览器看得懂的字符文件(1)我们打开网站，最上方点击import Icons，上传自己的图标图片文件这里写图片描述(2)上传好以后， 可以按铅笔图标对文件进行编辑，比如命名，方向结构等等这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述（3）上传好以后，点击下面的Generate Font,下载已经转换好的字体文件（4）下载好以后解压，用记事本打开style.css的文件，复制到你的html页面中的1![这里写图片描述](http://img.blog.csdn.net/20171103180119963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)复制好如下： @font-face{ font-family:‘icomoon’; src:url(‘fonts/icomoon.eot?eqsiuf’); src:url(‘fonts/icomoon.eot?eqsiuf#iefix’) format(‘embedded-opentype’), url(‘fonts/icomoon.ttf?eqsiuf’) format(‘truetype’), url(‘fonts/icomoon.woff?eqsiuf’) format(‘woff’), url(‘fonts/icomoon.svg?eqsiuf#icomoon’) format(‘svg’); font-weight:normal; font-style:normal}[class^=”icon-“],[class=”icon-“]{ / use !important to prevent issues with browser extensions that change fonts */ font-family:‘icomoon’!important; speak:none; font-style:normal; font-weight:normal; font-variant:normal; text-transform:none; line-height:1; / Better Font Rendering =========== / -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale}.icon-baidu:before{ content:“\e900”}.icon-mail:before{ content:“\e901”}.icon-qq:before{ content:“\e902”}.icon-qzone:before{ content:“\e903”}.icon-renren:before{ content:“\e904”}.icon-sina:before{ content:“\e905”}.icon-wechat:before{ content:“\e906”}.icon-copy:before{ content:“\e907”} 12345&gt; 这段CSS代码最好不用通过`&lt;link&gt;`标签引入，否则会出现字符无法正常显示的问题，这个问题目前我还在找原因。现在可以看到，通过@font-face已经引入了字体文件，并且已经为你预设好了每张图片(现在他们已经变成了字符或者说字体)的类名。和bootstrap的glyphicon的调用方法很像，都是通过给目标对象添加类名来调用。并且通过css3的高级选择器 ，在被选择元素之前添加了content，然后是对应字符的编号，非常贴心，这个时候只需要在你想要调用的地方添加class类名即可。最终的效果如下：这里写图片描述我通过js/jq又添加了hover效果，这个界面看上去就舒服多了。今天研究了一天这个问题，从最初的不明白第三方分享的原理，到现在可以改变默认样式，我觉得今天收获还是挺多的，对CSS、JS都有了更进一步的理解。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>百度share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript开心消消乐中的迭代算法]]></title>
    <url>%2F2017%2F10%2F22%2FJavaScript%E5%BC%80%E5%BF%83%E6%B6%88%E6%B6%88%E4%B9%90%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文初始编辑地址，源自我的CSDN博客：我的CSDN博客这两天玩开心消消乐，突然想琢磨一下每次这些小方块的生成算法。不考虑4个相同颜色的情况，理了一下初步的思路，大致如下：【一、游戏的初始化】1.首先有六种颜色：红、黄、蓝、绿、棕、紫。那么在一个44的矩阵里，要让这六种颜色分布于其中。2.初始化的颜色随机生成，并且每行、每列不能三个相同的颜色相连。3.为了能够进一步的游戏，必须在44的的矩阵中产生两个相连的颜色，并且在前者的左上、右上、左下、右下产生一个相同的颜色，否则整个游戏无法玩。【二、游戏的模拟点击操作】1.当点击第一个色块，再点击第二个色块，那么，交换这两个色块的颜色。2.如果这两个色块交换之后，并没有产生3个相同颜色相连，那么这种情况就应该保持两个点击色块的原本颜色。【三、色块消除以后的后续生成*(难点)】1.当三个色块消除后，上面的元素坍塌掉落。并用新的颜色填充坍塌元素的位置，并且还得遵循【一】中的生成原则。觉得文章有用？点击下方打赏，鼓励作者更好的写作！]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>

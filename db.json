{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/projects/proxy.properties","path":"projects/proxy.properties","modified":0,"renderable":0},{"_id":"themes/hexo-theme-mellow-master/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/alipay.png","path":"img/alipay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/brand.png","path":"img/brand.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/refresh.png","path":"img/refresh.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/wechat.png","path":"img/wechat.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/blog.js","path":"js/blog.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/method.js","path":"js/method.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/origin/LUICO.png","path":"origin/LUICO.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/origin/LUICO.psd","path":"origin/LUICO.psd","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/third-party/gitment.less","path":"css/third-party/gitment.less","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/1.jpg","path":"img/thumb/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/3.jpg","path":"img/thumb/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/7.jpg","path":"img/thumb/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/8.jpg","path":"img/thumb/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/fastclick.js","path":"js/plugins/fastclick.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/gitment.js","path":"js/plugins/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/leancloud_visitors.js","path":"js/plugins/leancloud_visitors.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/local_search.js","path":"js/plugins/local_search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/valine.js","path":"js/plugins/valine.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/6.jpg","path":"img/thumb/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/bluehost/Bluehost-Regular.woff","path":"css/fonts/bluehost/Bluehost-Regular.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/bluehost/Bluehost-Bold.woff","path":"css/fonts/bluehost/Bluehost-Bold.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/gitment.browser.js","path":"js/plugins/gitment.browser.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/gitmint.browser.js","path":"js/plugins/gitmint.browser.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/banner.png","path":"img/banner.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/10.jpg","path":"img/thumb/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/4.jpg","path":"img/thumb/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/9.jpg","path":"img/thumb/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/2.jpg","path":"img/thumb/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/origin/lu2.psd","path":"origin/lu2.psd","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/5.jpg","path":"img/thumb/5.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-mellow-master/.editorconfig","hash":"67a03b88eadd7810f2e01866e73814074ecd3b87","modified":1535514884832},{"_id":"themes/hexo-theme-mellow-master/LICENSE","hash":"9dd0f70bc72c9d575447655526aded395bb93754","modified":1535514884833},{"_id":"themes/hexo-theme-mellow-master/_config.yml","hash":"fdf5408296d6af00a302185770a24b23b5c2e6f8","modified":1535533981565},{"_id":"themes/hexo-theme-mellow-master/README.md","hash":"3293199fc433cac0989f649b2f70db019eb360b4","modified":1535514884834},{"_id":"themes/hexo-theme-mellow-master/a.js","hash":"c90794607f572b886684ff228b5df592e4be8e2e","modified":1535522717900},{"_id":"themes/hexo-theme-mellow-master/b.js","hash":"a945064277b44f120dde773969134ff05135f295","modified":1535522717902},{"_id":"themes/hexo-theme-mellow-master/package.json","hash":"4de887e2588a16a9105607f1b8ba080872045623","modified":1535514884890},{"_id":"source/简历.md","hash":"7f2369bf689d415bbac6f0b8fe62883b0aedad99","modified":1535522360748},{"_id":"themes/hexo-theme-mellow-master/languages/en.yml","hash":"ba78def0453d08172248e220a1f9e145e99b4f23","modified":1535514884836},{"_id":"themes/hexo-theme-mellow-master/languages/zh-CN.yml","hash":"6806e4c305facf19cbe4e37ccc5d6b00cb56e199","modified":1535514884837},{"_id":"themes/hexo-theme-mellow-master/languages/zh-TW.yml","hash":"9b8bdd9c8b68716f364503926dca6ba8571ee5ff","modified":1535514884837},{"_id":"themes/hexo-theme-mellow-master/layout/archive.ejs","hash":"47399518f0ba5d74d5d00c7189ba37b381c249f2","modified":1535514884884},{"_id":"themes/hexo-theme-mellow-master/layout/categories.ejs","hash":"939d3db86c08f3af9771c7352daf1d989e8b969e","modified":1535514884885},{"_id":"themes/hexo-theme-mellow-master/layout/category.ejs","hash":"67545ba2799eb2dc550954fadc1d1c265a56937e","modified":1535514884885},{"_id":"themes/hexo-theme-mellow-master/layout/index.ejs","hash":"f99df772f07c0852d4f4b4ea544060398a5d4587","modified":1535514884886},{"_id":"themes/hexo-theme-mellow-master/layout/layout.ejs","hash":"255fe7897591f1f92c2f23e20855e475c0cda054","modified":1535514884887},{"_id":"themes/hexo-theme-mellow-master/layout/page.ejs","hash":"db2f4ac06efd223bee81a932266c3d88a1349741","modified":1535514884887},{"_id":"themes/hexo-theme-mellow-master/layout/post.ejs","hash":"efc3352828351f8574c51e8a93dc56c66660c3b1","modified":1535514884888},{"_id":"themes/hexo-theme-mellow-master/layout/tag.ejs","hash":"90a231dea3a364b329a740e5d6c49c8cf5664fe9","modified":1535514884888},{"_id":"themes/hexo-theme-mellow-master/layout/tags.ejs","hash":"d0a211a5d50c5afec063f7852553fe1544db5ee4","modified":1535514884889},{"_id":"themes/hexo-theme-mellow-master/scripts/plugins.js","hash":"0c200aa56bae9cc131368f2bcb5c344522404b98","modified":1535514884891},{"_id":"source/_drafts/zhangqiang.md","hash":"e729d4f0f6e6415098fd57dcdf2804360f58e5a0","modified":1535514884799},{"_id":"source/_posts/2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录.md","hash":"fa7b7c098934557850291db00cc72ce3144d2b4c","modified":1535532851113},{"_id":"source/_posts/Ajax初探.md","hash":"167cb3181f2df70255cd937939a8915536108c48","modified":1535522399487},{"_id":"source/_posts/Angular1-4-6-Bootstrap3-3-7搭建后台人员管理系统-1-0-0.md","hash":"b498a52721866e50d40cc08d1b2d7a6bca44c772","modified":1535522360615},{"_id":"source/_posts/AngularJS学习笔记3.md","hash":"1fa2fdfe5a4bccf68536085015a2fb11a8a43c2c","modified":1535522407131},{"_id":"source/_posts/Angular搭建后台人员管理系统-1-1-0.md","hash":"c35ff141c455c8bf4b6de16c7d72f8c993fdc589","modified":1535522360618},{"_id":"source/_posts/Express快速构建应用.md","hash":"b1c232cf3cd6f03f538a7430a8e753d7cfab6d4a","modified":1535522360619},{"_id":"source/_posts/Git与GitHub之本地仓库.md","hash":"2bb8e5782ca68a2101fee67e0fc0acb3f269bfa6","modified":1535522360620},{"_id":"source/_posts/Git与GitHub之远程仓库.md","hash":"f08f22e55630b28f6e0eb7c8caaf8df157fa5615","modified":1535522360622},{"_id":"source/_posts/Html5回顾总结.md","hash":"92d6ac5edc4ff2547f1cac64791edea57b94dd81","modified":1535522360625},{"_id":"source/_posts/IONIC3 打包安卓apk详细过程（大量图文）.md","hash":"87c62688ca2d6aab78b1e31c8614275cbe44fc26","modified":1535522450788},{"_id":"source/_posts/JavaScript开心消消乐中的迭代算法.md","hash":"c8158504d6096048a793f3ce7e8c8026c061c934","modified":1535522469618},{"_id":"source/_posts/NodeBB搭建过程（windows+Redis）+ 科学上网方法.md","hash":"e5fb4a11d6355df9534f612e6e817198c2ec663c","modified":1535522360629},{"_id":"source/_posts/NodeJs基础配置、核心概念与学习路线回顾.md","hash":"b5fd51d4533641da56326e3d9f5cfd758d516ef6","modified":1535522360630},{"_id":"source/_posts/PHP初体验.md","hash":"c4393c5644aa725abe5a207bc68292233d1a3e53","modified":1535522360631},{"_id":"source/_posts/Webpack打包工具学习笔记.md","hash":"6a4e9463caeb248ba40da8067c552762fa40dc07","modified":1535522360632},{"_id":"source/_posts/ajax回顾.md","hash":"31f32834232cd9662274ed23a0576fe50f372b35","modified":1535522360633},{"_id":"source/_posts/cookie,session,token.md","hash":"b06d2f8786ca9905eb53b343fd4414237463ddbb","modified":1535527288339},{"_id":"source/_posts/css3原理，结合jquery复习.md","hash":"b51073248cc855db2278c1f043c0460d314351e1","modified":1535522360636},{"_id":"source/_posts/javascript Dom拖动 插件 putThere.js.md","hash":"29bcc40ba1f4bd02c5c995267b54108c90ecf2ac","modified":1535522462742},{"_id":"source/_posts/ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单双向绑定、组件通讯.md","hash":"c5ba6fc594a9009ac912125f7ecedf4a78383d27","modified":1535522480653},{"_id":"source/_posts/typescript学习笔记.md","hash":"41694bdaf9a4da18418ad0574c5930dbf3909a68","modified":1535522495094},{"_id":"source/_posts/使用 Travis-CI 持续集成部署 HEXO 博客项目.md","hash":"34c1dcbe566d19925e200994d93165c47bbc0e04","modified":1535528064604},{"_id":"source/_posts/关于CSS3呼吸效果的探究.md","hash":"5e4d40548a37be44fe67451bf2862d18b143c847","modified":1535522360641},{"_id":"source/_posts/关于jQuery中scrollTop中的一些兼容问题.md","hash":"d91e532088143f99c24e1ba7f44e7c22ab4ed12a","modified":1535522360642},{"_id":"source/_posts/关于百度集成API-bd-share的一些窥探.md","hash":"e0172f8868e9b365829f2df457c99360331991cc","modified":1535522360658},{"_id":"source/_posts/函数式编程与响应式编程之己见.md","hash":"fa7e0cd83576320e1060dff9e14e5464872c3f4e","modified":1535522513510},{"_id":"source/_posts/基于HEXO的个人博客图文搭建详尽过程，看不懂算我输.md","hash":"788a3d1c8684f9e64e4d63adb73a71ce2724147d","modified":1535522522422},{"_id":"source/_posts/基于bootstrap特殊分辨率页面的实现思路.md","hash":"30927dc464f19c681f753dcaf69fc3419abfd5ae","modified":1535522360694},{"_id":"source/_posts/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上.md","hash":"e8155a04fd4ff3edad8265baee2c71db15640a74","modified":1535532824958},{"_id":"source/_posts/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下.md","hash":"c9627783ba4d5cbcdf184ed0e29f2048a16dbd38","modified":1535532828688},{"_id":"source/_posts/用原生js制作一个动态简历(多动症简历)及在线预览部署过程.md","hash":"888e70dd0c679b2b29d8d7c7130dc882f75e01c4","modified":1535522547007},{"_id":"source/_posts/谈一谈来北京的工作节奏以及对前端的看法.md","hash":"fdfdd0b420ad6a70b6fe3a0854728ecf8d11263e","modified":1535532857354},{"_id":"source/categories/index.md","hash":"2d49fb1b799cfa114135a923cae4b9d3898ff0ac","modified":1535522360745},{"_id":"source/about/index.md","hash":"a1c5e3caae87bb47ee75b4d9573eb6a4dbb58f99","modified":1535522360733},{"_id":"source/about/个人简历.md","hash":"c313060f53ab5eb004627934eb5d241338bbe18d","modified":1535522360744},{"_id":"source/projects/index.md","hash":"6297f07a099e20300372f8ce3486280b832028b7","modified":1535514884828},{"_id":"source/projects/proxy.properties","hash":"0ec77baf443520db12846148859c0434fb8f3ab1","modified":1535522360746},{"_id":"source/tags/index.md","hash":"6c0f775ad72a4c697012b13665a6e8832ef8cca2","modified":1535522360747},{"_id":"themes/hexo-theme-mellow-master/layout/_custom/body.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535514884838},{"_id":"themes/hexo-theme-mellow-master/layout/_custom/head.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535514884838},{"_id":"themes/hexo-theme-mellow-master/layout/_custom/script.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535514884838},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/after-footer.ejs","hash":"cd335bf5823d2fbb03bb1485041503853971a380","modified":1535514884854},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/archive.ejs","hash":"fbb35d4b58b644c156d37564ce884f0311ea2bcc","modified":1535514884854},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/footer.ejs","hash":"13a3ac0975074d95d0d5f41a3fb8eaae3d858da5","modified":1535514884855},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/head.ejs","hash":"5db6222446bc519ae02e53d93cf0762a4115df8c","modified":1535514884855},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/header.ejs","hash":"742ce99ccef10891d5c4d7556ad212490ff35b9d","modified":1535514884856},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/index-item.ejs","hash":"1b288daf173c2d8103b73b6217982f6641fbd84f","modified":1535514884857},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/loading.ejs","hash":"8b3e037dd5f3d4564012689c5cd6f63caf73df0f","modified":1535514884858},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/menu.ejs","hash":"b2d4ad0227360db413df1d140508c68adf015384","modified":1535514884858},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/paginator.ejs","hash":"13952250463f70d1c1bbbfdd7f4ee8160dd6d99b","modified":1535514884859},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post.ejs","hash":"b04d313c0b194b979b5ff07d7c77d047615c104d","modified":1535514884859},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/script.ejs","hash":"ec7bf06c7af83aefc7b13a0e9d5d25ec3fe9fe15","modified":1535514884883},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/tags-bar.ejs","hash":"8e9a493abbb60bcd68f27f1ff6535a2a97287628","modified":1535514884884},{"_id":"themes/hexo-theme-mellow-master/source/css/style.less","hash":"50e88403265f8ff418394952d85a2c5d885497d7","modified":1535514884923},{"_id":"themes/hexo-theme-mellow-master/source/img/alipay.png","hash":"cc934395585b647219bd233d49787ec71eea7663","modified":1535514884929},{"_id":"themes/hexo-theme-mellow-master/source/img/brand.png","hash":"bf034073e834234cc6183242c7f26c031d98306a","modified":1535514884949},{"_id":"themes/hexo-theme-mellow-master/source/img/favicon.png","hash":"5c0c682dc272e8db9eca93ecd0d3ee9c0f0ffa6a","modified":1535514884950},{"_id":"themes/hexo-theme-mellow-master/source/img/github.png","hash":"f277cda817d07b79fa7dbebbbbdf980436d80808","modified":1535514884951},{"_id":"themes/hexo-theme-mellow-master/source/img/img-err.png","hash":"762288999d47566a20ced25c7377bf2f3ebc7c4f","modified":1535514884951},{"_id":"themes/hexo-theme-mellow-master/source/img/img-loading.png","hash":"f832f5a523efb5d680b66ab0ea54379a176291e7","modified":1535514884952},{"_id":"themes/hexo-theme-mellow-master/source/img/refresh.png","hash":"02e01daa167e5baa3cfe16720f0307779e271618","modified":1535514884952},{"_id":"themes/hexo-theme-mellow-master/source/img/wechat.png","hash":"9b1e23852ace142a7cd8aae36c683cf761e478dd","modified":1535514884975},{"_id":"themes/hexo-theme-mellow-master/source/js/_config.yml","hash":"ac7d67462e3b401bec0229c460655618a3b01931","modified":1535514884976},{"_id":"themes/hexo-theme-mellow-master/source/js/blog.js","hash":"22ae7a3c963c0815bdf0eaf196d093fb89781128","modified":1535514884977},{"_id":"themes/hexo-theme-mellow-master/source/js/method.js","hash":"f290c258d15e46d335067c1a68503daf34b22164","modified":1535514884977},{"_id":"themes/hexo-theme-mellow-master/source/origin/LUICO.png","hash":"e4cdefaca47bb58e9b99a82ed75e61bdd6d0e1aa","modified":1535514884986},{"_id":"themes/hexo-theme-mellow-master/source/origin/LUICO.psd","hash":"89ee660a03ed14ec70963085069293b1ec64e149","modified":1535514884986},{"_id":"themes/hexo-theme-mellow-master/source/img/_avatar.png","hash":"25df816f6fd8692ca749f0c8d269938521635b76","modified":1535523124057},{"_id":"themes/hexo-theme-mellow-master/source/img/avatar.png","hash":"25df816f6fd8692ca749f0c8d269938521635b76","modified":1535522717912},{"_id":"themes/hexo-theme-mellow-master/source/img/_alipay.jpg","hash":"01d963c04cab39e14603456e1a8067971b4649c7","modified":1535514884925},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/gitment.ejs","hash":"a53b28cf018f73a44361aaf9ab7604276cdaa720","modified":1535514884843},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/dynamic_title.ejs","hash":"1b6dc09947c6b39cfc2abd5ef087d12f89331150","modified":1535514884841},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/github_repo.ejs","hash":"841441db80aa2d0170b3f4481b1176c0a53e5a3b","modified":1535514884842},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/leancloud_visitors.ejs","hash":"81cd97d76bcc19d711df5a113db935717304e6f4","modified":1535514884843},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/local_search.ejs","hash":"9c77ea96055ddeb0ed61f6afab3a54920e3970e7","modified":1535514884852},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/mathjax.ejs","hash":"f213b937586cc5d6adad9530b3fb7de1e67668b7","modified":1535514884853},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/baidu_tongji.ejs","hash":"b8cee3b4cc2daba89f41ed6bff7121075641b587","modified":1535514884841},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_third-party/valine.ejs","hash":"bda46f0dca3bc01c7ab459cb21f90fe421641aaf","modified":1535514884853},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_plugins/blogroll.ejs","hash":"63d66cb49747fdfe327674e889e275855cdd6008","modified":1535514884839},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_plugins/gitment.ejs","hash":"c39461991e0c811ca47dc8f2115b90aabc0f3850","modified":1535522717904},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_plugins/site-visitor.ejs","hash":"28081ac5bee26d2ec4777d2c53eb6560a148cefe","modified":1535514884840},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/_plugins/valine.ejs","hash":"cf3633fe1f105ba5ed7a2733521d4916b7dd6257","modified":1535514884840},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/category.ejs","hash":"c08e44cbd7315dec7afb6054b04d3c7b82c3bde8","modified":1535514884860},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/comment-count.ejs","hash":"4e5c0c265b34739a54927566d1255928dcac11be","modified":1535522717907},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/comment.ejs","hash":"c5ea435f288d3e0871d3aa64585e6a346cfbc739","modified":1535514884861},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/copyright.ejs","hash":"28c1839ae035c1cd0dc89593d0e885da40b2e528","modified":1535514884862},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/date.ejs","hash":"c5adcec8db1506c378d39855a697e1bb1165646c","modified":1535514884862},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/head-meta.ejs","hash":"f137c126672769e9571be2bb0a70ea8dda644b0e","modified":1535514884863},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/music.ejs","hash":"4c5dcee38b3a6311e651cb3668f940ec8c75ac47","modified":1535514884875},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/nav.ejs","hash":"98936485f6929b5beeeb8efbe2fc6aa6c14a185e","modified":1535514884876},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/repo-icon.ejs","hash":"2d2a7f96f1f520bb8ad95e594c21e0b766f286b2","modified":1535514884876},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/repo.ejs","hash":"dfdcc95b008077ee3221047011642cba0c814d7d","modified":1535522717909},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/reward-btn.ejs","hash":"5847ca92a1675a35be254a54b09a3d0a78a447f8","modified":1535514884877},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/reward.ejs","hash":"c288344665250924c3a643347e4ba13427dc446d","modified":1535514884878},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/share-fab.ejs","hash":"41ee96ff9b8f0ee395009e321670c20073329554","modified":1535514884878},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/share.ejs","hash":"2df4bd3c29222ebd0ba2d62c53bb001e63919120","modified":1535514884879},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/tag.ejs","hash":"412894001b1ac6e63012b26b1109a0856651c076","modified":1535514884879},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/thumb.ejs","hash":"933a71162f70c91ed1de871b151988c3f569a62e","modified":1535514884880},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/title.ejs","hash":"109a1b5950db165f3f2dea5733129655e052b57d","modified":1535514884881},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/toc.ejs","hash":"903f61c70b444dcbdc44c88ed911bb0072f2e905","modified":1535514884881},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/top.ejs","hash":"6348e0cbb7b0d3a7100e7d3f4bbc0be4652d8b3f","modified":1535522717910},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/updated.ejs","hash":"80fc5f754a1aa029156efb5a0bdbdd1064cc4487","modified":1535514884882},{"_id":"themes/hexo-theme-mellow-master/layout/_partial/post/visitor.ejs","hash":"824cbdf692077328abf90bd362c19a8b33018e3f","modified":1535514884883},{"_id":"themes/hexo-theme-mellow-master/source/css/_custom/custom.less","hash":"dd87c07c04660b002f9a137677263e8dc1f5c754","modified":1535514884892},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/archives.less","hash":"078d14e3c058c99b48929b4ad9cb307e9a3bbbf1","modified":1535514884892},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/article.less","hash":"426a35402308f77a858517162e9e9506ffa78e21","modified":1535514884893},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/bluehost.less","hash":"8140a695d575d8004ba5ae75e802f17028cb448d","modified":1535514884893},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/gotop.less","hash":"61c5a5595888bb21584adf4afe540747a651a823","modified":1535514884895},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/header.less","hash":"1e873663d8703030544190e666e5ed16b1c9409c","modified":1535514884896},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/highlight.less","hash":"204ebbbda17694d82b22454a8f98cb0aed601d3e","modified":1535514884897},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/imagebox.less","hash":"98843f937c2b58aa843e9c2258ec0a10c6acb838","modified":1535514884897},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/layout.less","hash":"81d0b65b9c7991d37a92ff4eacce2413d149957f","modified":1535514884898},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/loading.less","hash":"15c932a870f0481549fce45956765db566cc8cb9","modified":1535514884899},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/page.less","hash":"7a1c49943dbe9bfaae9463b8ef2bdfccd51d0a4c","modified":1535514884899},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/plugins.less","hash":"dfc28840c72510d64ccbf426f610f023dccc8420","modified":1535514884900},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/postlist.less","hash":"7cf6d0d1ddb3491836f53a95c688c3c1f26a9949","modified":1535514884900},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/repo.less","hash":"544258d61fd815f39c9ee7028c5d4144254e85c1","modified":1535514884901},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/search.less","hash":"4fa047d684131ba38f4bc9964f078acf521a3b84","modified":1535514884902},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/reward.less","hash":"52abe8c36d8e0472df164325c7aa6b3fb7b2e9df","modified":1535514884902},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/share.less","hash":"0e758a1a20f03d80e8f49e3223df0293b507050b","modified":1535514884903},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/tags.less","hash":"b6c1c74e6c640d56b5430551f882dbefeb33b3f0","modified":1535514884903},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/variable.less","hash":"849eb93e79e2f8b690224438ca88c7021247a095","modified":1535514884904},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/waves.less","hash":"332553d6330df00b45f9c1850fcf8750c949a0e6","modified":1535514884905},{"_id":"themes/hexo-theme-mellow-master/source/css/third-party/gitment.less","hash":"4eed862257e31399d4f093f48200c91c796e2c8a","modified":1535514884924},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/1.jpg","hash":"fc06372f11612f8636b41cf19d16249d2867637e","modified":1535514884954},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/3.jpg","hash":"b8b5b3e326aad1b2e85ef7c192d5d67532f9cf02","modified":1535514884960},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/7.jpg","hash":"3c34514405e097bd0a1fbfa33d6e6c0a771f82fe","modified":1535514884972},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/8.jpg","hash":"dec3142dae0f8ee75dda4a9c6b7ec5ab4646f626","modified":1535514884973},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/fastclick.js","hash":"2267d1ee08bc04edfd7efbf6c62a361bd371f4ef","modified":1535514884978},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/gitment.js","hash":"3ba2d6bdebf5a8b89061842310d83fe4c9e43748","modified":1535522717939},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/leancloud_visitors.js","hash":"80245560c7992bedb83f27efe73be4ba22b4f51d","modified":1535514884983},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/local_search.js","hash":"a92ec4cb83b200a67a2004c66cf9eadc219a449b","modified":1535514884984},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/valine.js","hash":"f31d7a6bcab34e8a1ece993f53e5209ee588243e","modified":1535514884985},{"_id":"themes/hexo-theme-mellow-master/source/css/_partial/fontawesome.less","hash":"a3ecbd6ccf5b56ac39df710c34a149b82989a498","modified":1535514884895},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/6.jpg","hash":"ac2da275f8be2c0d00eb2076a70fcda510363df6","modified":1535514884970},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/bluehost/Bluehost-Regular.woff","hash":"bfde0e4648eb3ee39c77044ddab4c4fad175cb38","modified":1535514884906},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/bluehost/Bluehost-Bold.woff","hash":"83d8e77fb78d396118155cfbb1c99ff9c430d864","modified":1535514884906},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/gitment.browser.js","hash":"b15998a45d5f386d30905cfbfbb1658336acbb5b","modified":1535514884981},{"_id":"themes/hexo-theme-mellow-master/source/js/plugins/gitmint.browser.js","hash":"f05fd16366cbc16466f8f92f286082dfd5e44fa5","modified":1535514884983},{"_id":"themes/hexo-theme-mellow-master/source/img/banner.png","hash":"063628a9326b0b0ad5cf4ab54ef6bc185d85cd5a","modified":1535514884948},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535514884921},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/10.jpg","hash":"0fa7a3ece29aa4363be21e16cfd8f8a3e2c9a879","modified":1535514884956},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/4.jpg","hash":"7e77df16248c696202230a16da8a57c16be6f246","modified":1535514884962},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535514884922},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/9.jpg","hash":"a1ddd14c3eb63454d0ebebb35aa2ea1685815e0e","modified":1535514884975},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535514884909},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535514884912},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535514884919},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/2.jpg","hash":"6e4aab3d27009889f980171f034517236f1cc689","modified":1535514884959},{"_id":"themes/hexo-theme-mellow-master/source/origin/lu2.psd","hash":"39ebf3cb8b2b62382da3a2c629bf934a29ad391e","modified":1535514884990},{"_id":"themes/hexo-theme-mellow-master/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"c5aa7f2fe1cecbbe92e6c57d7414a4dbc731012e","modified":1535514884916},{"_id":"themes/hexo-theme-mellow-master/source/img/thumb/5.jpg","hash":"d6c69e0b30b2fb7825135d574eb00781bde5e993","modified":1535514884969},{"_id":"public/atom.xml","hash":"2ac45be2da8647d2f2cc10510c38751848454cd6","modified":1535533380602},{"_id":"public/search.xml","hash":"b99569421a81461df4f3f96f6a15bd2c698b5c75","modified":1535533380776},{"_id":"public/简历.html","hash":"34686d6c7bc0d32f0bf913c2352e67a1927b64e8","modified":1535534000636},{"_id":"public/categories/index.html","hash":"7d9408c2316a5bde10c12c549010fe8ba1e17010","modified":1535534000634},{"_id":"public/about/index.html","hash":"96fbc4d937004a717e1f0d27bd1087fefe74880c","modified":1535534000634},{"_id":"public/about/个人简历.html","hash":"6803c2f4084606571440cd3bb96214a0c1522cd8","modified":1535534000636},{"_id":"public/projects/index.html","hash":"aa2d19c3a3027f9d94dc16c48542e03cfeb48efa","modified":1535534000636},{"_id":"public/tags/index.html","hash":"3dc3765269d97e3a9efb342001f8ca2fcc589a17","modified":1535534000636},{"_id":"public/2018/08/29/使用 Travis-CI 持续集成部署 HEXO 博客项目/index.html","hash":"89e01071b9b8f82260002ac326aa1831a38013a3","modified":1535534000637},{"_id":"public/2018/08/26/cookie,session,token/index.html","hash":"13f5f481400dae4ab56a3d3e3254974821dcbc72","modified":1535534000637},{"_id":"public/2018/07/22/函数式编程与响应式编程之己见/index.html","hash":"de603a37137ffabd450ecd6042fba86337f7c36a","modified":1535534000637},{"_id":"public/2018/06/22/NodeBB搭建过程（windows+Redis）+ 科学上网方法/index.html","hash":"c192e6da1b96148ad3497d7ff6ab3c4e54b3effc","modified":1535534000637},{"_id":"public/2018/05/23/谈一谈来北京的工作节奏以及对前端的看法/index.html","hash":"ebcc0186a98c8de4cbe5ed4226bcc937b85ecbe4","modified":1535534000637},{"_id":"public/2018/04/14/基于bootstrap特殊分辨率页面的实现思路/index.html","hash":"3da6f2674f2b47dc5acb301662ab61762982686d","modified":1535534000637},{"_id":"public/2018/03/25/ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单双向绑定、组件通讯/index.html","hash":"61cf66a7401cc1cd1be4ddc01669b7ce33d66552","modified":1535534000637},{"_id":"public/2018/03/11/typescript学习笔记/index.html","hash":"975b5f0aed507c6979ab23ea4524c5414e422df4","modified":1535534000638},{"_id":"public/2018/03/06/IONIC3 打包安卓apk详细过程（大量图文）/index.html","hash":"ea90d0fcb1722d8b8f2bccef49384f3db1b68c1d","modified":1535534000638},{"_id":"public/2018/03/06/javascript Dom拖动 插件 putThere.js/index.html","hash":"90480daaa135c14cc53a27069d328d6cf89c17f6","modified":1535534000638},{"_id":"public/2018/02/01/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下/index.html","hash":"45af5082c3a318c41b04eca2c5dc91fc2da0149b","modified":1535534000639},{"_id":"public/2018/01/31/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上/index.html","hash":"4ac9e30eb78e81a37c85684591c351dc19b46fd7","modified":1535534000639},{"_id":"public/2018/01/29/用原生js制作一个动态简历(多动症简历)及在线预览部署过程/index.html","hash":"2610d3c3ff0ea4a1d8d4fe329d874c3a1ff31aa8","modified":1535534000639},{"_id":"public/2018/01/25/2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录/index.html","hash":"17011061f51a818751264679409a31b7789d5fa6","modified":1535534000639},{"_id":"public/2018/01/18/基于HEXO的个人博客图文搭建详尽过程，看不懂算我输/index.html","hash":"ddbc522f144042f9ad4d018cac5d2900da9f8ba4","modified":1535534000639},{"_id":"public/2018/01/17/Webpack打包工具学习笔记/index.html","hash":"3df0fad8ef6f9d4ab92f492ad526b1b34619f2cf","modified":1535534000639},{"_id":"public/2018/01/17/css3原理，结合jquery复习/index.html","hash":"f306c62cdc7c016da7ff7e40b925d9f062d4d6dc","modified":1535534000639},{"_id":"public/2018/01/17/Angular搭建后台人员管理系统-1-1-0/index.html","hash":"52ab4d211ec04ba4a7f5015a2247d1590350570b","modified":1535534000640},{"_id":"public/2018/01/17/关于CSS3呼吸效果的探究/index.html","hash":"cb3864db917f8f968864f6a373b147c1ec30f4e8","modified":1535534000640},{"_id":"public/2018/01/12/Html5回顾总结/index.html","hash":"70572ffc001ef6397a054cb5413919b0fd4f8fb1","modified":1535534000640},{"_id":"public/2017/12/25/Express快速构建应用/index.html","hash":"cf9695db13f6d4531745d58c2dfdea52a1db4fea","modified":1535534000640},{"_id":"public/2017/12/19/Angular1-4-6-Bootstrap3-3-7搭建后台人员管理系统-1-0-0/index.html","hash":"e1a04c9bad486cfe4ee275355891c143cf591e21","modified":1535534000641},{"_id":"public/2017/12/13/关于jQuery中scrollTop中的一些兼容问题/index.html","hash":"f1ca520c4e42e2e0e7ab57a3c4bd309c8a59e0e0","modified":1535534000641},{"_id":"public/2017/12/12/NodeJs基础配置、核心概念与学习路线回顾/index.html","hash":"ad944dcade683d2f4dc90abc673675d9a7be231d","modified":1535534000641},{"_id":"public/2017/12/12/ajax回顾/index.html","hash":"fc7a3aeee2c57e22058d629292f5b286e97c8a7a","modified":1535534000641},{"_id":"public/2017/12/11/Git与GitHub之远程仓库/index.html","hash":"6f0452e62845fe1241a6b2577a23c53d157a8406","modified":1535534000641},{"_id":"public/2017/12/11/Git与GitHub之本地仓库/index.html","hash":"b4d458baebbd5f5d89a3d3adf53a93a9ec24c944","modified":1535534000642},{"_id":"public/2017/12/09/PHP初体验/index.html","hash":"5e8db0610d40bdcb72cc08efd17d57f3ec9892c1","modified":1535534000642},{"_id":"public/2017/12/05/AngularJS学习笔记3/index.html","hash":"48965fabdb336a33c0cb75a3deb0eda09728eaa7","modified":1535534000642},{"_id":"public/2017/11/06/Ajax初探/index.html","hash":"78608e1697573874cb28197b2cd131a044170dd6","modified":1535534000642},{"_id":"public/2017/11/03/关于百度集成API-bd-share的一些窥探/index.html","hash":"549e9c3d03355e02a1492666b2651c6242caae3e","modified":1535534000644},{"_id":"public/2017/10/22/JavaScript开心消消乐中的迭代算法/index.html","hash":"bb333c824bd7ef7f3aaf821e0d7e985b0aead967","modified":1535534000644},{"_id":"public/index.html","hash":"bbebb07a01e5cbdd2be86465fe660ee847f7ef3d","modified":1535534000644},{"_id":"public/page/2/index.html","hash":"071e2ad9779ece7711619f324298f99599ad165c","modified":1535534000644},{"_id":"public/page/3/index.html","hash":"cc880e350a92acb8299da0b9427cbd712c87b663","modified":1535534000644},{"_id":"public/page/4/index.html","hash":"0f9e1014c940464ffb8c8aba5972b517b2dc9d79","modified":1535534000644},{"_id":"public/page/5/index.html","hash":"3b2a9e3db35c8883032ecdd7510c5f509805670e","modified":1535534000644},{"_id":"public/page/6/index.html","hash":"e8462e84c900ebe20689fc00c867cda69691a384","modified":1535534000644},{"_id":"public/page/7/index.html","hash":"ed431652f1b0a40d3c9eb8e7eead59fd7568041c","modified":1535534000644},{"_id":"public/archives/index.html","hash":"2b1fe7568d6f3e3bc975de56af596452aea35a50","modified":1535534000644},{"_id":"public/archives/page/2/index.html","hash":"8fdeb6ba90c549fb2e7766d0cddd587d2010247e","modified":1535534000644},{"_id":"public/archives/page/3/index.html","hash":"83d8a6c2418345f3a918e68d862c692c1c3b56d0","modified":1535534000644},{"_id":"public/archives/page/4/index.html","hash":"915e06d0bdb2e0e0dcec10c8d04a6bb43f01bc2c","modified":1535534000634},{"_id":"public/archives/2017/index.html","hash":"36fdc0e4ff59948c699324b6ad53514a530eaac2","modified":1535534000644},{"_id":"public/archives/2017/page/2/index.html","hash":"7e007386ecf71e4bde8b446a2c214e4db5250a2d","modified":1535534000635},{"_id":"public/archives/2017/10/index.html","hash":"496eb32a4e9885311d7267cc301cb466ef758d59","modified":1535534000635},{"_id":"public/archives/2017/11/index.html","hash":"051dbee538987f0482a93d4b664f59fd234c4f96","modified":1535534000635},{"_id":"public/archives/2017/12/index.html","hash":"237f7b8c694e22cc39ad2d1505cef5988d2c4d8e","modified":1535534000644},{"_id":"public/archives/2018/index.html","hash":"3a96e0ceb06d9300b6db7232191fd3013640e02e","modified":1535534000644},{"_id":"public/archives/2018/page/2/index.html","hash":"d8ba5248f7f76e66ef0641528a3736de1e1db5f9","modified":1535534000644},{"_id":"public/archives/2018/01/index.html","hash":"be814adc7c88521f0fca349d19c3cea69839f259","modified":1535534000644},{"_id":"public/archives/2018/02/index.html","hash":"6268d843d599f0faf06be463f2604ebeac2e88c6","modified":1535534000635},{"_id":"public/archives/2018/03/index.html","hash":"819167d51e96962eca45e42c549abdf1a2d533fb","modified":1535534000635},{"_id":"public/archives/2018/04/index.html","hash":"9fbc61650faf2c4802bf2951a99680c9f33008f4","modified":1535534000635},{"_id":"public/archives/2018/05/index.html","hash":"ae0cf071808b03c56bb5389299c4cadf64ecf885","modified":1535534000635},{"_id":"public/archives/2018/06/index.html","hash":"b26e64bc14aff9d52f29af08166a1e8fe3ed6441","modified":1535534000636},{"_id":"public/archives/2018/07/index.html","hash":"e20189bc968fd59f30b42c21525a1a4d367d3da3","modified":1535534000636},{"_id":"public/archives/2018/08/index.html","hash":"d202c4830dc47395c1fdf54164a08ba044e3736a","modified":1535534000636},{"_id":"public/tags/腾讯SNG-IMWeb面试/index.html","hash":"6b3de20716d37ebb63107399b255f1ace717d915","modified":1535534000644},{"_id":"public/tags/ajax/index.html","hash":"c1db9bedf0ef19f0ce2616c1dfc6853d712dbc9d","modified":1535534000645},{"_id":"public/tags/angularjs/index.html","hash":"17dfd4b9c7e771dda219d90e4fa52db220c181ed","modified":1535534000645},{"_id":"public/tags/Express/index.html","hash":"b865978357d5dbd7961cb36bf1dccea80dcae474","modified":1535534000645},{"_id":"public/tags/git/index.html","hash":"ae413a45a7c7e58ae8048d0ecd8a78edb8531bb6","modified":1535534000645},{"_id":"public/tags/html5/index.html","hash":"351ac775ae2a92e922775bfc7ada679fadbd339a","modified":1535534000645},{"_id":"public/tags/android/index.html","hash":"f97c13f3e363af604669dc5dafd8af6c350bf043","modified":1535534000645},{"_id":"public/tags/SDK/index.html","hash":"3ad12f0cfa9d5a26393b6c6071b4aeeae05d3eed","modified":1535534000645},{"_id":"public/tags/JDK/index.html","hash":"0b2ad866bbb43cd6d3e39ec5a6d6caea8737f191","modified":1535534000646},{"_id":"public/tags/APP/index.html","hash":"5577fbfa12828cc4b2668c747231d21a0546443b","modified":1535534000646},{"_id":"public/tags/IONIC/index.html","hash":"337befc45618f989a0e068a06b3d11731f10e123","modified":1535534000646},{"_id":"public/tags/gradle/index.html","hash":"0c1bc185388640494901e1c7caa5ea2e856b9bcf","modified":1535534000646},{"_id":"public/tags/算法/index.html","hash":"4160d7cf9605883b54034edaf651909a4f55c8c1","modified":1535534000646},{"_id":"public/tags/node/index.html","hash":"e910dffef37c6581392954bbc032f01f63a023a3","modified":1535534000646},{"_id":"public/tags/javascript/index.html","hash":"0b20d3212d2220ba1b1bb796c09cfff4be5f59ec","modified":1535534000646},{"_id":"public/tags/nodejs/index.html","hash":"301637d2dd85be909887aad6b2347f86c117592b","modified":1535534000646},{"_id":"public/tags/php/index.html","hash":"3335fa33aa1c7233b86186e4d2063036537f85a1","modified":1535534000646},{"_id":"public/tags/Webpack/index.html","hash":"f52cab3d660dbc30dfd0842e443c11f55a9bc972","modified":1535534000647},{"_id":"public/tags/http/index.html","hash":"1aa8778a2f54b119291b43041b1965a27eaf5253","modified":1535534000647},{"_id":"public/tags/css3/index.html","hash":"244ecc4618004e19afcd4e24737027b99867b09e","modified":1535534000647},{"_id":"public/tags/plug-in/index.html","hash":"06dba7a38b55642f862299d74449b664fb57efb8","modified":1535534000647},{"_id":"public/tags/angular/index.html","hash":"5447dfac80632fb5032d6962752b5eb25dc3a2dd","modified":1535534000647},{"_id":"public/tags/typescript/index.html","hash":"7bc684b4f61dab88df3af3d9f725c7e0c52c8c8a","modified":1535534000647},{"_id":"public/tags/编译/index.html","hash":"e8ff0c148bdbbb703cfa46a94159d2b3bb743b59","modified":1535534000647},{"_id":"public/tags/工具/index.html","hash":"4d1b18bb357ecb83efc9b9ec1759dcde0954ea99","modified":1535534000647},{"_id":"public/tags/Travis-CI/index.html","hash":"98096275d5f93ea1c2321c1b084b9a27d22018bd","modified":1535534000648},{"_id":"public/tags/Hexo/index.html","hash":"96c46bf3aabeb38a2b0f76048bc2407519445945","modified":1535534000648},{"_id":"public/tags/jquery/index.html","hash":"84532cf7c62a72c8eb2fe71912744af3573421d9","modified":1535534000648},{"_id":"public/tags/百度share/index.html","hash":"9a0f92d28cd26edd6f5cad472f6cb1603c728576","modified":1535534000648},{"_id":"public/tags/HEXO/index.html","hash":"843951f6537c2c1c66471285ca0a84ce0d61a46c","modified":1535534000648},{"_id":"public/tags/动态部署/index.html","hash":"64ed1b272f94d30130ffdaff7feec58277122b98","modified":1535534000648},{"_id":"public/tags/bootstrap/index.html","hash":"f71717e6dae8814f64f80fe9fa1a3ae345634787","modified":1535534000648},{"_id":"public/tags/腾讯/index.html","hash":"9af476808052f1d630557f5c05553ab43e92bc16","modified":1535534000648},{"_id":"public/tags/面试/index.html","hash":"2a2d9478be9da02dbd11362e771e504b251c613e","modified":1535534000649},{"_id":"public/tags/浏览器兼容/index.html","hash":"3caa58ca6a1c5c13728b3756aef17c9706b4799d","modified":1535534000649},{"_id":"public/tags/原理/index.html","hash":"dbec8492aeeaeb8f7fba2c92ccd52839d0665be8","modified":1535534000649},{"_id":"public/tags/重绘/index.html","hash":"873453c2778995d33e0a526ff69eb8b636c6d1ca","modified":1535534000649},{"_id":"public/tags/冲排/index.html","hash":"4d5d2259a9c9c65f8d0480fb959f0781afdc772c","modified":1535534000650},{"_id":"public/tags/腾讯面试/index.html","hash":"421f7c4f29f4fcfea3b95a0ae346b6311043d324","modified":1535534000650},{"_id":"public/tags/动态简历/index.html","hash":"9a4fcb04d46ea6ae916733cf3634d1fd8a802376","modified":1535534000650},{"_id":"public/tags/Github部署/index.html","hash":"15177530304400890ceda88e342f5ac48d2e4f3b","modified":1535534000650},{"_id":"public/tags/杂谈/index.html","hash":"665bfc3aedac1dd88aa4d7c6d0e4171a2e9bf44d","modified":1535534000651},{"_id":"public/projects/proxy.properties","hash":"0ec77baf443520db12846148859c0434fb8f3ab1","modified":1535533380869},{"_id":"public/img/alipay.png","hash":"cc934395585b647219bd233d49787ec71eea7663","modified":1535533380869},{"_id":"public/img/brand.png","hash":"bf034073e834234cc6183242c7f26c031d98306a","modified":1535533380869},{"_id":"public/img/favicon.png","hash":"5c0c682dc272e8db9eca93ecd0d3ee9c0f0ffa6a","modified":1535533380869},{"_id":"public/img/github.png","hash":"f277cda817d07b79fa7dbebbbbdf980436d80808","modified":1535533380869},{"_id":"public/img/img-err.png","hash":"762288999d47566a20ced25c7377bf2f3ebc7c4f","modified":1535533380870},{"_id":"public/img/img-loading.png","hash":"f832f5a523efb5d680b66ab0ea54379a176291e7","modified":1535533380870},{"_id":"public/img/refresh.png","hash":"02e01daa167e5baa3cfe16720f0307779e271618","modified":1535533380870},{"_id":"public/img/wechat.png","hash":"9b1e23852ace142a7cd8aae36c683cf761e478dd","modified":1535533380870},{"_id":"public/origin/LUICO.png","hash":"e4cdefaca47bb58e9b99a82ed75e61bdd6d0e1aa","modified":1535533380870},{"_id":"public/origin/LUICO.psd","hash":"89ee660a03ed14ec70963085069293b1ec64e149","modified":1535533380870},{"_id":"public/img/thumb/1.jpg","hash":"fc06372f11612f8636b41cf19d16249d2867637e","modified":1535533380870},{"_id":"public/img/thumb/3.jpg","hash":"b8b5b3e326aad1b2e85ef7c192d5d67532f9cf02","modified":1535533380870},{"_id":"public/img/thumb/7.jpg","hash":"3c34514405e097bd0a1fbfa33d6e6c0a771f82fe","modified":1535533380870},{"_id":"public/img/thumb/8.jpg","hash":"dec3142dae0f8ee75dda4a9c6b7ec5ab4646f626","modified":1535533380870},{"_id":"public/css/fonts/bluehost/Bluehost-Regular.woff","hash":"bfde0e4648eb3ee39c77044ddab4c4fad175cb38","modified":1535533380871},{"_id":"public/css/fonts/bluehost/Bluehost-Bold.woff","hash":"83d8e77fb78d396118155cfbb1c99ff9c430d864","modified":1535533380872},{"_id":"public/img/avatar.png","hash":"25df816f6fd8692ca749f0c8d269938521635b76","modified":1535533380941},{"_id":"public/img/thumb/6.jpg","hash":"ac2da275f8be2c0d00eb2076a70fcda510363df6","modified":1535533380941},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535533380945},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535533380945},{"_id":"public/js/method.js","hash":"6ee803b09a36c428a0d4b6b278cf0f59bda1e5db","modified":1535533380974},{"_id":"public/js/blog.js","hash":"21c6b6d4650a1088e426a8eb6d86132aee7a35ec","modified":1535533380975},{"_id":"public/js/plugins/gitment.js","hash":"7306370f4c9699ef772877efc4fd30b5cd48fa08","modified":1535533380975},{"_id":"public/js/plugins/leancloud_visitors.js","hash":"79da9d528dbf1abc6e2e3e8a5df7a6088c6308b9","modified":1535533380975},{"_id":"public/js/plugins/local_search.js","hash":"46485dff1f7616a3e9ebdfd04e97f75aae9253eb","modified":1535533380976},{"_id":"public/js/plugins/valine.js","hash":"dae4adaee5f5f672320d878532f1fa976af6dbfe","modified":1535533380976},{"_id":"public/js/plugins/fastclick.js","hash":"b48481265d9713f64872b6597db620be9cd8f9b3","modified":1535533380977},{"_id":"public/js/plugins/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1535533380978},{"_id":"public/js/plugins/gitmint.browser.js","hash":"3e3ad9e9ff9a6368aa272fd647b3db904e98a5b9","modified":1535533380978},{"_id":"public/img/thumb/9.jpg","hash":"a1ddd14c3eb63454d0ebebb35aa2ea1685815e0e","modified":1535533380978},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535533380979},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535533380979},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535533380980},{"_id":"public/img/thumb/10.jpg","hash":"0fa7a3ece29aa4363be21e16cfd8f8a3e2c9a879","modified":1535533381022},{"_id":"public/img/thumb/4.jpg","hash":"7e77df16248c696202230a16da8a57c16be6f246","modified":1535533381022},{"_id":"public/img/thumb/2.jpg","hash":"6e4aab3d27009889f980171f034517236f1cc689","modified":1535533381023},{"_id":"public/img/banner.png","hash":"063628a9326b0b0ad5cf4ab54ef6bc185d85cd5a","modified":1535533381041},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"c5aa7f2fe1cecbbe92e6c57d7414a4dbc731012e","modified":1535533381081},{"_id":"public/css/style.css","hash":"31d34a1270003b0431f1273d440aec470fc3e3cf","modified":1535533381599},{"_id":"public/css/third-party/gitment.css","hash":"727210bdf71124801a0f9a42842a0a6224156df1","modified":1535533381599},{"_id":"public/origin/lu2.psd","hash":"39ebf3cb8b2b62382da3a2c629bf934a29ad391e","modified":1535533381599},{"_id":"public/img/thumb/5.jpg","hash":"d6c69e0b30b2fb7825135d574eb00781bde5e993","modified":1535533381704}],"Category":[],"Data":[],"Page":[{"_content":"张强  \n==\n\n - 24岁\n - 通信工程(本科)  \n - 代码控\n - 擅长写作\n - 热爱音乐\n\n## 工作经验 ##\n    \n\n -  2015年11月--2016月，在青岛冠捷科技(AOC)实习，学习前端工作内容，初步掌握HTML、CSS知识，负责日常静态运营页面编写。\n \n -    2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。\n\n - 2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。\n \n##  我的优势 ##\n -  良好抗压能力：有压力会使我成长的更快。\n - 极强的书面表达能力：从小就爱写作。\n - 良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。\n - 良好的学习与沟通能力：有弄不懂的我一定会问。\n\n\n## 技能与项目 ##\n**1.技能**\n - 掌握HTML语义化标签、CSS常见属性与布局及CSS3动画\n - 掌握Bootstrap，能够快速搭建响应式页面\n - 掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)\n - 常逛github，熟悉commit的流程、本地GIT仓库和远程仓库对接、分支合并\n - 熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践\n - 熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax\n - 熟悉前端基本优化的方法和手段，了解XSS和CSRF\n \n **2.项目**\n*2.1中国兰州网美食频道 (尚未开源)*\nhttp://food.lanzhou.cn/ <br/>\n主导整个页面框架设计，滚动页面的逻辑。<br/>\n*2.2中国兰州网新闻页面框架重构改造(尚未开源)*                  \n旧  新闻框架（2015）：<br/>\n[旧新闻框架](http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml)\n<br/>\n新 响应式新闻框架（2017.8）：<br/>\n[响应式新闻框架](http://news.lanzhou.cn/system/2018/01/11/011492028.shtml)\n<br/>\n旧：图片新闻框架（2015）:<br/>\n[图片新闻框架](http://news.lanzhou.cn/system/2018/01/25/011501122.shtml)\n<br/>\n新：响应式图片框架（2017.8）<br/>\n[响应式图片框架](http://news.lanzhou.cn/system/2017/12/13/011475652.shtml)\n<br/>\n【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】<br/>\n*2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本*\n\n预览: https://zq-jhon.github.io/angular-demo/<br/>\n源码:https://github.com/ZQ-jhon/angular-demo<br/>\n博客记录：\n[博客记录1](http://blog.csdn.net/qq_20264891/article/details/78842927)\n[博客记录2](http://blog.csdn.net/qq_20264891/article/details/78842927)<br/>\n【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】<br/>\n*2.4 基于HEXO和GIT的个人博客*<br/>\n预览:https://ZQ-jhon.github.io<br/>\n源码:https://github.com/ZQ-jhon/ZQ-jhon.github.io<br/>\n博客记录: [基于HEXO和GIT的个人博客详细搭建及部署过程](http://blog.csdn.net/qq_20264891/article/details/79096846)<br/>\n【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】\n*2.5 原生js的插件----putThere.js 拖动DOM元素*<br/>\n\n预览:https://zq-jhon.github.io/putThere.js/<br/>\n源码:https://github.com/ZQ-jhon/putThere.js<br/>\n博客记录:[putThere.js造小轮子记录博客](http://blog.csdn.net/qq_20264891/article/details/79172246)<br/>\n【之前有一次腾讯远程面试的经历，就考了这个题。考完以后，我立马造了这个小轮子】\n\n*2.6 多动症简历*\n预览:https://zq-jhon.github.io/resume/<br/>\n源码:https://github.com/ZQ-jhon/resume<br/>\n博客记录: [多动症简历详细记录](http://blog.csdn.net/qq_20264891/article/details/79197651)<br/>\n【因为看到网上一个国外前端做了这样一份简历([http://strml.net/](http://strml.net/))，于是我自己根据JS知识，也进行了实践。】\n## 想说的话 ##\n\n - 期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。\n - 期待的工作城市：北京、上海、广州、深圳、杭州。","source":"简历.md","raw":"张强  \n==\n\n - 24岁\n - 通信工程(本科)  \n - 代码控\n - 擅长写作\n - 热爱音乐\n\n## 工作经验 ##\n    \n\n -  2015年11月--2016月，在青岛冠捷科技(AOC)实习，学习前端工作内容，初步掌握HTML、CSS知识，负责日常静态运营页面编写。\n \n -    2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。\n\n - 2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。\n \n##  我的优势 ##\n -  良好抗压能力：有压力会使我成长的更快。\n - 极强的书面表达能力：从小就爱写作。\n - 良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。\n - 良好的学习与沟通能力：有弄不懂的我一定会问。\n\n\n## 技能与项目 ##\n**1.技能**\n - 掌握HTML语义化标签、CSS常见属性与布局及CSS3动画\n - 掌握Bootstrap，能够快速搭建响应式页面\n - 掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)\n - 常逛github，熟悉commit的流程、本地GIT仓库和远程仓库对接、分支合并\n - 熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践\n - 熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax\n - 熟悉前端基本优化的方法和手段，了解XSS和CSRF\n \n **2.项目**\n*2.1中国兰州网美食频道 (尚未开源)*\nhttp://food.lanzhou.cn/ <br/>\n主导整个页面框架设计，滚动页面的逻辑。<br/>\n*2.2中国兰州网新闻页面框架重构改造(尚未开源)*                  \n旧  新闻框架（2015）：<br/>\n[旧新闻框架](http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml)\n<br/>\n新 响应式新闻框架（2017.8）：<br/>\n[响应式新闻框架](http://news.lanzhou.cn/system/2018/01/11/011492028.shtml)\n<br/>\n旧：图片新闻框架（2015）:<br/>\n[图片新闻框架](http://news.lanzhou.cn/system/2018/01/25/011501122.shtml)\n<br/>\n新：响应式图片框架（2017.8）<br/>\n[响应式图片框架](http://news.lanzhou.cn/system/2017/12/13/011475652.shtml)\n<br/>\n【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】<br/>\n*2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本*\n\n预览: https://zq-jhon.github.io/angular-demo/<br/>\n源码:https://github.com/ZQ-jhon/angular-demo<br/>\n博客记录：\n[博客记录1](http://blog.csdn.net/qq_20264891/article/details/78842927)\n[博客记录2](http://blog.csdn.net/qq_20264891/article/details/78842927)<br/>\n【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】<br/>\n*2.4 基于HEXO和GIT的个人博客*<br/>\n预览:https://ZQ-jhon.github.io<br/>\n源码:https://github.com/ZQ-jhon/ZQ-jhon.github.io<br/>\n博客记录: [基于HEXO和GIT的个人博客详细搭建及部署过程](http://blog.csdn.net/qq_20264891/article/details/79096846)<br/>\n【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】\n*2.5 原生js的插件----putThere.js 拖动DOM元素*<br/>\n\n预览:https://zq-jhon.github.io/putThere.js/<br/>\n源码:https://github.com/ZQ-jhon/putThere.js<br/>\n博客记录:[putThere.js造小轮子记录博客](http://blog.csdn.net/qq_20264891/article/details/79172246)<br/>\n【之前有一次腾讯远程面试的经历，就考了这个题。考完以后，我立马造了这个小轮子】\n\n*2.6 多动症简历*\n预览:https://zq-jhon.github.io/resume/<br/>\n源码:https://github.com/ZQ-jhon/resume<br/>\n博客记录: [多动症简历详细记录](http://blog.csdn.net/qq_20264891/article/details/79197651)<br/>\n【因为看到网上一个国外前端做了这样一份简历([http://strml.net/](http://strml.net/))，于是我自己根据JS知识，也进行了实践。】\n## 想说的话 ##\n\n - 期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。\n - 期待的工作城市：北京、上海、广州、深圳、杭州。","date":"2018-08-29T05:59:20.748Z","updated":"2018-08-29T05:59:20.748Z","path":"简历.html","title":"","comments":1,"layout":"page","_id":"cjlewxded0000jgv4w3xyup0l","content":"<h1 id=\"张强\"><a href=\"#张强\" class=\"headerlink\" title=\"张强  \"></a>张强  </h1><ul>\n<li>24岁</li>\n<li>通信工程(本科)  </li>\n<li>代码控</li>\n<li>擅长写作</li>\n<li>热爱音乐</li>\n</ul>\n<h2 id=\"工作经验\"><a href=\"#工作经验\" class=\"headerlink\" title=\"工作经验\"></a>工作经验</h2><ul>\n<li><p>2015年11月–2016月，在青岛冠捷科技(AOC)实习，学习前端工作内容，初步掌握HTML、CSS知识，负责日常静态运营页面编写。</p>\n</li>\n<li><p>2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。</p>\n</li>\n<li><p>2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。</p>\n</li>\n</ul>\n<h2 id=\"我的优势\"><a href=\"#我的优势\" class=\"headerlink\" title=\"我的优势\"></a>我的优势</h2><ul>\n<li>良好抗压能力：有压力会使我成长的更快。</li>\n<li>极强的书面表达能力：从小就爱写作。</li>\n<li>良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。</li>\n<li>良好的学习与沟通能力：有弄不懂的我一定会问。</li>\n</ul>\n<h2 id=\"技能与项目\"><a href=\"#技能与项目\" class=\"headerlink\" title=\"技能与项目\"></a>技能与项目</h2><p><strong>1.技能</strong></p>\n<ul>\n<li>掌握HTML语义化标签、CSS常见属性与布局及CSS3动画</li>\n<li>掌握Bootstrap，能够快速搭建响应式页面</li>\n<li>掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)</li>\n<li>常逛github，熟悉commit的流程、本地GIT仓库和远程仓库对接、分支合并</li>\n<li>熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践</li>\n<li>熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax</li>\n<li><p>熟悉前端基本优化的方法和手段，了解XSS和CSRF</p>\n<p><strong>2.项目</strong><br><em>2.1中国兰州网美食频道 (尚未开源)</em><br><a href=\"http://food.lanzhou.cn/\" target=\"_blank\" rel=\"noopener\">http://food.lanzhou.cn/</a> <br><br>主导整个页面框架设计，滚动页面的逻辑。<br><br><em>2.2中国兰州网新闻页面框架重构改造(尚未开源)</em><br>旧  新闻框架（2015）：<br><br><a href=\"http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml\" target=\"_blank\" rel=\"noopener\">旧新闻框架</a><br><br><br>新 响应式新闻框架（2017.8）：<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/11/011492028.shtml\" target=\"_blank\" rel=\"noopener\">响应式新闻框架</a><br><br><br>旧：图片新闻框架（2015）:<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/25/011501122.shtml\" target=\"_blank\" rel=\"noopener\">图片新闻框架</a><br><br><br>新：响应式图片框架（2017.8）<br><br><a href=\"http://news.lanzhou.cn/system/2017/12/13/011475652.shtml\" target=\"_blank\" rel=\"noopener\">响应式图片框架</a><br><br><br>【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】<br><br><em>2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本</em></p>\n</li>\n</ul>\n<p>预览: <a href=\"https://zq-jhon.github.io/angular-demo/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/angular-demo/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/angular-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/angular-demo</a><br><br>博客记录：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录1</a><br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录2</a><br><br>【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】<br><br><em>2.4 基于HEXO和GIT的个人博客</em><br><br>预览:<a href=\"https://ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://ZQ-jhon.github.io</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/ZQ-jhon.github.io</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79096846\" target=\"_blank\" rel=\"noopener\">基于HEXO和GIT的个人博客详细搭建及部署过程</a><br><br>【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】<br><em>2.5 原生js的插件—-putThere.js 拖动DOM元素</em><br></p>\n<p>预览:<a href=\"https://zq-jhon.github.io/putThere.js/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/putThere.js/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/putThere.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/putThere.js</a><br><br>博客记录:<a href=\"http://blog.csdn.net/qq_20264891/article/details/79172246\" target=\"_blank\" rel=\"noopener\">putThere.js造小轮子记录博客</a><br><br>【之前有一次腾讯远程面试的经历，就考了这个题。考完以后，我立马造了这个小轮子】</p>\n<p><em>2.6 多动症简历</em><br>预览:<a href=\"https://zq-jhon.github.io/resume/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/resume/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/resume\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/resume</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79197651\" target=\"_blank\" rel=\"noopener\">多动症简历详细记录</a><br><br>【因为看到网上一个国外前端做了这样一份简历(<a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a>)，于是我自己根据JS知识，也进行了实践。】</p>\n<h2 id=\"想说的话\"><a href=\"#想说的话\" class=\"headerlink\" title=\"想说的话\"></a>想说的话</h2><ul>\n<li>期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。</li>\n<li>期待的工作城市：北京、上海、广州、深圳、杭州。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"张强\"><a href=\"#张强\" class=\"headerlink\" title=\"张强  \"></a>张强  </h1><ul>\n<li>24岁</li>\n<li>通信工程(本科)  </li>\n<li>代码控</li>\n<li>擅长写作</li>\n<li>热爱音乐</li>\n</ul>\n<h2 id=\"工作经验\"><a href=\"#工作经验\" class=\"headerlink\" title=\"工作经验\"></a>工作经验</h2><ul>\n<li><p>2015年11月–2016月，在青岛冠捷科技(AOC)实习，学习前端工作内容，初步掌握HTML、CSS知识，负责日常静态运营页面编写。</p>\n</li>\n<li><p>2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。</p>\n</li>\n<li><p>2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。</p>\n</li>\n</ul>\n<h2 id=\"我的优势\"><a href=\"#我的优势\" class=\"headerlink\" title=\"我的优势\"></a>我的优势</h2><ul>\n<li>良好抗压能力：有压力会使我成长的更快。</li>\n<li>极强的书面表达能力：从小就爱写作。</li>\n<li>良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。</li>\n<li>良好的学习与沟通能力：有弄不懂的我一定会问。</li>\n</ul>\n<h2 id=\"技能与项目\"><a href=\"#技能与项目\" class=\"headerlink\" title=\"技能与项目\"></a>技能与项目</h2><p><strong>1.技能</strong></p>\n<ul>\n<li>掌握HTML语义化标签、CSS常见属性与布局及CSS3动画</li>\n<li>掌握Bootstrap，能够快速搭建响应式页面</li>\n<li>掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)</li>\n<li>常逛github，熟悉commit的流程、本地GIT仓库和远程仓库对接、分支合并</li>\n<li>熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践</li>\n<li>熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax</li>\n<li><p>熟悉前端基本优化的方法和手段，了解XSS和CSRF</p>\n<p><strong>2.项目</strong><br><em>2.1中国兰州网美食频道 (尚未开源)</em><br><a href=\"http://food.lanzhou.cn/\" target=\"_blank\" rel=\"noopener\">http://food.lanzhou.cn/</a> <br><br>主导整个页面框架设计，滚动页面的逻辑。<br><br><em>2.2中国兰州网新闻页面框架重构改造(尚未开源)</em><br>旧  新闻框架（2015）：<br><br><a href=\"http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml\" target=\"_blank\" rel=\"noopener\">旧新闻框架</a><br><br><br>新 响应式新闻框架（2017.8）：<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/11/011492028.shtml\" target=\"_blank\" rel=\"noopener\">响应式新闻框架</a><br><br><br>旧：图片新闻框架（2015）:<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/25/011501122.shtml\" target=\"_blank\" rel=\"noopener\">图片新闻框架</a><br><br><br>新：响应式图片框架（2017.8）<br><br><a href=\"http://news.lanzhou.cn/system/2017/12/13/011475652.shtml\" target=\"_blank\" rel=\"noopener\">响应式图片框架</a><br><br><br>【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】<br><br><em>2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本</em></p>\n</li>\n</ul>\n<p>预览: <a href=\"https://zq-jhon.github.io/angular-demo/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/angular-demo/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/angular-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/angular-demo</a><br><br>博客记录：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录1</a><br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录2</a><br><br>【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】<br><br><em>2.4 基于HEXO和GIT的个人博客</em><br><br>预览:<a href=\"https://ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://ZQ-jhon.github.io</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/ZQ-jhon.github.io</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79096846\" target=\"_blank\" rel=\"noopener\">基于HEXO和GIT的个人博客详细搭建及部署过程</a><br><br>【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】<br><em>2.5 原生js的插件—-putThere.js 拖动DOM元素</em><br></p>\n<p>预览:<a href=\"https://zq-jhon.github.io/putThere.js/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/putThere.js/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/putThere.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/putThere.js</a><br><br>博客记录:<a href=\"http://blog.csdn.net/qq_20264891/article/details/79172246\" target=\"_blank\" rel=\"noopener\">putThere.js造小轮子记录博客</a><br><br>【之前有一次腾讯远程面试的经历，就考了这个题。考完以后，我立马造了这个小轮子】</p>\n<p><em>2.6 多动症简历</em><br>预览:<a href=\"https://zq-jhon.github.io/resume/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/resume/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/resume\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/resume</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79197651\" target=\"_blank\" rel=\"noopener\">多动症简历详细记录</a><br><br>【因为看到网上一个国外前端做了这样一份简历(<a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a>)，于是我自己根据JS知识，也进行了实践。】</p>\n<h2 id=\"想说的话\"><a href=\"#想说的话\" class=\"headerlink\" title=\"想说的话\"></a>想说的话</h2><ul>\n<li>期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。</li>\n<li>期待的工作城市：北京、上海、广州、深圳、杭州。</li>\n</ul>\n"},{"title":"留言板","date":"2018-01-19T01:01:21.000Z","tag":["about"],"reward":false,"comment":false,"share":true,"_content":"","source":"categories/index.md","raw":"---\ntitle: 留言板 \ndate: 2018-01-19 09:01:21\ntag: [about]\nreward: false\ncomment: false\nshare: true\n---\n","updated":"2018-08-29T05:59:20.745Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjlewxdek0002jgv4vmazuyt3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About Me","date":"2018-01-19T01:01:21.000Z","tag":["about"],"reward":false,"comment":false,"share":true,"_content":"\n\n挂在鹿角上的钟停了\n\n生活是一次机会\n\n仅仅一次\n\n谁校对时间\n\n谁就会突然老去\n\n北岛——《无题》\n\n\n\n","source":"about/index.md","raw":"---\ntitle: About Me \ndate: 2018-01-19 09:01:21\ntag: [about]\nreward: false\ncomment: false\nshare: true\n---\n\n\n挂在鹿角上的钟停了\n\n生活是一次机会\n\n仅仅一次\n\n谁校对时间\n\n谁就会突然老去\n\n北岛——《无题》\n\n\n\n","updated":"2018-08-29T05:59:20.733Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjlewxdeo0004jgv432h3lcvs","content":"<p>挂在鹿角上的钟停了</p>\n<p>生活是一次机会</p>\n<p>仅仅一次</p>\n<p>谁校对时间</p>\n<p>谁就会突然老去</p>\n<p>北岛——《无题》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>挂在鹿角上的钟停了</p>\n<p>生活是一次机会</p>\n<p>仅仅一次</p>\n<p>谁校对时间</p>\n<p>谁就会突然老去</p>\n<p>北岛——《无题》</p>\n"},{"title":"About Me","date":"2018-01-19T01:01:21.000Z","tag":["about"],"reward":false,"comment":false,"share":true,"_content":"﻿张强  \n==\n[GitHub博客](https://ZQ-jhon.github.io)\n<br/>\n[CSDN博客](http://blog.csdn.net/qq_20264891)\n - 24岁\n - 通信工程(本科)  \n - 擅长写作\n - 热爱音乐\n \n## 在校经验 ##\n - 2012年下半年，任职学校贴吧大吧主，负责与百度贴吧官方申请活动物资，负责策划线下活动，负责向校方申请活动场地，拉赞助等。有良好的组织和策划能力，曾经发起向大凉山贫困地区募捐活动，筹集善款1600+元，衣物/书籍 20+ 编织袋。\n 链接:[贴吧大凉山活动募捐总结](http://tieba.baidu.com/p/2067459311?see_lz=1)\n - 2014年，在青岛绿城房地产有限公司实习渠道专员。\n\n\n## 工作经验 ##\n     \n -  2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。\n\n - 2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。\n \n - 2018年，怀着憧憬来到北京，就职于 《光辉城市》科技有限公司，任职前端开发( Angular 6.0 + )，负责官网后台组件开发/重构，对接 API，前沿知识学习并利用到项目中，混合应用（Ionic + Electron）\n \n##  我的优势 ##\n -  良好抗压能力：有压力会使我成长的更快。\n - 极强的书面表达能力：从小就爱写作。\n - 良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。\n - 良好的学习与沟通能力：有弄不懂的我一定会问。\n\n\n## 技能与项目 ##\n\n\n**1.技能**\n\n - 掌握HTML语义化标签、CSS常见属性与布局(Flex,Grid)及CSS3新特性\n - 掌握Bootstrap，能够快速搭建响应式页面\n - 掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)，熟练使用 TS,例如枚举，解构，泛型，接口等\n - 常逛github，熟悉git,svn等版本控制工具，会使用 commitlint 来语义化的 commit\n - 熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践\n - 熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax\n - 熟悉前端优化的方法和手段\n \n**2.项目/实践**\n <br/>\n2.0专题汇总\n\n2.1中国兰州网美食频道 (尚未开源)\nhttp://food.lanzhou.cn/ <br/> \n【主导整个页面框架设计，滚动页面的逻辑。】\n<br/>\n<br/>\n<br/>\n2.2中国兰州网新闻页面框架重构改造(尚未开源)   <br/>             \n旧  新闻框架（2015）：<br/>\n[旧新闻框架](http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml)\n<br/>\n新 响应式新闻框架（2017.8）：<br/>\n[响应式新闻框架](http://news.lanzhou.cn/system/2018/01/11/011492028.shtml)\n<br/>\n旧：图片新闻框架（2015）:<br/>\n[图片新闻框架](http://news.lanzhou.cn/system/2018/01/25/011501122.shtml)\n<br/>\n新：响应式图片框架（2017.8）<br/>\n[响应式图片框架](http://news.lanzhou.cn/system/2017/12/13/011475652.shtml)\n<br/>\n【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】\n<br/>\n<br/>\n<br/>\n2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本<br/>\n\n预览: https://zq-jhon.github.io/angular-demo/<br/>\n源码:https://github.com/ZQ-jhon/angular-demo<br/>\n博客记录：<br/>\n[博客记录1](http://blog.csdn.net/qq_20264891/article/details/78842927)\n[博客记录2](http://blog.csdn.net/qq_20264891/article/details/78842927)<br/>\n【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】\n<br/>\n<br/>\n<br/>\n2.4 基于HEXO和GIT的个人博客<br/>\n预览:https://ZQ-jhon.github.io<br/>\n源码:https://github.com/ZQ-jhon/ZQ-jhon.github.io<br/>\n博客记录: [基于HEXO和GIT的个人博客详细搭建及部署过程](http://blog.csdn.net/qq_20264891/article/details/79096846)<br/>\n【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】\n<br/>\n<br/>\n<br/>\n2.5 原生js的插件----putThere.js 拖动DOM元素<br/>\n\n预览:https://zq-jhon.github.io/putThere.js/<br/>\n源码:https://github.com/ZQ-jhon/putThere.js<br/>\n博客记录:[putThere.js造小轮子记录博客](http://blog.csdn.net/qq_20264891/article/details/79172246)<br/>\n【之前对360浏览器的首页缩略图书签拖动感兴趣，我立马造了这个小轮子】\n<br/>\n<br/>\n<br/>\n2.6 多动症简历\n预览:https://zq-jhon.github.io/resume/<br/>\n源码:https://github.com/ZQ-jhon/resume<br/>\n博客记录: [多动症简历详细记录](http://blog.csdn.net/qq_20264891/article/details/79197651)<br/>\n【因为看到网上一个国外前端做了这样一份简历([http://strml.net/](http://strml.net/))，于是我自己根据JS知识，也进行了实践。】\n<br/>\n<br/>\n<br/>\n## 想说的话 ##\n<br/>\n\n - 期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。\n - 期待的工作城市：北京、上海、广州、深圳、杭州。\n - 期待的发展：可以成为一名全栈开发人员。\n - 何时入职：本人目前在老家甘肃兰州，正月十五启程！\n - 写于2018年2月5日","source":"about/个人简历.md","raw":"---\ntitle: About Me \ndate: 2018-01-19 09:01:21\ntag: [about]\nreward: false\ncomment: false\nshare: true\n---\n﻿张强  \n==\n[GitHub博客](https://ZQ-jhon.github.io)\n<br/>\n[CSDN博客](http://blog.csdn.net/qq_20264891)\n - 24岁\n - 通信工程(本科)  \n - 擅长写作\n - 热爱音乐\n \n## 在校经验 ##\n - 2012年下半年，任职学校贴吧大吧主，负责与百度贴吧官方申请活动物资，负责策划线下活动，负责向校方申请活动场地，拉赞助等。有良好的组织和策划能力，曾经发起向大凉山贫困地区募捐活动，筹集善款1600+元，衣物/书籍 20+ 编织袋。\n 链接:[贴吧大凉山活动募捐总结](http://tieba.baidu.com/p/2067459311?see_lz=1)\n - 2014年，在青岛绿城房地产有限公司实习渠道专员。\n\n\n## 工作经验 ##\n     \n -  2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。\n\n - 2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。\n \n - 2018年，怀着憧憬来到北京，就职于 《光辉城市》科技有限公司，任职前端开发( Angular 6.0 + )，负责官网后台组件开发/重构，对接 API，前沿知识学习并利用到项目中，混合应用（Ionic + Electron）\n \n##  我的优势 ##\n -  良好抗压能力：有压力会使我成长的更快。\n - 极强的书面表达能力：从小就爱写作。\n - 良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。\n - 良好的学习与沟通能力：有弄不懂的我一定会问。\n\n\n## 技能与项目 ##\n\n\n**1.技能**\n\n - 掌握HTML语义化标签、CSS常见属性与布局(Flex,Grid)及CSS3新特性\n - 掌握Bootstrap，能够快速搭建响应式页面\n - 掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)，熟练使用 TS,例如枚举，解构，泛型，接口等\n - 常逛github，熟悉git,svn等版本控制工具，会使用 commitlint 来语义化的 commit\n - 熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践\n - 熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax\n - 熟悉前端优化的方法和手段\n \n**2.项目/实践**\n <br/>\n2.0专题汇总\n\n2.1中国兰州网美食频道 (尚未开源)\nhttp://food.lanzhou.cn/ <br/> \n【主导整个页面框架设计，滚动页面的逻辑。】\n<br/>\n<br/>\n<br/>\n2.2中国兰州网新闻页面框架重构改造(尚未开源)   <br/>             \n旧  新闻框架（2015）：<br/>\n[旧新闻框架](http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml)\n<br/>\n新 响应式新闻框架（2017.8）：<br/>\n[响应式新闻框架](http://news.lanzhou.cn/system/2018/01/11/011492028.shtml)\n<br/>\n旧：图片新闻框架（2015）:<br/>\n[图片新闻框架](http://news.lanzhou.cn/system/2018/01/25/011501122.shtml)\n<br/>\n新：响应式图片框架（2017.8）<br/>\n[响应式图片框架](http://news.lanzhou.cn/system/2017/12/13/011475652.shtml)\n<br/>\n【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】\n<br/>\n<br/>\n<br/>\n2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本<br/>\n\n预览: https://zq-jhon.github.io/angular-demo/<br/>\n源码:https://github.com/ZQ-jhon/angular-demo<br/>\n博客记录：<br/>\n[博客记录1](http://blog.csdn.net/qq_20264891/article/details/78842927)\n[博客记录2](http://blog.csdn.net/qq_20264891/article/details/78842927)<br/>\n【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】\n<br/>\n<br/>\n<br/>\n2.4 基于HEXO和GIT的个人博客<br/>\n预览:https://ZQ-jhon.github.io<br/>\n源码:https://github.com/ZQ-jhon/ZQ-jhon.github.io<br/>\n博客记录: [基于HEXO和GIT的个人博客详细搭建及部署过程](http://blog.csdn.net/qq_20264891/article/details/79096846)<br/>\n【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】\n<br/>\n<br/>\n<br/>\n2.5 原生js的插件----putThere.js 拖动DOM元素<br/>\n\n预览:https://zq-jhon.github.io/putThere.js/<br/>\n源码:https://github.com/ZQ-jhon/putThere.js<br/>\n博客记录:[putThere.js造小轮子记录博客](http://blog.csdn.net/qq_20264891/article/details/79172246)<br/>\n【之前对360浏览器的首页缩略图书签拖动感兴趣，我立马造了这个小轮子】\n<br/>\n<br/>\n<br/>\n2.6 多动症简历\n预览:https://zq-jhon.github.io/resume/<br/>\n源码:https://github.com/ZQ-jhon/resume<br/>\n博客记录: [多动症简历详细记录](http://blog.csdn.net/qq_20264891/article/details/79197651)<br/>\n【因为看到网上一个国外前端做了这样一份简历([http://strml.net/](http://strml.net/))，于是我自己根据JS知识，也进行了实践。】\n<br/>\n<br/>\n<br/>\n## 想说的话 ##\n<br/>\n\n - 期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。\n - 期待的工作城市：北京、上海、广州、深圳、杭州。\n - 期待的发展：可以成为一名全栈开发人员。\n - 何时入职：本人目前在老家甘肃兰州，正月十五启程！\n - 写于2018年2月5日","updated":"2018-08-29T05:59:20.744Z","path":"about/个人简历.html","comments":1,"layout":"page","_id":"cjlewxdex0007jgv4wh1zhzvo","content":"<h1 id=\"张强\"><a href=\"#张强\" class=\"headerlink\" title=\"﻿张强  \"></a>﻿张强  </h1><p><a href=\"https://ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">GitHub博客</a><br><br><br><a href=\"http://blog.csdn.net/qq_20264891\" target=\"_blank\" rel=\"noopener\">CSDN博客</a></p>\n<ul>\n<li>24岁</li>\n<li>通信工程(本科)  </li>\n<li>擅长写作</li>\n<li>热爱音乐</li>\n</ul>\n<h2 id=\"在校经验\"><a href=\"#在校经验\" class=\"headerlink\" title=\"在校经验\"></a>在校经验</h2><ul>\n<li>2012年下半年，任职学校贴吧大吧主，负责与百度贴吧官方申请活动物资，负责策划线下活动，负责向校方申请活动场地，拉赞助等。有良好的组织和策划能力，曾经发起向大凉山贫困地区募捐活动，筹集善款1600+元，衣物/书籍 20+ 编织袋。<br>链接:<a href=\"http://tieba.baidu.com/p/2067459311?see_lz=1\" target=\"_blank\" rel=\"noopener\">贴吧大凉山活动募捐总结</a></li>\n<li>2014年，在青岛绿城房地产有限公司实习渠道专员。</li>\n</ul>\n<h2 id=\"工作经验\"><a href=\"#工作经验\" class=\"headerlink\" title=\"工作经验\"></a>工作经验</h2><ul>\n<li><p>2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。</p>\n</li>\n<li><p>2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。</p>\n</li>\n<li><p>2018年，怀着憧憬来到北京，就职于 《光辉城市》科技有限公司，任职前端开发( Angular 6.0 + )，负责官网后台组件开发/重构，对接 API，前沿知识学习并利用到项目中，混合应用（Ionic + Electron）</p>\n</li>\n</ul>\n<h2 id=\"我的优势\"><a href=\"#我的优势\" class=\"headerlink\" title=\"我的优势\"></a>我的优势</h2><ul>\n<li>良好抗压能力：有压力会使我成长的更快。</li>\n<li>极强的书面表达能力：从小就爱写作。</li>\n<li>良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。</li>\n<li>良好的学习与沟通能力：有弄不懂的我一定会问。</li>\n</ul>\n<h2 id=\"技能与项目\"><a href=\"#技能与项目\" class=\"headerlink\" title=\"技能与项目\"></a>技能与项目</h2><p><strong>1.技能</strong></p>\n<ul>\n<li>掌握HTML语义化标签、CSS常见属性与布局(Flex,Grid)及CSS3新特性</li>\n<li>掌握Bootstrap，能够快速搭建响应式页面</li>\n<li>掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)，熟练使用 TS,例如枚举，解构，泛型，接口等</li>\n<li>常逛github，熟悉git,svn等版本控制工具，会使用 commitlint 来语义化的 commit</li>\n<li>熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践</li>\n<li>熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax</li>\n<li>熟悉前端优化的方法和手段</li>\n</ul>\n<p><strong>2.项目/实践</strong><br> <br><br>2.0专题汇总</p>\n<p>2.1中国兰州网美食频道 (尚未开源)<br><a href=\"http://food.lanzhou.cn/\" target=\"_blank\" rel=\"noopener\">http://food.lanzhou.cn/</a> <br><br>【主导整个页面框架设计，滚动页面的逻辑。】<br><br><br><br><br><br><br>2.2中国兰州网新闻页面框架重构改造(尚未开源)   <br><br>旧  新闻框架（2015）：<br><br><a href=\"http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml\" target=\"_blank\" rel=\"noopener\">旧新闻框架</a><br><br><br>新 响应式新闻框架（2017.8）：<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/11/011492028.shtml\" target=\"_blank\" rel=\"noopener\">响应式新闻框架</a><br><br><br>旧：图片新闻框架（2015）:<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/25/011501122.shtml\" target=\"_blank\" rel=\"noopener\">图片新闻框架</a><br><br><br>新：响应式图片框架（2017.8）<br><br><a href=\"http://news.lanzhou.cn/system/2017/12/13/011475652.shtml\" target=\"_blank\" rel=\"noopener\">响应式图片框架</a><br><br><br>【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】<br><br><br><br><br><br><br>2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本<br></p>\n<p>预览: <a href=\"https://zq-jhon.github.io/angular-demo/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/angular-demo/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/angular-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/angular-demo</a><br><br>博客记录：<br><br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录1</a><br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录2</a><br><br>【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】<br><br><br><br><br><br><br>2.4 基于HEXO和GIT的个人博客<br><br>预览:<a href=\"https://ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://ZQ-jhon.github.io</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/ZQ-jhon.github.io</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79096846\" target=\"_blank\" rel=\"noopener\">基于HEXO和GIT的个人博客详细搭建及部署过程</a><br><br>【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】<br><br><br><br><br><br><br>2.5 原生js的插件—-putThere.js 拖动DOM元素<br></p>\n<p>预览:<a href=\"https://zq-jhon.github.io/putThere.js/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/putThere.js/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/putThere.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/putThere.js</a><br><br>博客记录:<a href=\"http://blog.csdn.net/qq_20264891/article/details/79172246\" target=\"_blank\" rel=\"noopener\">putThere.js造小轮子记录博客</a><br><br>【之前对360浏览器的首页缩略图书签拖动感兴趣，我立马造了这个小轮子】<br><br><br><br><br><br><br>2.6 多动症简历<br>预览:<a href=\"https://zq-jhon.github.io/resume/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/resume/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/resume\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/resume</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79197651\" target=\"_blank\" rel=\"noopener\">多动症简历详细记录</a><br><br>【因为看到网上一个国外前端做了这样一份简历(<a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a>)，于是我自己根据JS知识，也进行了实践。】<br><br><br><br><br><br></p>\n<h2 id=\"想说的话\"><a href=\"#想说的话\" class=\"headerlink\" title=\"想说的话\"></a>想说的话</h2><p><br></p>\n<ul>\n<li>期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。</li>\n<li>期待的工作城市：北京、上海、广州、深圳、杭州。</li>\n<li>期待的发展：可以成为一名全栈开发人员。</li>\n<li>何时入职：本人目前在老家甘肃兰州，正月十五启程！</li>\n<li>写于2018年2月5日</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"张强\"><a href=\"#张强\" class=\"headerlink\" title=\"﻿张强  \"></a>﻿张强  </h1><p><a href=\"https://ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">GitHub博客</a><br><br><br><a href=\"http://blog.csdn.net/qq_20264891\" target=\"_blank\" rel=\"noopener\">CSDN博客</a></p>\n<ul>\n<li>24岁</li>\n<li>通信工程(本科)  </li>\n<li>擅长写作</li>\n<li>热爱音乐</li>\n</ul>\n<h2 id=\"在校经验\"><a href=\"#在校经验\" class=\"headerlink\" title=\"在校经验\"></a>在校经验</h2><ul>\n<li>2012年下半年，任职学校贴吧大吧主，负责与百度贴吧官方申请活动物资，负责策划线下活动，负责向校方申请活动场地，拉赞助等。有良好的组织和策划能力，曾经发起向大凉山贫困地区募捐活动，筹集善款1600+元，衣物/书籍 20+ 编织袋。<br>链接:<a href=\"http://tieba.baidu.com/p/2067459311?see_lz=1\" target=\"_blank\" rel=\"noopener\">贴吧大凉山活动募捐总结</a></li>\n<li>2014年，在青岛绿城房地产有限公司实习渠道专员。</li>\n</ul>\n<h2 id=\"工作经验\"><a href=\"#工作经验\" class=\"headerlink\" title=\"工作经验\"></a>工作经验</h2><ul>\n<li><p>2016年7月毕业，任职青岛某艺术培训学校吉他老师，负责日常微信公众号运营、小孩吉他教学。</p>\n</li>\n<li><p>2017年初，入职中国兰州网，担任前端开发，负责专题设计、JS逻辑层交互代码、北方网后台模版渲染对接、老旧网页响应式改造重构。</p>\n</li>\n<li><p>2018年，怀着憧憬来到北京，就职于 《光辉城市》科技有限公司，任职前端开发( Angular 6.0 + )，负责官网后台组件开发/重构，对接 API，前沿知识学习并利用到项目中，混合应用（Ionic + Electron）</p>\n</li>\n</ul>\n<h2 id=\"我的优势\"><a href=\"#我的优势\" class=\"headerlink\" title=\"我的优势\"></a>我的优势</h2><ul>\n<li>良好抗压能力：有压力会使我成长的更快。</li>\n<li>极强的书面表达能力：从小就爱写作。</li>\n<li>良好的自驱能力：每天都保持写博客，看技术文章学习提升，有开源精神。</li>\n<li>良好的学习与沟通能力：有弄不懂的我一定会问。</li>\n</ul>\n<h2 id=\"技能与项目\"><a href=\"#技能与项目\" class=\"headerlink\" title=\"技能与项目\"></a>技能与项目</h2><p><strong>1.技能</strong></p>\n<ul>\n<li>掌握HTML语义化标签、CSS常见属性与布局(Flex,Grid)及CSS3新特性</li>\n<li>掌握Bootstrap，能够快速搭建响应式页面</li>\n<li>掌握JS常用API，以及闭包、原型链、面向对象和继承(ES5)，熟练使用 TS,例如枚举，解构，泛型，接口等</li>\n<li>常逛github，熟悉git,svn等版本控制工具，会使用 commitlint 来语义化的 commit</li>\n<li>熟悉Nodejs，对Webpack、AngularJs、Express进行过一定的实践</li>\n<li>熟悉Ajax异步流程，包括JQuery和Angular封装的Ajax</li>\n<li>熟悉前端优化的方法和手段</li>\n</ul>\n<p><strong>2.项目/实践</strong><br> <br><br>2.0专题汇总</p>\n<p>2.1中国兰州网美食频道 (尚未开源)<br><a href=\"http://food.lanzhou.cn/\" target=\"_blank\" rel=\"noopener\">http://food.lanzhou.cn/</a> <br><br>【主导整个页面框架设计，滚动页面的逻辑。】<br><br><br><br><br><br><br>2.2中国兰州网新闻页面框架重构改造(尚未开源)   <br><br>旧  新闻框架（2015）：<br><br><a href=\"http://lz.lanzhou.cn/system/2018/01/27/011502940.shtml\" target=\"_blank\" rel=\"noopener\">旧新闻框架</a><br><br><br>新 响应式新闻框架（2017.8）：<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/11/011492028.shtml\" target=\"_blank\" rel=\"noopener\">响应式新闻框架</a><br><br><br>旧：图片新闻框架（2015）:<br><br><a href=\"http://news.lanzhou.cn/system/2018/01/25/011501122.shtml\" target=\"_blank\" rel=\"noopener\">图片新闻框架</a><br><br><br>新：响应式图片框架（2017.8）<br><br><a href=\"http://news.lanzhou.cn/system/2017/12/13/011475652.shtml\" target=\"_blank\" rel=\"noopener\">响应式图片框架</a><br><br><br>【整个项目的技术选型、代码编写、兼容测试、灰度发布、部署上线都是我自己主动向Leader请缨完成的。其中也踩了不少的坑，主要的用了一个Bootstrap的UI框架和jQuery（前者的依赖）。】<br><br><br><br><br><br><br>2.3 Angular和Bootstrap搭建后台管理系统 1.0.0版本<br></p>\n<p>预览: <a href=\"https://zq-jhon.github.io/angular-demo/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/angular-demo/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/angular-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/angular-demo</a><br><br>博客记录：<br><br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录1</a><br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">博客记录2</a><br><br>【这是刚开始接触Angular的时候做的，了解到它的双向数据绑定非常厉害，结合之前的Bootstrap做了一个实践项目。】<br><br><br><br><br><br><br>2.4 基于HEXO和GIT的个人博客<br><br>预览:<a href=\"https://ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://ZQ-jhon.github.io</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/ZQ-jhon.github.io</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79096846\" target=\"_blank\" rel=\"noopener\">基于HEXO和GIT的个人博客详细搭建及部署过程</a><br><br>【以前面试连博客都没有，后来就像把Demo部署到线上，让面试官一眼就能看见，所以花了一两天时间找了个漂亮的HEXO主题，进行部分样式修改，结合GITHUB的知识，顺利部署上线。期间也有很多不懂的地方，也咨询了HEXO主题的作者】<br><br><br><br><br><br><br>2.5 原生js的插件—-putThere.js 拖动DOM元素<br></p>\n<p>预览:<a href=\"https://zq-jhon.github.io/putThere.js/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/putThere.js/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/putThere.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/putThere.js</a><br><br>博客记录:<a href=\"http://blog.csdn.net/qq_20264891/article/details/79172246\" target=\"_blank\" rel=\"noopener\">putThere.js造小轮子记录博客</a><br><br>【之前对360浏览器的首页缩略图书签拖动感兴趣，我立马造了这个小轮子】<br><br><br><br><br><br><br>2.6 多动症简历<br>预览:<a href=\"https://zq-jhon.github.io/resume/\" target=\"_blank\" rel=\"noopener\">https://zq-jhon.github.io/resume/</a><br><br>源码:<a href=\"https://github.com/ZQ-jhon/resume\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/resume</a><br><br>博客记录: <a href=\"http://blog.csdn.net/qq_20264891/article/details/79197651\" target=\"_blank\" rel=\"noopener\">多动症简历详细记录</a><br><br>【因为看到网上一个国外前端做了这样一份简历(<a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a>)，于是我自己根据JS知识，也进行了实践。】<br><br><br><br><br><br></p>\n<h2 id=\"想说的话\"><a href=\"#想说的话\" class=\"headerlink\" title=\"想说的话\"></a>想说的话</h2><p><br></p>\n<ul>\n<li>期待的工作氛围：良好的技术氛围，能够多学东西，不限于前端。如果想培养我成为一名全栈工程师当然再好不过啦。</li>\n<li>期待的工作城市：北京、上海、广州、深圳、杭州。</li>\n<li>期待的发展：可以成为一名全栈开发人员。</li>\n<li>何时入职：本人目前在老家甘肃兰州，正月十五启程！</li>\n<li>写于2018年2月5日</li>\n</ul>\n"},{"title":"Projects","date":"2018-01-31T08:32:37.000Z","_content":"<h4  style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"dora\"> 1.  电影 --- 绘制多啦A梦  点击在本页查看 >> </a>\ngithub:  [Fork this project online-resume on Github](https://github.com/ZQ-jhon/draw-a-dora-A-mon-online/blob/master/README.md)\n</h4>\n\n<h4  style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"vTodo\"> 2.  Vue  --- TodoList  点击在本页查看 >> </a>\ngithub:  [Fork this project TodoList-by-Vue on Github](https://github.com/ZQ-jhon/TodoList-by-vue/tree/master)\n</h4>\n<h4  style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"ngTodo\"> 3.  ng6  --- TodoList  点击在本页查看 >> </a>\ngithub:  [Fork this project TodoList-by-Vue on Github](https://github.com/ZQ-jhon/ng6-todolist)\n</h4>\n\n\n<iframe class=\"iframes\"  id=\"iframe\" src=\"https://zq-jhon.github.io/draw-a-dora-A-mon-online/\" width=\"1000\" height=\"700\"></iframe>\n\n<script src=\"https://cdn.bootcss.com/jquery/3.2.0/jquery.min.js\"></script>\n<script type=\"text/javascript\">\nvar iframe = document.getElementById('iframe');\n\nvar dora = document.getElementById('dora');\n\nvar vTodo = document.getElementById('vTodo');\n\nvar ngTodo = document.getElementById('ngTodo');\n\n\n\ndora.onclick = function(){\n\t$('#iframe').attr('src','https://zq-jhon.github.io/draw-a-dora-A-mon-online/');\n\n}\n\nvTodo.onclick = function(){\n\t$('#iframe').attr('src','https://zq-jhon.github.io/TodoList-by-vue/');\n}\n\nngTodo.onclick = function(){\n\t$('#iframe').attr('src','https://zq-jhon.github.io/ng6-todolist/dist/ngTodolist/index.html');\n}\n\t\t\n</script>","source":"projects/index.md","raw":"---\ntitle: Projects \ndate: 2018-01-31 16:32:37\n---\n<h4  style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"dora\"> 1.  电影 --- 绘制多啦A梦  点击在本页查看 >> </a>\ngithub:  [Fork this project online-resume on Github](https://github.com/ZQ-jhon/draw-a-dora-A-mon-online/blob/master/README.md)\n</h4>\n\n<h4  style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"vTodo\"> 2.  Vue  --- TodoList  点击在本页查看 >> </a>\ngithub:  [Fork this project TodoList-by-Vue on Github](https://github.com/ZQ-jhon/TodoList-by-vue/tree/master)\n</h4>\n<h4  style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"ngTodo\"> 3.  ng6  --- TodoList  点击在本页查看 >> </a>\ngithub:  [Fork this project TodoList-by-Vue on Github](https://github.com/ZQ-jhon/ng6-todolist)\n</h4>\n\n\n<iframe class=\"iframes\"  id=\"iframe\" src=\"https://zq-jhon.github.io/draw-a-dora-A-mon-online/\" width=\"1000\" height=\"700\"></iframe>\n\n<script src=\"https://cdn.bootcss.com/jquery/3.2.0/jquery.min.js\"></script>\n<script type=\"text/javascript\">\nvar iframe = document.getElementById('iframe');\n\nvar dora = document.getElementById('dora');\n\nvar vTodo = document.getElementById('vTodo');\n\nvar ngTodo = document.getElementById('ngTodo');\n\n\n\ndora.onclick = function(){\n\t$('#iframe').attr('src','https://zq-jhon.github.io/draw-a-dora-A-mon-online/');\n\n}\n\nvTodo.onclick = function(){\n\t$('#iframe').attr('src','https://zq-jhon.github.io/TodoList-by-vue/');\n}\n\nngTodo.onclick = function(){\n\t$('#iframe').attr('src','https://zq-jhon.github.io/ng6-todolist/dist/ngTodolist/index.html');\n}\n\t\t\n</script>","updated":"2018-08-29T03:54:44.828Z","path":"projects/index.html","comments":1,"layout":"page","_id":"cjlewxdez0009jgv4fv7jqxuq","content":"<h4 style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"dora\" target=\"_blank\" rel=\"noopener\"> 1.  电影 — 绘制多啦A梦  点击在本页查看 &gt;&gt; </a><br>github:  <a href=\"https://github.com/ZQ-jhon/draw-a-dora-A-mon-online/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">Fork this project online-resume on Github</a><br></h4>\n\n<h4 style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"vTodo\" target=\"_blank\" rel=\"noopener\"> 2.  Vue  — TodoList  点击在本页查看 &gt;&gt; </a><br>github:  <a href=\"https://github.com/ZQ-jhon/TodoList-by-vue/tree/master\" target=\"_blank\" rel=\"noopener\">Fork this project TodoList-by-Vue on Github</a><br></h4><br><h4 style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"ngTodo\" target=\"_blank\" rel=\"noopener\"> 3.  ng6  — TodoList  点击在本页查看 &gt;&gt; </a><br>github:  <a href=\"https://github.com/ZQ-jhon/ng6-todolist\" target=\"_blank\" rel=\"noopener\">Fork this project TodoList-by-Vue on Github</a><br></h4>\n\n\n<iframe class=\"iframes\" id=\"iframe\" src=\"https://zq-jhon.github.io/draw-a-dora-A-mon-online/\" width=\"1000\" height=\"700\"></iframe>\n\n<script src=\"https://cdn.bootcss.com/jquery/3.2.0/jquery.min.js\"></script>\n<script type=\"text/javascript\">\nvar iframe = document.getElementById('iframe');\n\nvar dora = document.getElementById('dora');\n\nvar vTodo = document.getElementById('vTodo');\n\nvar ngTodo = document.getElementById('ngTodo');\n\n\n\ndora.onclick = function(){\n    $('#iframe').attr('src','https://zq-jhon.github.io/draw-a-dora-A-mon-online/');\n\n}\n\nvTodo.onclick = function(){\n    $('#iframe').attr('src','https://zq-jhon.github.io/TodoList-by-vue/');\n}\n\nngTodo.onclick = function(){\n    $('#iframe').attr('src','https://zq-jhon.github.io/ng6-todolist/dist/ngTodolist/index.html');\n}\n\n</script>","site":{"data":{}},"excerpt":"","more":"<h4 style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"dora\" target=\"_blank\" rel=\"noopener\"> 1.  电影 — 绘制多啦A梦  点击在本页查看 &gt;&gt; </a><br>github:  <a href=\"https://github.com/ZQ-jhon/draw-a-dora-A-mon-online/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">Fork this project online-resume on Github</a><br></h4>\n\n<h4 style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"vTodo\" target=\"_blank\" rel=\"noopener\"> 2.  Vue  — TodoList  点击在本页查看 &gt;&gt; </a><br>github:  <a href=\"https://github.com/ZQ-jhon/TodoList-by-vue/tree/master\" target=\"_blank\" rel=\"noopener\">Fork this project TodoList-by-Vue on Github</a><br></h4><br><h4 style=\"text-align:left;\"> <a href=\"javascript:0;\" id=\"ngTodo\" target=\"_blank\" rel=\"noopener\"> 3.  ng6  — TodoList  点击在本页查看 &gt;&gt; </a><br>github:  <a href=\"https://github.com/ZQ-jhon/ng6-todolist\" target=\"_blank\" rel=\"noopener\">Fork this project TodoList-by-Vue on Github</a><br></h4>\n\n\n<iframe class=\"iframes\" id=\"iframe\" src=\"https://zq-jhon.github.io/draw-a-dora-A-mon-online/\" width=\"1000\" height=\"700\"></iframe>\n\n<script src=\"https://cdn.bootcss.com/jquery/3.2.0/jquery.min.js\"></script>\n<script type=\"text/javascript\">\nvar iframe = document.getElementById('iframe');\n\nvar dora = document.getElementById('dora');\n\nvar vTodo = document.getElementById('vTodo');\n\nvar ngTodo = document.getElementById('ngTodo');\n\n\n\ndora.onclick = function(){\n    $('#iframe').attr('src','https://zq-jhon.github.io/draw-a-dora-A-mon-online/');\n\n}\n\nvTodo.onclick = function(){\n    $('#iframe').attr('src','https://zq-jhon.github.io/TodoList-by-vue/');\n}\n\nngTodo.onclick = function(){\n    $('#iframe').attr('src','https://zq-jhon.github.io/ng6-todolist/dist/ngTodolist/index.html');\n}\n\n</script>"},{"title":"Note","date":"2018-08-19T01:01:21.000Z","tag":["about"],"reward":false,"comment":false,"share":true,"_content":"<h3>Compare Version</h3>\n```javascript\n/**\n * view it online : https://codepen.io/zq-jhon/pen/oPXorj\n */\ntype Vers = {\n    // 主版本，副版本，小版本号\n    main: number;\n    minor: number;\n    beta: string;\n}\n\nclass Version {\n    constructor(v1: string, v2: string) {\n\n        const result = this.compareVersion(\n            this.flatVersion(v1),\n            this.flatVersion(v2)\n        )\n        console.log(result);\n    }\n    flatVersion(v: string): Vers {\n        const verArr = v.split('.'); // eg: ['1','2','3a']\n        let vs = {\n            main: + verArr[0],\n            minor: + verArr[1],\n            beta: verArr[2],\n        }\n        return vs;\n    }\n    /**\n     *  \n     * @param v1 compare parama1\n     * @param v2 compare parama2\n     * \n     * @returns  result = 1 , v1 > v2; \n     *           result = 0 , v1 = v2; \n     *           result = -1 , v1 < v2;\n     */\n    compareVersion(v1: Vers, v2: Vers): number {\n        if (v1.main === v2.main && v1.minor === v2.minor && v1.beta === v2.beta) { return 0; }\n\n\n        // 判断首位\n        let result = v1.main > v2.main ? 1 :  -1;\n\n        if(v1.main === v2.main) {\n            // ...如果首位相等，判断第二位\n           result =  v1.minor > v2.minor ? 1 : -1;\n\n           if(v1.minor === v2.minor) {\n               // ... ... 如果第二位相等，判断第三位\n               result = v1.beta > v2.beta ? 1 : -1; \n           }\n        }\n\n        return result;\n    }\n}\n\n// 实例出一个 Version 对象，填入两个比较的参数，进行比较，控制台看结果。\nconst v1 = '1.2.4b', v2 = '1.2.3a';\nnew Version(v1, v2);\n\n\n\n\n```","source":"tags/index.md","raw":"---\ntitle: Note\ndate: 2018-08-19 09:01:21\ntag: [about]\nreward: false\ncomment: false\nshare: true\n---\n<h3>Compare Version</h3>\n```javascript\n/**\n * view it online : https://codepen.io/zq-jhon/pen/oPXorj\n */\ntype Vers = {\n    // 主版本，副版本，小版本号\n    main: number;\n    minor: number;\n    beta: string;\n}\n\nclass Version {\n    constructor(v1: string, v2: string) {\n\n        const result = this.compareVersion(\n            this.flatVersion(v1),\n            this.flatVersion(v2)\n        )\n        console.log(result);\n    }\n    flatVersion(v: string): Vers {\n        const verArr = v.split('.'); // eg: ['1','2','3a']\n        let vs = {\n            main: + verArr[0],\n            minor: + verArr[1],\n            beta: verArr[2],\n        }\n        return vs;\n    }\n    /**\n     *  \n     * @param v1 compare parama1\n     * @param v2 compare parama2\n     * \n     * @returns  result = 1 , v1 > v2; \n     *           result = 0 , v1 = v2; \n     *           result = -1 , v1 < v2;\n     */\n    compareVersion(v1: Vers, v2: Vers): number {\n        if (v1.main === v2.main && v1.minor === v2.minor && v1.beta === v2.beta) { return 0; }\n\n\n        // 判断首位\n        let result = v1.main > v2.main ? 1 :  -1;\n\n        if(v1.main === v2.main) {\n            // ...如果首位相等，判断第二位\n           result =  v1.minor > v2.minor ? 1 : -1;\n\n           if(v1.minor === v2.minor) {\n               // ... ... 如果第二位相等，判断第三位\n               result = v1.beta > v2.beta ? 1 : -1; \n           }\n        }\n\n        return result;\n    }\n}\n\n// 实例出一个 Version 对象，填入两个比较的参数，进行比较，控制台看结果。\nconst v1 = '1.2.4b', v2 = '1.2.3a';\nnew Version(v1, v2);\n\n\n\n\n```","updated":"2018-08-29T05:59:20.747Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjlewxdi50040jgv4irp2a5ps","content":"<p></p><h3>Compare Version</h3><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * view it online : https://codepen.io/zq-jhon/pen/oPXorj</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">type Vers = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主版本，副版本，小版本号</span></span><br><span class=\"line\">    main: number;</span><br><span class=\"line\">    minor: number;</span><br><span class=\"line\">    beta: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Version</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(v1: string, v2: string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">this</span>.compareVersion(</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.flatVersion(v1),</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.flatVersion(v2)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    flatVersion(v: string): Vers &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> verArr = v.split(<span class=\"string\">'.'</span>); <span class=\"comment\">// eg: ['1','2','3a']</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> vs = &#123;</span><br><span class=\"line\">            main: + verArr[<span class=\"number\">0</span>],</span><br><span class=\"line\">            minor: + verArr[<span class=\"number\">1</span>],</span><br><span class=\"line\">            beta: verArr[<span class=\"number\">2</span>],</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * @param v1 compare parama1</span></span><br><span class=\"line\"><span class=\"comment\">     * @param v2 compare parama2</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * @returns  result = 1 , v1 &gt; v2; </span></span><br><span class=\"line\"><span class=\"comment\">     *           result = 0 , v1 = v2; </span></span><br><span class=\"line\"><span class=\"comment\">     *           result = -1 , v1 &lt; v2;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    compareVersion(v1: Vers, <span class=\"attr\">v2</span>: Vers): number &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v1.main === v2.main &amp;&amp; v1.minor === v2.minor &amp;&amp; v1.beta === v2.beta) &#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断首位</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = v1.main &gt; v2.main ? <span class=\"number\">1</span> :  <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v1.main === v2.main) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...如果首位相等，判断第二位</span></span><br><span class=\"line\">           result =  v1.minor &gt; v2.minor ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(v1.minor === v2.minor) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// ... ... 如果第二位相等，判断第三位</span></span><br><span class=\"line\">               result = v1.beta &gt; v2.beta ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>; </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例出一个 Version 对象，填入两个比较的参数，进行比较，控制台看结果。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> v1 = <span class=\"string\">'1.2.4b'</span>, v2 = <span class=\"string\">'1.2.3a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">new</span> Version(v1, v2);</span><br></pre></td></tr></table></figure><p></p>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h3>Compare Version</h3><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * view it online : https://codepen.io/zq-jhon/pen/oPXorj</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">type Vers = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 主版本，副版本，小版本号</span></span><br><span class=\"line\">    main: number;</span><br><span class=\"line\">    minor: number;</span><br><span class=\"line\">    beta: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Version</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(v1: string, v2: string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">this</span>.compareVersion(</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.flatVersion(v1),</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.flatVersion(v2)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    flatVersion(v: string): Vers &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> verArr = v.split(<span class=\"string\">'.'</span>); <span class=\"comment\">// eg: ['1','2','3a']</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> vs = &#123;</span><br><span class=\"line\">            main: + verArr[<span class=\"number\">0</span>],</span><br><span class=\"line\">            minor: + verArr[<span class=\"number\">1</span>],</span><br><span class=\"line\">            beta: verArr[<span class=\"number\">2</span>],</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">     * @param v1 compare parama1</span></span><br><span class=\"line\"><span class=\"comment\">     * @param v2 compare parama2</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * @returns  result = 1 , v1 &gt; v2; </span></span><br><span class=\"line\"><span class=\"comment\">     *           result = 0 , v1 = v2; </span></span><br><span class=\"line\"><span class=\"comment\">     *           result = -1 , v1 &lt; v2;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    compareVersion(v1: Vers, <span class=\"attr\">v2</span>: Vers): number &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v1.main === v2.main &amp;&amp; v1.minor === v2.minor &amp;&amp; v1.beta === v2.beta) &#123; <span class=\"keyword\">return</span> <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断首位</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = v1.main &gt; v2.main ? <span class=\"number\">1</span> :  <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v1.main === v2.main) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...如果首位相等，判断第二位</span></span><br><span class=\"line\">           result =  v1.minor &gt; v2.minor ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(v1.minor === v2.minor) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// ... ... 如果第二位相等，判断第三位</span></span><br><span class=\"line\">               result = v1.beta &gt; v2.beta ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>; </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例出一个 Version 对象，填入两个比较的参数，进行比较，控制台看结果。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> v1 = <span class=\"string\">'1.2.4b'</span>, v2 = <span class=\"string\">'1.2.3a'</span>;</span><br><span class=\"line\"><span class=\"keyword\">new</span> Version(v1, v2);</span><br></pre></td></tr></table></figure><p></p>\n"}],"Post":[{"title":"zhangqiang","_content":"","source":"_drafts/zhangqiang.md","raw":"---\ntitle: zhangqiang\ntags:\n---\n","slug":"zhangqiang","published":0,"date":"2018-08-29T06:10:48.325Z","updated":"2018-08-29T03:54:44.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdef0001jgv4byrev73e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录","date":"2018-01-24T16:00:00.000Z","reward":true,"comment":true,"_content":"\n\n\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79158495)\n\n\n\n## 前言 ##\n   2018年1月18日，突然接到一个来自深圳的电话，对方说从拉勾网上看到我投递腾讯SNG部门的IMWEB团队前端，简单询问了一下我的具体情况，包括前端的就职年限，过去的工作经历。其中有一点比较有意思的是，对方问我为什么2016年7月毕业直到2017年2月入职中国XX网，这之间的简历是空缺的？我回答他说因为刚毕业没有太好的就业选择和机会，错过了很多校招，所以在毕业的时候去一个艺术培训学校当了半年的吉他老师，因为觉得和前端的职业经历没有关系，因此没有把这段经历写在简历上。对方说，我觉得你应该把这段经历也写在简历上，我说好的谢谢。\n      接着问了他招聘的是什么职位，对方说是前端工程师，我说主要负责什么工作？他说主要负责腾讯课堂的一些前端工作，我跟对方说，我目前还在老家，可能无法及时的去深圳那边面试，问了他可不可以远程面试，遂对方跟我说，可以采用电话面试，并且约定了电话一面的时间，2018年1月23日。\n## 面试的过程及结果 ##\n从接到电话直到第一次面试的这段时间，我在网上大量的检索了关于腾讯电面的经验，并且深入的针对一些常用的考点，进行梳理和总结，例如：闭包、原型、作用域链、Ajax、http协议、盒模型、兼容问题、xss/csrf攻击、浏览器渲染（重绘重排）等。\n在1月23日的当天，5点多回家，还一直在看复习资料，饭也顾不上吃。\n7点，从深圳打来了一个熟悉的电话。整个电话持续了40分钟之久，基本上问的都是基本的原理，而后可能我的回答让面试官也比较满意，之后是1个半小时的远程监控编程环节，三道程序设计题，给一个半小时的时间，腾讯面试官远程QQ协助监控你的桌面，只允许用浏览器的console以及本地编辑器，不允许查询资料，在编程过程中，面试官还会试图针对一些有问题的地方给予提示。最后，我还是很遗憾的没有通过，因为三道编程题目，我磕磕巴巴基本上没做出来，所以挂了，把文件打包发送给面试官后。我问面试官，像我这样经历不丰富，简历不突出的，为什么会考虑我呢？面试官说，我们什么阶段的人选都会考虑，你入行前端一年，基础还是不错的，就是编码能力需要提高。。。\n面试完以后，大概有几个小时，一直沉浸在刚才的面试里，晚饭也忘了吃了，一直在反思自己哪些地方答的不够好，这几天的复习哪些地方有疏漏。\n我的互联网公司处女面就以失败告终了。但是回头想想，这次失败的经历是一面镜子，让我清楚的认识到自己几斤几两，督促我在今后的学习中一步一个脚印，脚踏实地，再去仰望星空。\n\n## 电话里问到的题目 ##\n接下来，根据我当天的通话录音，来对所问到的题目进行穷举：\n\n\n  **1.接你现在的工作主要是偏前端还是偏后端？我看你大学的课程主要是偏后端一点？**\n  \n A:大学课程修完以后，出来没找到工作，干了半年吉他老师，对自己就业比较迷茫。回        到老家以后，干前端、运维都有，但是主要是前端。\n \n **2.接触前端多久了？接触/学习的渠道是什么？**\n \n A：满打满算一年。刚开始是同事辅导，慢慢入手以后，在W3CSCHOOL、网易云课堂、腾讯课堂、慕课网学习。\n \n **3.Ajax发送请求的步骤？**\n \n   3.1 xhr.open()\n   \n   3.2 xhr.send()\n   \n   3.3 callback()\n   \n **4.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？**\n \n **5.事件代理，事件委托是什么意思？**\n \n **6.闭包是怎么回事？用在什么场景？**\n \n   6.1   变量常驻内存会带来什么问题？\n   \n   6.2   如何避免这种问题？\n   \n   6.3   怎么销毁？\n   \n**7.CALL和Apply是干嘛的？**\n\n**8.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？**\n\n   8.1.如何进行CORS跨域？需要什么条件？\n   \n   8.2 对服务器来说，返回json数据和JSONP数据有什么不一样？\n   \n   8.3 还有其他跨域方式吗？\n   \n**9.简单说一说盒模型，W3C和IE怪异盒模型。**\n\n**10.简要阐述XSS和CSRF攻击及防范**\n\n  10.1 XSS脚本劫持，如何截获？(ps.这里居然把CSRF的概念当做XSS的来回答....)\n  \n  10.2 CSRF域名劫持\n  \n**11.强类型语言有继承，在JS里面如何做到继承呢？(_proto_和prototype)**\n\n   11.1 例如构造函数有一个test()方法，prototype上也有一个test()，这两个方法有区别吗？\n   \n**12.页面性能优化有哪些方式？**\n\n   12.1 文件、脚本合并是如何优化的呢？\n   \n   12.2 重绘，重排是怎么回事？有什么区别？\n   \n   12.3 请举例说明重绘，什么情况下会重绘？\n   \n   12.4 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？\n   \n   **13.浏览器如何知道一个文件资源是否需要缓存？**\n   \n   \n   **14.HTTP状态码304,502,503**\n  \n   14.1 *1,2,3,4,5* 开头的状态码都表示什么？\n    \n  **15.Node、Vim、angular简述**\n  \n  15.1 Node上如何处理异常情况？（Ps.我回答的是开发调试。。。找js文件）\n 15.2 已经上线的项目，出问题，怎么样去处理异常？\n     \n   **16.构建工具除了Webpack，还接触过其他的吗？**\n   \n 16.1 Webpack的优点和应用场景？\n\n## 编程大题 ##\n\n 1、页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。\n\n\n2、实现超出整数存储范围的两个大正整数相加 function add(a, b) 。\n注意：参数 a 和 b 以及函数的返回值都是字符串。\n\n\n3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。\n          \n这个环节基本上就知道自己GG了。。。\n\n第一题考基本功，DOM、事件、定位、jsAPI\n\n第二题考算法，基本逻辑\n\n第三题考原理，基础\n\n不得不说面试官的技术确实比较全面，腾讯的远程面试也是好狠，直接远程监控写代码的。。。鼠标和界面都不敢静止，静止可能就会被认为作弊（不知道他们是不是这样来判断的，反正我没有停下来过）。\n\n以下是做完所有题目后跟面试官的沟通记录。天真的我以为会被眷顾招入鹅厂，然鹅我想多了。。\n\n![图1](http://img.blog.csdn.net/20180125112701622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![图2](http://img.blog.csdn.net/20180125112711300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![图3](http://img.blog.csdn.net/20180125112723206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![图4](http://img.blog.csdn.net/20180125112738983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n \n \n \n\n\n\n\n\n\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==123456){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录.md","raw":"---\ntitle:  2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录\ndate: 2018-01-25 00:00:00\ntags: 腾讯SNG-IMWeb面试\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n\n\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79158495)\n\n\n\n## 前言 ##\n   2018年1月18日，突然接到一个来自深圳的电话，对方说从拉勾网上看到我投递腾讯SNG部门的IMWEB团队前端，简单询问了一下我的具体情况，包括前端的就职年限，过去的工作经历。其中有一点比较有意思的是，对方问我为什么2016年7月毕业直到2017年2月入职中国XX网，这之间的简历是空缺的？我回答他说因为刚毕业没有太好的就业选择和机会，错过了很多校招，所以在毕业的时候去一个艺术培训学校当了半年的吉他老师，因为觉得和前端的职业经历没有关系，因此没有把这段经历写在简历上。对方说，我觉得你应该把这段经历也写在简历上，我说好的谢谢。\n      接着问了他招聘的是什么职位，对方说是前端工程师，我说主要负责什么工作？他说主要负责腾讯课堂的一些前端工作，我跟对方说，我目前还在老家，可能无法及时的去深圳那边面试，问了他可不可以远程面试，遂对方跟我说，可以采用电话面试，并且约定了电话一面的时间，2018年1月23日。\n## 面试的过程及结果 ##\n从接到电话直到第一次面试的这段时间，我在网上大量的检索了关于腾讯电面的经验，并且深入的针对一些常用的考点，进行梳理和总结，例如：闭包、原型、作用域链、Ajax、http协议、盒模型、兼容问题、xss/csrf攻击、浏览器渲染（重绘重排）等。\n在1月23日的当天，5点多回家，还一直在看复习资料，饭也顾不上吃。\n7点，从深圳打来了一个熟悉的电话。整个电话持续了40分钟之久，基本上问的都是基本的原理，而后可能我的回答让面试官也比较满意，之后是1个半小时的远程监控编程环节，三道程序设计题，给一个半小时的时间，腾讯面试官远程QQ协助监控你的桌面，只允许用浏览器的console以及本地编辑器，不允许查询资料，在编程过程中，面试官还会试图针对一些有问题的地方给予提示。最后，我还是很遗憾的没有通过，因为三道编程题目，我磕磕巴巴基本上没做出来，所以挂了，把文件打包发送给面试官后。我问面试官，像我这样经历不丰富，简历不突出的，为什么会考虑我呢？面试官说，我们什么阶段的人选都会考虑，你入行前端一年，基础还是不错的，就是编码能力需要提高。。。\n面试完以后，大概有几个小时，一直沉浸在刚才的面试里，晚饭也忘了吃了，一直在反思自己哪些地方答的不够好，这几天的复习哪些地方有疏漏。\n我的互联网公司处女面就以失败告终了。但是回头想想，这次失败的经历是一面镜子，让我清楚的认识到自己几斤几两，督促我在今后的学习中一步一个脚印，脚踏实地，再去仰望星空。\n\n## 电话里问到的题目 ##\n接下来，根据我当天的通话录音，来对所问到的题目进行穷举：\n\n\n  **1.接你现在的工作主要是偏前端还是偏后端？我看你大学的课程主要是偏后端一点？**\n  \n A:大学课程修完以后，出来没找到工作，干了半年吉他老师，对自己就业比较迷茫。回        到老家以后，干前端、运维都有，但是主要是前端。\n \n **2.接触前端多久了？接触/学习的渠道是什么？**\n \n A：满打满算一年。刚开始是同事辅导，慢慢入手以后，在W3CSCHOOL、网易云课堂、腾讯课堂、慕课网学习。\n \n **3.Ajax发送请求的步骤？**\n \n   3.1 xhr.open()\n   \n   3.2 xhr.send()\n   \n   3.3 callback()\n   \n **4.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？**\n \n **5.事件代理，事件委托是什么意思？**\n \n **6.闭包是怎么回事？用在什么场景？**\n \n   6.1   变量常驻内存会带来什么问题？\n   \n   6.2   如何避免这种问题？\n   \n   6.3   怎么销毁？\n   \n**7.CALL和Apply是干嘛的？**\n\n**8.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？**\n\n   8.1.如何进行CORS跨域？需要什么条件？\n   \n   8.2 对服务器来说，返回json数据和JSONP数据有什么不一样？\n   \n   8.3 还有其他跨域方式吗？\n   \n**9.简单说一说盒模型，W3C和IE怪异盒模型。**\n\n**10.简要阐述XSS和CSRF攻击及防范**\n\n  10.1 XSS脚本劫持，如何截获？(ps.这里居然把CSRF的概念当做XSS的来回答....)\n  \n  10.2 CSRF域名劫持\n  \n**11.强类型语言有继承，在JS里面如何做到继承呢？(_proto_和prototype)**\n\n   11.1 例如构造函数有一个test()方法，prototype上也有一个test()，这两个方法有区别吗？\n   \n**12.页面性能优化有哪些方式？**\n\n   12.1 文件、脚本合并是如何优化的呢？\n   \n   12.2 重绘，重排是怎么回事？有什么区别？\n   \n   12.3 请举例说明重绘，什么情况下会重绘？\n   \n   12.4 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？\n   \n   **13.浏览器如何知道一个文件资源是否需要缓存？**\n   \n   \n   **14.HTTP状态码304,502,503**\n  \n   14.1 *1,2,3,4,5* 开头的状态码都表示什么？\n    \n  **15.Node、Vim、angular简述**\n  \n  15.1 Node上如何处理异常情况？（Ps.我回答的是开发调试。。。找js文件）\n 15.2 已经上线的项目，出问题，怎么样去处理异常？\n     \n   **16.构建工具除了Webpack，还接触过其他的吗？**\n   \n 16.1 Webpack的优点和应用场景？\n\n## 编程大题 ##\n\n 1、页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。\n\n\n2、实现超出整数存储范围的两个大正整数相加 function add(a, b) 。\n注意：参数 a 和 b 以及函数的返回值都是字符串。\n\n\n3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。\n          \n这个环节基本上就知道自己GG了。。。\n\n第一题考基本功，DOM、事件、定位、jsAPI\n\n第二题考算法，基本逻辑\n\n第三题考原理，基础\n\n不得不说面试官的技术确实比较全面，腾讯的远程面试也是好狠，直接远程监控写代码的。。。鼠标和界面都不敢静止，静止可能就会被认为作弊（不知道他们是不是这样来判断的，反正我没有停下来过）。\n\n以下是做完所有题目后跟面试官的沟通记录。天真的我以为会被眷顾招入鹅厂，然鹅我想多了。。\n\n![图1](http://img.blog.csdn.net/20180125112701622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![图2](http://img.blog.csdn.net/20180125112711300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![图3](http://img.blog.csdn.net/20180125112723206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![图4](http://img.blog.csdn.net/20180125112738983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n \n \n \n\n\n\n\n\n\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==123456){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"2018年1月23日腾讯SNG-IMWeb前端工程师 电话远程面试记录","published":1,"updated":"2018-08-29T08:54:11.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdem0003jgv4991wroaq","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79158495\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>   2018年1月18日，突然接到一个来自深圳的电话，对方说从拉勾网上看到我投递腾讯SNG部门的IMWEB团队前端，简单询问了一下我的具体情况，包括前端的就职年限，过去的工作经历。其中有一点比较有意思的是，对方问我为什么2016年7月毕业直到2017年2月入职中国XX网，这之间的简历是空缺的？我回答他说因为刚毕业没有太好的就业选择和机会，错过了很多校招，所以在毕业的时候去一个艺术培训学校当了半年的吉他老师，因为觉得和前端的职业经历没有关系，因此没有把这段经历写在简历上。对方说，我觉得你应该把这段经历也写在简历上，我说好的谢谢。<br>      接着问了他招聘的是什么职位，对方说是前端工程师，我说主要负责什么工作？他说主要负责腾讯课堂的一些前端工作，我跟对方说，我目前还在老家，可能无法及时的去深圳那边面试，问了他可不可以远程面试，遂对方跟我说，可以采用电话面试，并且约定了电话一面的时间，2018年1月23日。</p>\n<h2 id=\"面试的过程及结果\"><a href=\"#面试的过程及结果\" class=\"headerlink\" title=\"面试的过程及结果\"></a>面试的过程及结果</h2><p>从接到电话直到第一次面试的这段时间，我在网上大量的检索了关于腾讯电面的经验，并且深入的针对一些常用的考点，进行梳理和总结，例如：闭包、原型、作用域链、Ajax、http协议、盒模型、兼容问题、xss/csrf攻击、浏览器渲染（重绘重排）等。<br>在1月23日的当天，5点多回家，还一直在看复习资料，饭也顾不上吃。<br>7点，从深圳打来了一个熟悉的电话。整个电话持续了40分钟之久，基本上问的都是基本的原理，而后可能我的回答让面试官也比较满意，之后是1个半小时的远程监控编程环节，三道程序设计题，给一个半小时的时间，腾讯面试官远程QQ协助监控你的桌面，只允许用浏览器的console以及本地编辑器，不允许查询资料，在编程过程中，面试官还会试图针对一些有问题的地方给予提示。最后，我还是很遗憾的没有通过，因为三道编程题目，我磕磕巴巴基本上没做出来，所以挂了，把文件打包发送给面试官后。我问面试官，像我这样经历不丰富，简历不突出的，为什么会考虑我呢？面试官说，我们什么阶段的人选都会考虑，你入行前端一年，基础还是不错的，就是编码能力需要提高。。。<br>面试完以后，大概有几个小时，一直沉浸在刚才的面试里，晚饭也忘了吃了，一直在反思自己哪些地方答的不够好，这几天的复习哪些地方有疏漏。<br>我的互联网公司处女面就以失败告终了。但是回头想想，这次失败的经历是一面镜子，让我清楚的认识到自己几斤几两，督促我在今后的学习中一步一个脚印，脚踏实地，再去仰望星空。</p>\n<h2 id=\"电话里问到的题目\"><a href=\"#电话里问到的题目\" class=\"headerlink\" title=\"电话里问到的题目\"></a>电话里问到的题目</h2><p>接下来，根据我当天的通话录音，来对所问到的题目进行穷举：</p>\n<p>  <strong>1.接你现在的工作主要是偏前端还是偏后端？我看你大学的课程主要是偏后端一点？</strong></p>\n<p> A:大学课程修完以后，出来没找到工作，干了半年吉他老师，对自己就业比较迷茫。回        到老家以后，干前端、运维都有，但是主要是前端。</p>\n<p> <strong>2.接触前端多久了？接触/学习的渠道是什么？</strong></p>\n<p> A：满打满算一年。刚开始是同事辅导，慢慢入手以后，在W3CSCHOOL、网易云课堂、腾讯课堂、慕课网学习。</p>\n<p> <strong>3.Ajax发送请求的步骤？</strong></p>\n<p>   3.1 xhr.open()</p>\n<p>   3.2 xhr.send()</p>\n<p>   3.3 callback()</p>\n<p> <strong>4.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</strong></p>\n<p> <strong>5.事件代理，事件委托是什么意思？</strong></p>\n<p> <strong>6.闭包是怎么回事？用在什么场景？</strong></p>\n<p>   6.1   变量常驻内存会带来什么问题？</p>\n<p>   6.2   如何避免这种问题？</p>\n<p>   6.3   怎么销毁？</p>\n<p><strong>7.CALL和Apply是干嘛的？</strong></p>\n<p><strong>8.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</strong></p>\n<p>   8.1.如何进行CORS跨域？需要什么条件？</p>\n<p>   8.2 对服务器来说，返回json数据和JSONP数据有什么不一样？</p>\n<p>   8.3 还有其他跨域方式吗？</p>\n<p><strong>9.简单说一说盒模型，W3C和IE怪异盒模型。</strong></p>\n<p><strong>10.简要阐述XSS和CSRF攻击及防范</strong></p>\n<p>  10.1 XSS脚本劫持，如何截获？(ps.这里居然把CSRF的概念当做XSS的来回答….)</p>\n<p>  10.2 CSRF域名劫持</p>\n<p><strong>11.强类型语言有继承，在JS里面如何做到继承呢？(<em>proto</em>和prototype)</strong></p>\n<p>   11.1 例如构造函数有一个test()方法，prototype上也有一个test()，这两个方法有区别吗？</p>\n<p><strong>12.页面性能优化有哪些方式？</strong></p>\n<p>   12.1 文件、脚本合并是如何优化的呢？</p>\n<p>   12.2 重绘，重排是怎么回事？有什么区别？</p>\n<p>   12.3 请举例说明重绘，什么情况下会重绘？</p>\n<p>   12.4 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？</p>\n<p>   <strong>13.浏览器如何知道一个文件资源是否需要缓存？</strong></p>\n<p>   <strong>14.HTTP状态码304,502,503</strong></p>\n<p>   14.1 <em>1,2,3,4,5</em> 开头的状态码都表示什么？</p>\n<p>  <strong>15.Node、Vim、angular简述</strong></p>\n<p>  15.1 Node上如何处理异常情况？（Ps.我回答的是开发调试。。。找js文件）<br> 15.2 已经上线的项目，出问题，怎么样去处理异常？</p>\n<p>   <strong>16.构建工具除了Webpack，还接触过其他的吗？</strong></p>\n<p> 16.1 Webpack的优点和应用场景？</p>\n<h2 id=\"编程大题\"><a href=\"#编程大题\" class=\"headerlink\" title=\"编程大题\"></a>编程大题</h2><p> 1、页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。</p>\n<p>2、实现超出整数存储范围的两个大正整数相加 function add(a, b) 。<br>注意：参数 a 和 b 以及函数的返回值都是字符串。</p>\n<p>3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。</p>\n<p>这个环节基本上就知道自己GG了。。。</p>\n<p>第一题考基本功，DOM、事件、定位、jsAPI</p>\n<p>第二题考算法，基本逻辑</p>\n<p>第三题考原理，基础</p>\n<p>不得不说面试官的技术确实比较全面，腾讯的远程面试也是好狠，直接远程监控写代码的。。。鼠标和界面都不敢静止，静止可能就会被认为作弊（不知道他们是不是这样来判断的，反正我没有停下来过）。</p>\n<p>以下是做完所有题目后跟面试官的沟通记录。天真的我以为会被眷顾招入鹅厂，然鹅我想多了。。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112701622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图1\" title=\"\" class=\"\">\n                <p>图1</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112711300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图2\" title=\"\" class=\"\">\n                <p>图2</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112723206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图3\" title=\"\" class=\"\">\n                <p>图3</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112738983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图4\" title=\"\" class=\"\">\n                <p>图4</p>\n            </figure>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==123456){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79158495\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>   2018年1月18日，突然接到一个来自深圳的电话，对方说从拉勾网上看到我投递腾讯SNG部门的IMWEB团队前端，简单询问了一下我的具体情况，包括前端的就职年限，过去的工作经历。其中有一点比较有意思的是，对方问我为什么2016年7月毕业直到2017年2月入职中国XX网，这之间的简历是空缺的？我回答他说因为刚毕业没有太好的就业选择和机会，错过了很多校招，所以在毕业的时候去一个艺术培训学校当了半年的吉他老师，因为觉得和前端的职业经历没有关系，因此没有把这段经历写在简历上。对方说，我觉得你应该把这段经历也写在简历上，我说好的谢谢。<br>      接着问了他招聘的是什么职位，对方说是前端工程师，我说主要负责什么工作？他说主要负责腾讯课堂的一些前端工作，我跟对方说，我目前还在老家，可能无法及时的去深圳那边面试，问了他可不可以远程面试，遂对方跟我说，可以采用电话面试，并且约定了电话一面的时间，2018年1月23日。</p>\n<h2 id=\"面试的过程及结果\"><a href=\"#面试的过程及结果\" class=\"headerlink\" title=\"面试的过程及结果\"></a>面试的过程及结果</h2><p>从接到电话直到第一次面试的这段时间，我在网上大量的检索了关于腾讯电面的经验，并且深入的针对一些常用的考点，进行梳理和总结，例如：闭包、原型、作用域链、Ajax、http协议、盒模型、兼容问题、xss/csrf攻击、浏览器渲染（重绘重排）等。<br>在1月23日的当天，5点多回家，还一直在看复习资料，饭也顾不上吃。<br>7点，从深圳打来了一个熟悉的电话。整个电话持续了40分钟之久，基本上问的都是基本的原理，而后可能我的回答让面试官也比较满意，之后是1个半小时的远程监控编程环节，三道程序设计题，给一个半小时的时间，腾讯面试官远程QQ协助监控你的桌面，只允许用浏览器的console以及本地编辑器，不允许查询资料，在编程过程中，面试官还会试图针对一些有问题的地方给予提示。最后，我还是很遗憾的没有通过，因为三道编程题目，我磕磕巴巴基本上没做出来，所以挂了，把文件打包发送给面试官后。我问面试官，像我这样经历不丰富，简历不突出的，为什么会考虑我呢？面试官说，我们什么阶段的人选都会考虑，你入行前端一年，基础还是不错的，就是编码能力需要提高。。。<br>面试完以后，大概有几个小时，一直沉浸在刚才的面试里，晚饭也忘了吃了，一直在反思自己哪些地方答的不够好，这几天的复习哪些地方有疏漏。<br>我的互联网公司处女面就以失败告终了。但是回头想想，这次失败的经历是一面镜子，让我清楚的认识到自己几斤几两，督促我在今后的学习中一步一个脚印，脚踏实地，再去仰望星空。</p>\n<h2 id=\"电话里问到的题目\"><a href=\"#电话里问到的题目\" class=\"headerlink\" title=\"电话里问到的题目\"></a>电话里问到的题目</h2><p>接下来，根据我当天的通话录音，来对所问到的题目进行穷举：</p>\n<p>  <strong>1.接你现在的工作主要是偏前端还是偏后端？我看你大学的课程主要是偏后端一点？</strong></p>\n<p> A:大学课程修完以后，出来没找到工作，干了半年吉他老师，对自己就业比较迷茫。回        到老家以后，干前端、运维都有，但是主要是前端。</p>\n<p> <strong>2.接触前端多久了？接触/学习的渠道是什么？</strong></p>\n<p> A：满打满算一年。刚开始是同事辅导，慢慢入手以后，在W3CSCHOOL、网易云课堂、腾讯课堂、慕课网学习。</p>\n<p> <strong>3.Ajax发送请求的步骤？</strong></p>\n<p>   3.1 xhr.open()</p>\n<p>   3.2 xhr.send()</p>\n<p>   3.3 callback()</p>\n<p> <strong>4.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</strong></p>\n<p> <strong>5.事件代理，事件委托是什么意思？</strong></p>\n<p> <strong>6.闭包是怎么回事？用在什么场景？</strong></p>\n<p>   6.1   变量常驻内存会带来什么问题？</p>\n<p>   6.2   如何避免这种问题？</p>\n<p>   6.3   怎么销毁？</p>\n<p><strong>7.CALL和Apply是干嘛的？</strong></p>\n<p><strong>8.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</strong></p>\n<p>   8.1.如何进行CORS跨域？需要什么条件？</p>\n<p>   8.2 对服务器来说，返回json数据和JSONP数据有什么不一样？</p>\n<p>   8.3 还有其他跨域方式吗？</p>\n<p><strong>9.简单说一说盒模型，W3C和IE怪异盒模型。</strong></p>\n<p><strong>10.简要阐述XSS和CSRF攻击及防范</strong></p>\n<p>  10.1 XSS脚本劫持，如何截获？(ps.这里居然把CSRF的概念当做XSS的来回答….)</p>\n<p>  10.2 CSRF域名劫持</p>\n<p><strong>11.强类型语言有继承，在JS里面如何做到继承呢？(<em>proto</em>和prototype)</strong></p>\n<p>   11.1 例如构造函数有一个test()方法，prototype上也有一个test()，这两个方法有区别吗？</p>\n<p><strong>12.页面性能优化有哪些方式？</strong></p>\n<p>   12.1 文件、脚本合并是如何优化的呢？</p>\n<p>   12.2 重绘，重排是怎么回事？有什么区别？</p>\n<p>   12.3 请举例说明重绘，什么情况下会重绘？</p>\n<p>   12.4 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？</p>\n<p>   <strong>13.浏览器如何知道一个文件资源是否需要缓存？</strong></p>\n<p>   <strong>14.HTTP状态码304,502,503</strong></p>\n<p>   14.1 <em>1,2,3,4,5</em> 开头的状态码都表示什么？</p>\n<p>  <strong>15.Node、Vim、angular简述</strong></p>\n<p>  15.1 Node上如何处理异常情况？（Ps.我回答的是开发调试。。。找js文件）<br> 15.2 已经上线的项目，出问题，怎么样去处理异常？</p>\n<p>   <strong>16.构建工具除了Webpack，还接触过其他的吗？</strong></p>\n<p> 16.1 Webpack的优点和应用场景？</p>\n<h2 id=\"编程大题\"><a href=\"#编程大题\" class=\"headerlink\" title=\"编程大题\"></a>编程大题</h2><p> 1、页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。</p>\n<p>2、实现超出整数存储范围的两个大正整数相加 function add(a, b) 。<br>注意：参数 a 和 b 以及函数的返回值都是字符串。</p>\n<p>3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。</p>\n<p>这个环节基本上就知道自己GG了。。。</p>\n<p>第一题考基本功，DOM、事件、定位、jsAPI</p>\n<p>第二题考算法，基本逻辑</p>\n<p>第三题考原理，基础</p>\n<p>不得不说面试官的技术确实比较全面，腾讯的远程面试也是好狠，直接远程监控写代码的。。。鼠标和界面都不敢静止，静止可能就会被认为作弊（不知道他们是不是这样来判断的，反正我没有停下来过）。</p>\n<p>以下是做完所有题目后跟面试官的沟通记录。天真的我以为会被眷顾招入鹅厂，然鹅我想多了。。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112701622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图1\" title=\"\" class=\"\">\n                <p>图1</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112711300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图2\" title=\"\" class=\"\">\n                <p>图2</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112723206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图3\" title=\"\" class=\"\">\n                <p>图3</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180125112738983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"图4\" title=\"\" class=\"\">\n                <p>图4</p>\n            </figure>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==123456){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Ajax初探","date":"2017-11-06T06:03:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78457021)\n\n\n## Ajax初探 ##\n\n---------- \n<h2>1.环境搭建与配置</h2>\n这两天在捣鼓Ajax,期初用的都是开发工具自己集成的apache服务器，但是因为我太蠢，找不到相关的设置项和说明，又或者是我懒得找把，于是搜了一款**数据库**和**Apache**服务器集成好的本地站点包：【XAMPP】，百度下载好，按照相关说明进行配置。\n<h2>2.基本设置与文件索引目录</h2>\n\n![这里写图片描述](http://img.blog.csdn.net/20171106140930710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，只需要将Apache与MySQL打钩，并且star，就OK。\n打开浏览器，输入站点ip与端口（默认是127.0.0.1）\n然后在安装目录下的,安装盘:\\xampp\\htdocs 看到有个.html的文件，该就是刚才在浏览器中看到的。\n可以将这个.html的文件**删除**，刷新浏览器，可以直接看到浏览器中的目录索引。\n![这里写图片描述](http://img.blog.csdn.net/20171106141608295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \n现在网页上127.0.0.1的目录就是文件库中的映射。\n以后我们可以将服务器端需要响应的asp/php/txt文件，都放在  **安装盘:\\xampp\\htdocs**下即可，环境搭建完成。\n\n<h2>3.喜闻乐见敲代码环节</h2>\n<h4>3.1 javascript原生Ajax</h4>\n\n>       所谓Ajax：\n      A:async 异步加载\n      ja: javascript  脚本语言\n      x:xml  前后台通信的数据载体，文本\n      （鉴与json的出现，XML正在被逐渐取代，大有\"Ajaj\"的趋势）\n\n  <h4> 3.2 目的</h4>\n  目的是为了提高用户体验，更新局部数据时不用刷新整个网页，就可以完成数据交互。\n  <h4>3.3 对象(API)</h4>\n 1. 在IE7+/Chrome/Opera/Safari 中，对象为XMLHttpRequest，**该对象属于window下的子对象**;\n  创建方法为\n```\nvar xhr = new XMLHttpRequest;\n```\n2.在IE7以下， 对象为ActiveXObject,**该对象属于window下的子对象**;\n 创建方法为\n \n\n```\nvar xhr = new ActiveXObject('Microsoft.XMLHTTP');\n//括号中的必须有。\n```\n <h4>3.4 浏览器兼容判断</h4>\n\n```\n var xhr =;  //var 一个空对象\n if(window.XMLHttpRequest){\n xhr = new XMLHttpRequest;\n }  //非IE7以下\n \n else if(window.ActiveXObject){\nxhr = new ActiveXObject('Microsoft.XMLHTTP');\n}//IE7以下\n\nelse{alert(\"您的浏览器过于先进，请降级到合适的版本！\")}\n```\n\n  <h4>3.5 方法</h4>\n  这个xhr对象，自带了一些方法。\n  1.open（规定请求的类型，地址，是否异步）方法\n\n```\n  xhr.open(method,url,async) \n```\n2.send(string)方法，用于发送请求\n该方法中的string，只要在method=\"post\"时，才可以使用。\n\n3.当method==true,那么要设定就绪时执行的函数，跟回调函数有点像:\n  先说两个属性：\n  (1)xhr.responseText           //······························· 返回字符串形式的相应数据\n  (2)xhr.responseXML          //································ 返回XML形式的相应数据\n```\n\nxhr.onreadystateChange=function{\nif(xhr.readystate==4&&xhr.status==200){\n     //这里写下要回调的方法\n     document.getElementById('div').innerHTML=xhr.responseText;\n     //获取返回的文本，这里也可以写xhr.responseXML\n     \n     }\n}\nxhr.open('get','123.php',true);\nxhr.send();\n```\nOK,这是默认的**异步处理**，要执行一个就绪时的函数。\n那么，在同步模式下，即async=false时，应该这么写请求：\n\nxhr.open(\"GET\",\"/try/ajax/ajax_info.txt\",false);\nxh.send();\ndocument.getElementById(\"Div\").innerHTML=xhr.responseText;\n\n\n   <h4>3.6  onreadystatechange 存储函数</h4>\n    onreadystatechange 存储着xhr的好几种状态：\n    0：初始化未就绪    (想找老板要工资，但没准备好)\n    1：已经与服务器连接 （已经走进老板办公室）\n    2：服务器已经接受（老板已经听到你的诉求）\n    3：正在处理请求（老板在苦思冥想给不给你钱）\n    4：请求已经完成，并且响应也已经下发（想了半天给你了）\n    每当 readyState 改变时，就会触发 onreadystatechange 事件。\n\n  同时，status也需要有响应的返回值，从服务器传递回来，有两个值：\n  200 响应就绪，成功下发（会计接到老板的电话，立马爽快的给了你工资）\n  404  未找到   （会计跑路了，尽管老板同意，你还是没拿到钱）\n    <h4></h4>\n     <h4></h4>\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Ajax初探.md","raw":"---\ntitle: Ajax初探 \ndate: 2017-11-06 14:03:00\ntags: ajax\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78457021)\n\n\n## Ajax初探 ##\n\n---------- \n<h2>1.环境搭建与配置</h2>\n这两天在捣鼓Ajax,期初用的都是开发工具自己集成的apache服务器，但是因为我太蠢，找不到相关的设置项和说明，又或者是我懒得找把，于是搜了一款**数据库**和**Apache**服务器集成好的本地站点包：【XAMPP】，百度下载好，按照相关说明进行配置。\n<h2>2.基本设置与文件索引目录</h2>\n\n![这里写图片描述](http://img.blog.csdn.net/20171106140930710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，只需要将Apache与MySQL打钩，并且star，就OK。\n打开浏览器，输入站点ip与端口（默认是127.0.0.1）\n然后在安装目录下的,安装盘:\\xampp\\htdocs 看到有个.html的文件，该就是刚才在浏览器中看到的。\n可以将这个.html的文件**删除**，刷新浏览器，可以直接看到浏览器中的目录索引。\n![这里写图片描述](http://img.blog.csdn.net/20171106141608295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \n现在网页上127.0.0.1的目录就是文件库中的映射。\n以后我们可以将服务器端需要响应的asp/php/txt文件，都放在  **安装盘:\\xampp\\htdocs**下即可，环境搭建完成。\n\n<h2>3.喜闻乐见敲代码环节</h2>\n<h4>3.1 javascript原生Ajax</h4>\n\n>       所谓Ajax：\n      A:async 异步加载\n      ja: javascript  脚本语言\n      x:xml  前后台通信的数据载体，文本\n      （鉴与json的出现，XML正在被逐渐取代，大有\"Ajaj\"的趋势）\n\n  <h4> 3.2 目的</h4>\n  目的是为了提高用户体验，更新局部数据时不用刷新整个网页，就可以完成数据交互。\n  <h4>3.3 对象(API)</h4>\n 1. 在IE7+/Chrome/Opera/Safari 中，对象为XMLHttpRequest，**该对象属于window下的子对象**;\n  创建方法为\n```\nvar xhr = new XMLHttpRequest;\n```\n2.在IE7以下， 对象为ActiveXObject,**该对象属于window下的子对象**;\n 创建方法为\n \n\n```\nvar xhr = new ActiveXObject('Microsoft.XMLHTTP');\n//括号中的必须有。\n```\n <h4>3.4 浏览器兼容判断</h4>\n\n```\n var xhr =;  //var 一个空对象\n if(window.XMLHttpRequest){\n xhr = new XMLHttpRequest;\n }  //非IE7以下\n \n else if(window.ActiveXObject){\nxhr = new ActiveXObject('Microsoft.XMLHTTP');\n}//IE7以下\n\nelse{alert(\"您的浏览器过于先进，请降级到合适的版本！\")}\n```\n\n  <h4>3.5 方法</h4>\n  这个xhr对象，自带了一些方法。\n  1.open（规定请求的类型，地址，是否异步）方法\n\n```\n  xhr.open(method,url,async) \n```\n2.send(string)方法，用于发送请求\n该方法中的string，只要在method=\"post\"时，才可以使用。\n\n3.当method==true,那么要设定就绪时执行的函数，跟回调函数有点像:\n  先说两个属性：\n  (1)xhr.responseText           //······························· 返回字符串形式的相应数据\n  (2)xhr.responseXML          //································ 返回XML形式的相应数据\n```\n\nxhr.onreadystateChange=function{\nif(xhr.readystate==4&&xhr.status==200){\n     //这里写下要回调的方法\n     document.getElementById('div').innerHTML=xhr.responseText;\n     //获取返回的文本，这里也可以写xhr.responseXML\n     \n     }\n}\nxhr.open('get','123.php',true);\nxhr.send();\n```\nOK,这是默认的**异步处理**，要执行一个就绪时的函数。\n那么，在同步模式下，即async=false时，应该这么写请求：\n\nxhr.open(\"GET\",\"/try/ajax/ajax_info.txt\",false);\nxh.send();\ndocument.getElementById(\"Div\").innerHTML=xhr.responseText;\n\n\n   <h4>3.6  onreadystatechange 存储函数</h4>\n    onreadystatechange 存储着xhr的好几种状态：\n    0：初始化未就绪    (想找老板要工资，但没准备好)\n    1：已经与服务器连接 （已经走进老板办公室）\n    2：服务器已经接受（老板已经听到你的诉求）\n    3：正在处理请求（老板在苦思冥想给不给你钱）\n    4：请求已经完成，并且响应也已经下发（想了半天给你了）\n    每当 readyState 改变时，就会触发 onreadystatechange 事件。\n\n  同时，status也需要有响应的返回值，从服务器传递回来，有两个值：\n  200 响应就绪，成功下发（会计接到老板的电话，立马爽快的给了你工资）\n  404  未找到   （会计跑路了，尽管老板同意，你还是没拿到钱）\n    <h4></h4>\n     <h4></h4>\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Ajax初探","published":1,"updated":"2018-08-29T05:59:59.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxder0005jgv4qp2dypkf","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78457021\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"Ajax初探\"><a href=\"#Ajax初探\" class=\"headerlink\" title=\"Ajax初探\"></a>Ajax初探</h2><hr>\n<h2>1.环境搭建与配置</h2><br>这两天在捣鼓Ajax,期初用的都是开发工具自己集成的apache服务器，但是因为我太蠢，找不到相关的设置项和说明，又或者是我懒得找把，于是搜了一款<strong>数据库</strong>和<strong>Apache</strong>服务器集成好的本地站点包：【XAMPP】，百度下载好，按照相关说明进行配置。<br><h2>2.基本设置与文件索引目录</h2>\n\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171106140930710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>如图所示，只需要将Apache与MySQL打钩，并且star，就OK。<br>打开浏览器，输入站点ip与端口（默认是127.0.0.1）<br>然后在安装目录下的,安装盘:\\xampp\\htdocs 看到有个.html的文件，该就是刚才在浏览器中看到的。<br>可以将这个.html的文件<strong>删除</strong>，刷新浏览器，可以直接看到浏览器中的目录索引。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171106141608295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>现在网页上127.0.0.1的目录就是文件库中的映射。<br>以后我们可以将服务器端需要响应的asp/php/txt文件，都放在  <strong>安装盘:\\xampp\\htdocs</strong>下即可，环境搭建完成。</p>\n<p></p><h2>3.喜闻乐见敲代码环节</h2><p></p>\n<h4>3.1 javascript原生Ajax</h4>\n\n<blockquote>\n<pre><code>所谓Ajax：\nA:async 异步加载\nja: javascript  脚本语言\nx:xml  前后台通信的数据载体，文本\n（鉴与json的出现，XML正在被逐渐取代，大有&quot;Ajaj&quot;的趋势）\n</code></pre></blockquote>\n  <h4> 3.2 目的</h4><br>  目的是为了提高用户体验，更新局部数据时不用刷新整个网页，就可以完成数据交互。<br>  <h4>3.3 对象(API)</h4><br> 1. 在IE7+/Chrome/Opera/Safari 中，对象为XMLHttpRequest，<strong>该对象属于window下的子对象</strong>;<br>  创建方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest;</span><br></pre></td></tr></table></figure><br><br>2.在IE7以下， 对象为ActiveXObject,<strong>该对象属于window下的子对象</strong>;<br> 创建方法为<br><br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">//括号中的必须有。</span><br></pre></td></tr></table></figure><br><br> <h4>3.4 浏览器兼容判断</h4>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var xhr =;  //var 一个空对象</span><br><span class=\"line\"> if(window.XMLHttpRequest)&#123;</span><br><span class=\"line\"> xhr = new XMLHttpRequest;</span><br><span class=\"line\"> &#125;  //非IE7以下</span><br><span class=\"line\"> </span><br><span class=\"line\"> else if(window.ActiveXObject)&#123;</span><br><span class=\"line\">xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">&#125;//IE7以下</span><br><span class=\"line\"></span><br><span class=\"line\">else&#123;alert(&quot;您的浏览器过于先进，请降级到合适的版本！&quot;)&#125;</span><br></pre></td></tr></table></figure>\n  <h4>3.5 方法</h4><br>  这个xhr对象，自带了一些方法。<br>  1.open（规定请求的类型，地址，是否异步）方法<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(method,url,async)</span><br></pre></td></tr></table></figure><br><br>2.send(string)方法，用于发送请求<br>该方法中的string，只要在method=”post”时，才可以使用。<br><br>3.当method==true,那么要设定就绪时执行的函数，跟回调函数有点像:<br>  先说两个属性：<br>  (1)xhr.responseText           //······························· 返回字符串形式的相应数据<br>  (2)xhr.responseXML          //································ 返回XML形式的相应数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">xhr.onreadystateChange=function&#123;</span><br><span class=\"line\">if(xhr.readystate==4&amp;&amp;xhr.status==200)&#123;</span><br><span class=\"line\">     //这里写下要回调的方法</span><br><span class=\"line\">     document.getElementById(&apos;div&apos;).innerHTML=xhr.responseText;</span><br><span class=\"line\">     //获取返回的文本，这里也可以写xhr.responseXML</span><br><span class=\"line\">     </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.open(&apos;get&apos;,&apos;123.php&apos;,true);</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure><br><br>OK,这是默认的<strong>异步处理</strong>，要执行一个就绪时的函数。<br>那么，在同步模式下，即async=false时，应该这么写请求：<br><br>xhr.open(“GET”,”/try/ajax/ajax_info.txt”,false);<br>xh.send();<br>document.getElementById(“Div”).innerHTML=xhr.responseText;<br><br><br>   <h4>3.6  onreadystatechange 存储函数</h4><br>    onreadystatechange 存储着xhr的好几种状态：<br>    0：初始化未就绪    (想找老板要工资，但没准备好)<br>    1：已经与服务器连接 （已经走进老板办公室）<br>    2：服务器已经接受（老板已经听到你的诉求）<br>    3：正在处理请求（老板在苦思冥想给不给你钱）<br>    4：请求已经完成，并且响应也已经下发（想了半天给你了）<br>    每当 readyState 改变时，就会触发 onreadystatechange 事件。<br><br>  同时，status也需要有响应的返回值，从服务器传递回来，有两个值：<br>  200 响应就绪，成功下发（会计接到老板的电话，立马爽快的给了你工资）<br>  404  未找到   （会计跑路了，尽管老板同意，你还是没拿到钱）<br>    <h4></h4><br>     <h4></h4>\n\n\n\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78457021\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"Ajax初探\"><a href=\"#Ajax初探\" class=\"headerlink\" title=\"Ajax初探\"></a>Ajax初探</h2><hr>\n<h2>1.环境搭建与配置</h2><br>这两天在捣鼓Ajax,期初用的都是开发工具自己集成的apache服务器，但是因为我太蠢，找不到相关的设置项和说明，又或者是我懒得找把，于是搜了一款<strong>数据库</strong>和<strong>Apache</strong>服务器集成好的本地站点包：【XAMPP】，百度下载好，按照相关说明进行配置。<br><h2>2.基本设置与文件索引目录</h2>\n\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171106140930710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>如图所示，只需要将Apache与MySQL打钩，并且star，就OK。<br>打开浏览器，输入站点ip与端口（默认是127.0.0.1）<br>然后在安装目录下的,安装盘:\\xampp\\htdocs 看到有个.html的文件，该就是刚才在浏览器中看到的。<br>可以将这个.html的文件<strong>删除</strong>，刷新浏览器，可以直接看到浏览器中的目录索引。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171106141608295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>现在网页上127.0.0.1的目录就是文件库中的映射。<br>以后我们可以将服务器端需要响应的asp/php/txt文件，都放在  <strong>安装盘:\\xampp\\htdocs</strong>下即可，环境搭建完成。</p>\n<p></p><h2>3.喜闻乐见敲代码环节</h2><p></p>\n<h4>3.1 javascript原生Ajax</h4>\n\n<blockquote>\n<pre><code>所谓Ajax：\nA:async 异步加载\nja: javascript  脚本语言\nx:xml  前后台通信的数据载体，文本\n（鉴与json的出现，XML正在被逐渐取代，大有&quot;Ajaj&quot;的趋势）\n</code></pre></blockquote>\n  <h4> 3.2 目的</h4><br>  目的是为了提高用户体验，更新局部数据时不用刷新整个网页，就可以完成数据交互。<br>  <h4>3.3 对象(API)</h4><br> 1. 在IE7+/Chrome/Opera/Safari 中，对象为XMLHttpRequest，<strong>该对象属于window下的子对象</strong>;<br>  创建方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest;</span><br></pre></td></tr></table></figure><br><br>2.在IE7以下， 对象为ActiveXObject,<strong>该对象属于window下的子对象</strong>;<br> 创建方法为<br><br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">//括号中的必须有。</span><br></pre></td></tr></table></figure><br><br> <h4>3.4 浏览器兼容判断</h4>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var xhr =;  //var 一个空对象</span><br><span class=\"line\"> if(window.XMLHttpRequest)&#123;</span><br><span class=\"line\"> xhr = new XMLHttpRequest;</span><br><span class=\"line\"> &#125;  //非IE7以下</span><br><span class=\"line\"> </span><br><span class=\"line\"> else if(window.ActiveXObject)&#123;</span><br><span class=\"line\">xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">&#125;//IE7以下</span><br><span class=\"line\"></span><br><span class=\"line\">else&#123;alert(&quot;您的浏览器过于先进，请降级到合适的版本！&quot;)&#125;</span><br></pre></td></tr></table></figure>\n  <h4>3.5 方法</h4><br>  这个xhr对象，自带了一些方法。<br>  1.open（规定请求的类型，地址，是否异步）方法<br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(method,url,async)</span><br></pre></td></tr></table></figure><br><br>2.send(string)方法，用于发送请求<br>该方法中的string，只要在method=”post”时，才可以使用。<br><br>3.当method==true,那么要设定就绪时执行的函数，跟回调函数有点像:<br>  先说两个属性：<br>  (1)xhr.responseText           //······························· 返回字符串形式的相应数据<br>  (2)xhr.responseXML          //································ 返回XML形式的相应数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">xhr.onreadystateChange=function&#123;</span><br><span class=\"line\">if(xhr.readystate==4&amp;&amp;xhr.status==200)&#123;</span><br><span class=\"line\">     //这里写下要回调的方法</span><br><span class=\"line\">     document.getElementById(&apos;div&apos;).innerHTML=xhr.responseText;</span><br><span class=\"line\">     //获取返回的文本，这里也可以写xhr.responseXML</span><br><span class=\"line\">     </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.open(&apos;get&apos;,&apos;123.php&apos;,true);</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure><br><br>OK,这是默认的<strong>异步处理</strong>，要执行一个就绪时的函数。<br>那么，在同步模式下，即async=false时，应该这么写请求：<br><br>xhr.open(“GET”,”/try/ajax/ajax_info.txt”,false);<br>xh.send();<br>document.getElementById(“Div”).innerHTML=xhr.responseText;<br><br><br>   <h4>3.6  onreadystatechange 存储函数</h4><br>    onreadystatechange 存储着xhr的好几种状态：<br>    0：初始化未就绪    (想找老板要工资，但没准备好)<br>    1：已经与服务器连接 （已经走进老板办公室）<br>    2：服务器已经接受（老板已经听到你的诉求）<br>    3：正在处理请求（老板在苦思冥想给不给你钱）<br>    4：请求已经完成，并且响应也已经下发（想了半天给你了）<br>    每当 readyState 改变时，就会触发 onreadystatechange 事件。<br><br>  同时，status也需要有响应的返回值，从服务器传递回来，有两个值：<br>  200 响应就绪，成功下发（会计接到老板的电话，立马爽快的给了你工资）<br>  404  未找到   （会计跑路了，尽管老板同意，你还是没拿到钱）<br>    <h4></h4><br>     <h4></h4>\n\n\n\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Angular1.4.6 & Bootstrap3.3.7搭建后台人员管理系统 1.0.0","date":"2017-12-19T07:35:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78842927)\n\n\n**前言：接触前端快1满一年了，从什么都不会，一步步摸索，走到现在，觉得前方的路还是很迷茫，但是每天感觉自己都在进步，这是最好的！希望自己能坚持下去，也跟各位同仁共勉！**\n\n```\n@important message!\n{\n    \"name\":\"Manage-system-By-AngularJs\",\n    \"version\":\"1.0.0\",\n    \"author\":\"ZQ-jhon\",\n    \"connect\":\"QQ:350037310\"\n}\n```\n\n直接上全部效果的演示图：\nLet's view together:\n\n![GIF加载中，请耐心等待... ...](http://img.blog.csdn.net/20171220094856558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n## 1.Angualr和Bootstrap的火花 ##\n\nAngular是开发SPA的得力框架，其数据双向绑定和指令系统能够最大程度的保持页面的\n\n整洁干净，而Bootstrap作为一个UI库，也能够很好的满足本系统的需求。\n\n## 2.思路 ##\n\n2.1 在后台人员管理系统中，需要有以下功能：增、删、改、查。\n\n为了实现这些功能，就必须在项目中留好数据接口，方便跟后台数据进行I/O操作。\n\n2.2 为了实现部分功能的 toggle()，例如：\n\n 1. 点击编辑，文本框的可编辑状态会来回在:  可编辑/不可编辑  切换。\n\n 2. 点击编辑，删除button的 show 与 hidden。\n\n必须使用一个ng-show = bool/ng-disabled = !bool，bool的具体方法每次访问，会\n\n更改布尔值为对立值：\n\n```\n//初始化:\n$scope.bool = true;\n\n//调用改变自身布尔值\n$scope.toggle = function(){        \n\n\n$scope.bool = !$scope.bool;  //谁调谁改变\n \n}\n```\n\n\n而这个`$scope`的bool()方法，应该位于`$rootscope`是最好的解决方式，所有的局部\n\ncontroller都可以访问到根作用域。\n\n因此，改写如下：\n\n```\n$rootscope.toggle = function(){        \n\n\n$rootscope.bool = !$scope.bool;  //谁调谁改变\n \n}\n```\n\n\n## 3.实现 ##\n\n3.1 框架搭建 ：使用bootstrap搭建框架\n\n3.2 初始数据展示：为了让用户有一个直观的展示，当前界面上会mock一些假的数据上\n\n去，仅供参考(当然这些数据也可以删除)，mock的方法为，在`$scope`上绑定一个数\n\n组，该数组是对象数组，然后用过ng-repeat来展现在我们的bootstrap表格中。\n\n3.3 框架代码：\n\n```\n<body>\n\t\t\t\t\t\t\t\n\n        <div class=\"container-fluid\">\n            <h1 class=\"text-center\">增删改查后台管理系统</h1>\n       <table class=\"table table-responsive table-hover\">\n           <thead>\n               <tr>\n                   <td>序号</td>\n                   <td>姓名</td>\n                   <td>年龄</td>\n                   <td>职务</td>\n                   \n               </tr>\n               <tr>\n                   <td><span class=\"glyphicon glyphicon-pencil btn btn-info\">编辑</span></td>\n               \n                   <td></td>\n                   <td><input type=\"text\" value=\"\" ng-disabled=\"bool\"/></td>\n                   <td><input type=\"text\" value=\"\" ng-disabled=\"bool\"/></td>\n                   <td><input type=\"text\" value=\"\" ng-disabled=\"bool\"/></td>\n                   <td><button class=\"btn btn-danger\">删除</button></td>\n                   \n               </tr>\n           </thead>\n       </table>\n       \n       <button class=\"btn btn-success\"><i class=\"glyphicon glyphicon-user\"></i>创建新用户</button> \t\n        </div> \n        </body>\n```\n3.4 ng指令系统的控制原理与规划过程 \n\n  3.4.1     指令构建\n  \n    首先在表格上声明 `ng-app =\"myapp\"`\n         \n    并且声明控制器`ng-controller=\"ctrl\"`\n     \n    接着，在需要toggle切换的地方赋值，如果默认要false,可以使用 \n         \n      ng-show=\"!bool\"或者 ng-disabled=\"bool\"\n         \n    这里因为初始值是：\n\n       `$scope.bool = true`\n\n  然后，在$`scope`上绑定初始数据，即一个对象组：\n     \n\n```\n        var app=angular.module('myApp',[]);\n \tapp.controller('ctrl',function($scope){\n \t\t$scope.users = [\n \t\t{name:'LiMing',age:23,job:'fontAnggener'},\n \t\t{name:'Hanmeimei',age:22,job:'teacher'},\n \t\t{name:'Wangjie',age:25,job:'driver'},\n \t\t{name:'Liusir',age:27,job:'business'},\n \t\t{name:'guojingming',age:29,job:'editor'},\n \t\t{name:'Yaoming',age:33,job:'player'}\n \t\t\n \t\t];\n```\n\n  有了元数据，就可以为所欲为了，在需要的位置，例如 table 中的 tr 进行ng - repeat\n\n循环，循环的结果是\n\n对象数组中每一个对象！\n==\n然后在对应的`<td></td>`中使用{{use.name}}或者balalala进行取值\n\n\n\n \n   为了完成自动化序号排列以及删除功能，需要$index服务，不需要依赖注入。\n   \n    当每个删除按钮点击的一瞬间，Angular如何判断该删除哪个呢？\n\n \n    我们为每一个删除按钮button添加一个指令 `ng-click = 'remove($index)'`\n    \n这里，Angular就是通过`$index`来自行判定当前的行序。来看这一块的代码：\n\n```\n<tr ng-repeat=\"user in users\">\n    <td>\n        <span class=\"glyphicon glyphicon-pencil btn btn-info\" ng-click=\"toggle()\">编辑</span>\n    </td>\n\n    <td>{{$index+1}}</td>\n    <td>\n        <input type=\"text\" value=\"{{user.name}}\" ng-disabled=\"bool\" />\n    </td>\n    <td>\n        <input type=\"text\" value=\"{{user.age}}\" ng-disabled=\"bool\" />\n    </td>\n    <td>\n        <input type=\"text\" value=\"{{user.job}}\" ng-disabled=\"bool\" />\n    </td>\n    <td>\n        <button class=\"btn btn-danger\" ng-click=\"remove($index)\" ng-show=\"!bool\">删除</button>\n    </td>\n\n</tr>\n```\nOK，删除，排序，Toggle功能都完成了，还有一个增加新用户怎么完成呢？\n\n这个更简单了，直接往Object Array 里 push 对象即可：\n\n```\n/****这是增加用户按钮的指令*****/\nng-click = \"addUser()\"\n\n/*****以下是js*****/\n\n $scope.addUser = function(){\n       var index = $scope.users.length-1;  //确定当前最大的行序（ps.本来想自己实现 $index 功能的。。。）\n  \n       \t$scope.users.push({name:'',age:'',job:''});\n       \n       }\n```\n\n以上，就完成了一个后台管理系统，这是初始版本，后续我会增加新的功能在里面。\n\n\n\n## 4.初步完成alpha版本，觉得还是有很多不足之处： ##\n\n1.数据很糙，很杂，controller中的东西太过冗杂，而我并没有选择使用构建工具来模块\n\n化、打包、合并，这不是一个好习惯。\n\n2.所有的输入框没有加入过滤器，例如：姓名的位置我们可以用filter或者正则来强行限\n\n定只能输英文，而不是数字或者标点。 这是一个细节不够完善的地方。\n\n3.在点下编辑的时候，文本框变得可以编辑，再次点下编辑，文本框变成了丑丑的不可\n\n编辑，我在想：**\n\n如何可以使得文字在不可编辑的状态下自动切换为`<p>`标签，而在可编辑的状态下变成`<input>`表单？\n------------------------------------------------\n\n**\n4.自学了这么久ajax,nodejs，然而并没有从后端拉任何数据，所有数据都是angular来\n\n进行操作的，这样也不好，我希望尽快精通express，来进行项目的全栈构建。\n\n以上问题留给自己去解决。\n\n\n最后，附上我的Github地址，fork 或者 download都可以\n\n地址：https://github.com/ZQ-jhon/Manage-system-By-AngularJs\n\n注意：将 index.html中的\n\n```\n<script>以及<link>的src 及 href 替换 成本地目录 \n```\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Angular1-4-6-Bootstrap3-3-7搭建后台人员管理系统-1-0-0.md","raw":"---\ntitle: Angular1.4.6 & Bootstrap3.3.7搭建后台人员管理系统 1.0.0 \ndate: 2017-12-19 15:35:00\ntags: angularjs\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78842927)\n\n\n**前言：接触前端快1满一年了，从什么都不会，一步步摸索，走到现在，觉得前方的路还是很迷茫，但是每天感觉自己都在进步，这是最好的！希望自己能坚持下去，也跟各位同仁共勉！**\n\n```\n@important message!\n{\n    \"name\":\"Manage-system-By-AngularJs\",\n    \"version\":\"1.0.0\",\n    \"author\":\"ZQ-jhon\",\n    \"connect\":\"QQ:350037310\"\n}\n```\n\n直接上全部效果的演示图：\nLet's view together:\n\n![GIF加载中，请耐心等待... ...](http://img.blog.csdn.net/20171220094856558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n## 1.Angualr和Bootstrap的火花 ##\n\nAngular是开发SPA的得力框架，其数据双向绑定和指令系统能够最大程度的保持页面的\n\n整洁干净，而Bootstrap作为一个UI库，也能够很好的满足本系统的需求。\n\n## 2.思路 ##\n\n2.1 在后台人员管理系统中，需要有以下功能：增、删、改、查。\n\n为了实现这些功能，就必须在项目中留好数据接口，方便跟后台数据进行I/O操作。\n\n2.2 为了实现部分功能的 toggle()，例如：\n\n 1. 点击编辑，文本框的可编辑状态会来回在:  可编辑/不可编辑  切换。\n\n 2. 点击编辑，删除button的 show 与 hidden。\n\n必须使用一个ng-show = bool/ng-disabled = !bool，bool的具体方法每次访问，会\n\n更改布尔值为对立值：\n\n```\n//初始化:\n$scope.bool = true;\n\n//调用改变自身布尔值\n$scope.toggle = function(){        \n\n\n$scope.bool = !$scope.bool;  //谁调谁改变\n \n}\n```\n\n\n而这个`$scope`的bool()方法，应该位于`$rootscope`是最好的解决方式，所有的局部\n\ncontroller都可以访问到根作用域。\n\n因此，改写如下：\n\n```\n$rootscope.toggle = function(){        \n\n\n$rootscope.bool = !$scope.bool;  //谁调谁改变\n \n}\n```\n\n\n## 3.实现 ##\n\n3.1 框架搭建 ：使用bootstrap搭建框架\n\n3.2 初始数据展示：为了让用户有一个直观的展示，当前界面上会mock一些假的数据上\n\n去，仅供参考(当然这些数据也可以删除)，mock的方法为，在`$scope`上绑定一个数\n\n组，该数组是对象数组，然后用过ng-repeat来展现在我们的bootstrap表格中。\n\n3.3 框架代码：\n\n```\n<body>\n\t\t\t\t\t\t\t\n\n        <div class=\"container-fluid\">\n            <h1 class=\"text-center\">增删改查后台管理系统</h1>\n       <table class=\"table table-responsive table-hover\">\n           <thead>\n               <tr>\n                   <td>序号</td>\n                   <td>姓名</td>\n                   <td>年龄</td>\n                   <td>职务</td>\n                   \n               </tr>\n               <tr>\n                   <td><span class=\"glyphicon glyphicon-pencil btn btn-info\">编辑</span></td>\n               \n                   <td></td>\n                   <td><input type=\"text\" value=\"\" ng-disabled=\"bool\"/></td>\n                   <td><input type=\"text\" value=\"\" ng-disabled=\"bool\"/></td>\n                   <td><input type=\"text\" value=\"\" ng-disabled=\"bool\"/></td>\n                   <td><button class=\"btn btn-danger\">删除</button></td>\n                   \n               </tr>\n           </thead>\n       </table>\n       \n       <button class=\"btn btn-success\"><i class=\"glyphicon glyphicon-user\"></i>创建新用户</button> \t\n        </div> \n        </body>\n```\n3.4 ng指令系统的控制原理与规划过程 \n\n  3.4.1     指令构建\n  \n    首先在表格上声明 `ng-app =\"myapp\"`\n         \n    并且声明控制器`ng-controller=\"ctrl\"`\n     \n    接着，在需要toggle切换的地方赋值，如果默认要false,可以使用 \n         \n      ng-show=\"!bool\"或者 ng-disabled=\"bool\"\n         \n    这里因为初始值是：\n\n       `$scope.bool = true`\n\n  然后，在$`scope`上绑定初始数据，即一个对象组：\n     \n\n```\n        var app=angular.module('myApp',[]);\n \tapp.controller('ctrl',function($scope){\n \t\t$scope.users = [\n \t\t{name:'LiMing',age:23,job:'fontAnggener'},\n \t\t{name:'Hanmeimei',age:22,job:'teacher'},\n \t\t{name:'Wangjie',age:25,job:'driver'},\n \t\t{name:'Liusir',age:27,job:'business'},\n \t\t{name:'guojingming',age:29,job:'editor'},\n \t\t{name:'Yaoming',age:33,job:'player'}\n \t\t\n \t\t];\n```\n\n  有了元数据，就可以为所欲为了，在需要的位置，例如 table 中的 tr 进行ng - repeat\n\n循环，循环的结果是\n\n对象数组中每一个对象！\n==\n然后在对应的`<td></td>`中使用{{use.name}}或者balalala进行取值\n\n\n\n \n   为了完成自动化序号排列以及删除功能，需要$index服务，不需要依赖注入。\n   \n    当每个删除按钮点击的一瞬间，Angular如何判断该删除哪个呢？\n\n \n    我们为每一个删除按钮button添加一个指令 `ng-click = 'remove($index)'`\n    \n这里，Angular就是通过`$index`来自行判定当前的行序。来看这一块的代码：\n\n```\n<tr ng-repeat=\"user in users\">\n    <td>\n        <span class=\"glyphicon glyphicon-pencil btn btn-info\" ng-click=\"toggle()\">编辑</span>\n    </td>\n\n    <td>{{$index+1}}</td>\n    <td>\n        <input type=\"text\" value=\"{{user.name}}\" ng-disabled=\"bool\" />\n    </td>\n    <td>\n        <input type=\"text\" value=\"{{user.age}}\" ng-disabled=\"bool\" />\n    </td>\n    <td>\n        <input type=\"text\" value=\"{{user.job}}\" ng-disabled=\"bool\" />\n    </td>\n    <td>\n        <button class=\"btn btn-danger\" ng-click=\"remove($index)\" ng-show=\"!bool\">删除</button>\n    </td>\n\n</tr>\n```\nOK，删除，排序，Toggle功能都完成了，还有一个增加新用户怎么完成呢？\n\n这个更简单了，直接往Object Array 里 push 对象即可：\n\n```\n/****这是增加用户按钮的指令*****/\nng-click = \"addUser()\"\n\n/*****以下是js*****/\n\n $scope.addUser = function(){\n       var index = $scope.users.length-1;  //确定当前最大的行序（ps.本来想自己实现 $index 功能的。。。）\n  \n       \t$scope.users.push({name:'',age:'',job:''});\n       \n       }\n```\n\n以上，就完成了一个后台管理系统，这是初始版本，后续我会增加新的功能在里面。\n\n\n\n## 4.初步完成alpha版本，觉得还是有很多不足之处： ##\n\n1.数据很糙，很杂，controller中的东西太过冗杂，而我并没有选择使用构建工具来模块\n\n化、打包、合并，这不是一个好习惯。\n\n2.所有的输入框没有加入过滤器，例如：姓名的位置我们可以用filter或者正则来强行限\n\n定只能输英文，而不是数字或者标点。 这是一个细节不够完善的地方。\n\n3.在点下编辑的时候，文本框变得可以编辑，再次点下编辑，文本框变成了丑丑的不可\n\n编辑，我在想：**\n\n如何可以使得文字在不可编辑的状态下自动切换为`<p>`标签，而在可编辑的状态下变成`<input>`表单？\n------------------------------------------------\n\n**\n4.自学了这么久ajax,nodejs，然而并没有从后端拉任何数据，所有数据都是angular来\n\n进行操作的，这样也不好，我希望尽快精通express，来进行项目的全栈构建。\n\n以上问题留给自己去解决。\n\n\n最后，附上我的Github地址，fork 或者 download都可以\n\n地址：https://github.com/ZQ-jhon/Manage-system-By-AngularJs\n\n注意：将 index.html中的\n\n```\n<script>以及<link>的src 及 href 替换 成本地目录 \n```\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Angular1-4-6-Bootstrap3-3-7搭建后台人员管理系统-1-0-0","published":1,"updated":"2018-08-29T05:59:20.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdex0008jgv4vf3t617h","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p><strong>前言：接触前端快1满一年了，从什么都不会，一步步摸索，走到现在，觉得前方的路还是很迷茫，但是每天感觉自己都在进步，这是最好的！希望自己能坚持下去，也跟各位同仁共勉！</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@important message!</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;Manage-system-By-AngularJs&quot;,</span><br><span class=\"line\">    &quot;version&quot;:&quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;author&quot;:&quot;ZQ-jhon&quot;,</span><br><span class=\"line\">    &quot;connect&quot;:&quot;QQ:350037310&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接上全部效果的演示图：<br>Let’s view together:</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171220094856558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"GIF加载中，请耐心等待... ...\" title=\"\" class=\"\">\n                <p>GIF加载中，请耐心等待... ...</p>\n            </figure>\n<h2 id=\"1-Angualr和Bootstrap的火花\"><a href=\"#1-Angualr和Bootstrap的火花\" class=\"headerlink\" title=\"1.Angualr和Bootstrap的火花\"></a>1.Angualr和Bootstrap的火花</h2><p>Angular是开发SPA的得力框架，其数据双向绑定和指令系统能够最大程度的保持页面的</p>\n<p>整洁干净，而Bootstrap作为一个UI库，也能够很好的满足本系统的需求。</p>\n<h2 id=\"2-思路\"><a href=\"#2-思路\" class=\"headerlink\" title=\"2.思路\"></a>2.思路</h2><p>2.1 在后台人员管理系统中，需要有以下功能：增、删、改、查。</p>\n<p>为了实现这些功能，就必须在项目中留好数据接口，方便跟后台数据进行I/O操作。</p>\n<p>2.2 为了实现部分功能的 toggle()，例如：</p>\n<ol>\n<li><p>点击编辑，文本框的可编辑状态会来回在:  可编辑/不可编辑  切换。</p>\n</li>\n<li><p>点击编辑，删除button的 show 与 hidden。</p>\n</li>\n</ol>\n<p>必须使用一个ng-show = bool/ng-disabled = !bool，bool的具体方法每次访问，会</p>\n<p>更改布尔值为对立值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//初始化:</span><br><span class=\"line\">$scope.bool = true;</span><br><span class=\"line\"></span><br><span class=\"line\">//调用改变自身布尔值</span><br><span class=\"line\">$scope.toggle = function()&#123;        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$scope.bool = !$scope.bool;  //谁调谁改变</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而这个<code>$scope</code>的bool()方法，应该位于<code>$rootscope</code>是最好的解决方式，所有的局部</p>\n<p>controller都可以访问到根作用域。</p>\n<p>因此，改写如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$rootscope.toggle = function()&#123;        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$rootscope.bool = !$scope.bool;  //谁调谁改变</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3.实现\"></a>3.实现</h2><p>3.1 框架搭建 ：使用bootstrap搭建框架</p>\n<p>3.2 初始数据展示：为了让用户有一个直观的展示，当前界面上会mock一些假的数据上</p>\n<p>去，仅供参考(当然这些数据也可以删除)，mock的方法为，在<code>$scope</code>上绑定一个数</p>\n<p>组，该数组是对象数组，然后用过ng-repeat来展现在我们的bootstrap表格中。</p>\n<p>3.3 框架代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class=\"line\">            &lt;h1 class=&quot;text-center&quot;&gt;增删改查后台管理系统&lt;/h1&gt;</span><br><span class=\"line\">       &lt;table class=&quot;table table-responsive table-hover&quot;&gt;</span><br><span class=\"line\">           &lt;thead&gt;</span><br><span class=\"line\">               &lt;tr&gt;</span><br><span class=\"line\">                   &lt;td&gt;序号&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;姓名&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;年龄&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;职务&lt;/td&gt;</span><br><span class=\"line\">                   </span><br><span class=\"line\">               &lt;/tr&gt;</span><br><span class=\"line\">               &lt;tr&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot;&gt;编辑&lt;/span&gt;&lt;/td&gt;</span><br><span class=\"line\">               </span><br><span class=\"line\">                   &lt;td&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;</span><br><span class=\"line\">                   </span><br><span class=\"line\">               &lt;/tr&gt;</span><br><span class=\"line\">           &lt;/thead&gt;</span><br><span class=\"line\">       &lt;/table&gt;</span><br><span class=\"line\">       </span><br><span class=\"line\">       &lt;button class=&quot;btn btn-success&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/i&gt;创建新用户&lt;/button&gt; \t</span><br><span class=\"line\">        &lt;/div&gt; </span><br><span class=\"line\">        &lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>3.4 ng指令系统的控制原理与规划过程 </p>\n<p>  3.4.1     指令构建</p>\n<pre><code>首先在表格上声明 `ng-app =&quot;myapp&quot;`\n\n并且声明控制器`ng-controller=&quot;ctrl&quot;`\n\n接着，在需要toggle切换的地方赋值，如果默认要false,可以使用 \n\n  ng-show=&quot;!bool&quot;或者 ng-disabled=&quot;bool&quot;\n\n这里因为初始值是：\n\n   `$scope.bool = true`\n</code></pre><p>  然后，在$<code>scope</code>上绑定初始数据，即一个对象组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      var app=angular.module(&apos;myApp&apos;,[]);</span><br><span class=\"line\">app.controller(&apos;ctrl&apos;,function($scope)&#123;</span><br><span class=\"line\">\t$scope.users = [</span><br><span class=\"line\">\t&#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t];</span><br></pre></td></tr></table></figure>\n<p>  有了元数据，就可以为所欲为了，在需要的位置，例如 table 中的 tr 进行ng - repeat</p>\n<p>循环，循环的结果是</p>\n<h1 id=\"对象数组中每一个对象！\"><a href=\"#对象数组中每一个对象！\" class=\"headerlink\" title=\"对象数组中每一个对象！\"></a>对象数组中每一个对象！</h1><p>然后在对应的<code>&lt;td&gt;&lt;/td&gt;</code>中使用或者balalala进行取值</p>\n<p>   为了完成自动化序号排列以及删除功能，需要$index服务，不需要依赖注入。</p>\n<pre><code>当每个删除按钮点击的一瞬间，Angular如何判断该删除哪个呢？\n\n\n我们为每一个删除按钮button添加一个指令 `ng-click = &apos;remove($index)&apos;`\n</code></pre><p>这里，Angular就是通过<code>$index</code>来自行判定当前的行序。来看这一块的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tr ng-repeat=&quot;user in users&quot;&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot; ng-click=&quot;toggle()&quot;&gt;编辑&lt;/span&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.name&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.age&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.job&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;button class=&quot;btn btn-danger&quot; ng-click=&quot;remove($index)&quot; ng-show=&quot;!bool&quot;&gt;删除&lt;/button&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>\n<p>OK，删除，排序，Toggle功能都完成了，还有一个增加新用户怎么完成呢？</p>\n<p>这个更简单了，直接往Object Array 里 push 对象即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/****这是增加用户按钮的指令*****/</span><br><span class=\"line\">ng-click = &quot;addUser()&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">/*****以下是js*****/</span><br><span class=\"line\"></span><br><span class=\"line\"> $scope.addUser = function()&#123;</span><br><span class=\"line\">       var index = $scope.users.length-1;  //确定当前最大的行序（ps.本来想自己实现 $index 功能的。。。）</span><br><span class=\"line\">  </span><br><span class=\"line\">       \t$scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>以上，就完成了一个后台管理系统，这是初始版本，后续我会增加新的功能在里面。</p>\n<h2 id=\"4-初步完成alpha版本，觉得还是有很多不足之处：\"><a href=\"#4-初步完成alpha版本，觉得还是有很多不足之处：\" class=\"headerlink\" title=\"4.初步完成alpha版本，觉得还是有很多不足之处：\"></a>4.初步完成alpha版本，觉得还是有很多不足之处：</h2><p>1.数据很糙，很杂，controller中的东西太过冗杂，而我并没有选择使用构建工具来模块</p>\n<p>化、打包、合并，这不是一个好习惯。</p>\n<p>2.所有的输入框没有加入过滤器，例如：姓名的位置我们可以用filter或者正则来强行限</p>\n<p>定只能输英文，而不是数字或者标点。 这是一个细节不够完善的地方。</p>\n<p>3.在点下编辑的时候，文本框变得可以编辑，再次点下编辑，文本框变成了丑丑的不可</p>\n<p>编辑，我在想：**</p>\n<h2 id=\"如何可以使得文字在不可编辑的状态下自动切换为-lt-p-gt-标签，而在可编辑的状态下变成-lt-input-gt-表单？\"><a href=\"#如何可以使得文字在不可编辑的状态下自动切换为-lt-p-gt-标签，而在可编辑的状态下变成-lt-input-gt-表单？\" class=\"headerlink\" title=\"如何可以使得文字在不可编辑的状态下自动切换为&lt;p&gt;标签，而在可编辑的状态下变成&lt;input&gt;表单？\"></a>如何可以使得文字在不可编辑的状态下自动切换为<code>&lt;p&gt;</code>标签，而在可编辑的状态下变成<code>&lt;input&gt;</code>表单？</h2><p>**<br>4.自学了这么久ajax,nodejs，然而并没有从后端拉任何数据，所有数据都是angular来</p>\n<p>进行操作的，这样也不好，我希望尽快精通express，来进行项目的全栈构建。</p>\n<p>以上问题留给自己去解决。</p>\n<p>最后，附上我的Github地址，fork 或者 download都可以</p>\n<p>地址：<a href=\"https://github.com/ZQ-jhon/Manage-system-By-AngularJs\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/Manage-system-By-AngularJs</a></p>\n<p>注意：将 index.html中的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;以及&lt;link&gt;的src 及 href 替换 成本地目录</span><br></pre></td></tr></table></figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78842927\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p><strong>前言：接触前端快1满一年了，从什么都不会，一步步摸索，走到现在，觉得前方的路还是很迷茫，但是每天感觉自己都在进步，这是最好的！希望自己能坚持下去，也跟各位同仁共勉！</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@important message!</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;Manage-system-By-AngularJs&quot;,</span><br><span class=\"line\">    &quot;version&quot;:&quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;author&quot;:&quot;ZQ-jhon&quot;,</span><br><span class=\"line\">    &quot;connect&quot;:&quot;QQ:350037310&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接上全部效果的演示图：<br>Let’s view together:</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171220094856558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"GIF加载中，请耐心等待... ...\" title=\"\" class=\"\">\n                <p>GIF加载中，请耐心等待... ...</p>\n            </figure>\n<h2 id=\"1-Angualr和Bootstrap的火花\"><a href=\"#1-Angualr和Bootstrap的火花\" class=\"headerlink\" title=\"1.Angualr和Bootstrap的火花\"></a>1.Angualr和Bootstrap的火花</h2><p>Angular是开发SPA的得力框架，其数据双向绑定和指令系统能够最大程度的保持页面的</p>\n<p>整洁干净，而Bootstrap作为一个UI库，也能够很好的满足本系统的需求。</p>\n<h2 id=\"2-思路\"><a href=\"#2-思路\" class=\"headerlink\" title=\"2.思路\"></a>2.思路</h2><p>2.1 在后台人员管理系统中，需要有以下功能：增、删、改、查。</p>\n<p>为了实现这些功能，就必须在项目中留好数据接口，方便跟后台数据进行I/O操作。</p>\n<p>2.2 为了实现部分功能的 toggle()，例如：</p>\n<ol>\n<li><p>点击编辑，文本框的可编辑状态会来回在:  可编辑/不可编辑  切换。</p>\n</li>\n<li><p>点击编辑，删除button的 show 与 hidden。</p>\n</li>\n</ol>\n<p>必须使用一个ng-show = bool/ng-disabled = !bool，bool的具体方法每次访问，会</p>\n<p>更改布尔值为对立值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//初始化:</span><br><span class=\"line\">$scope.bool = true;</span><br><span class=\"line\"></span><br><span class=\"line\">//调用改变自身布尔值</span><br><span class=\"line\">$scope.toggle = function()&#123;        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$scope.bool = !$scope.bool;  //谁调谁改变</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而这个<code>$scope</code>的bool()方法，应该位于<code>$rootscope</code>是最好的解决方式，所有的局部</p>\n<p>controller都可以访问到根作用域。</p>\n<p>因此，改写如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$rootscope.toggle = function()&#123;        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$rootscope.bool = !$scope.bool;  //谁调谁改变</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3.实现\"></a>3.实现</h2><p>3.1 框架搭建 ：使用bootstrap搭建框架</p>\n<p>3.2 初始数据展示：为了让用户有一个直观的展示，当前界面上会mock一些假的数据上</p>\n<p>去，仅供参考(当然这些数据也可以删除)，mock的方法为，在<code>$scope</code>上绑定一个数</p>\n<p>组，该数组是对象数组，然后用过ng-repeat来展现在我们的bootstrap表格中。</p>\n<p>3.3 框架代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;div class=&quot;container-fluid&quot;&gt;</span><br><span class=\"line\">            &lt;h1 class=&quot;text-center&quot;&gt;增删改查后台管理系统&lt;/h1&gt;</span><br><span class=\"line\">       &lt;table class=&quot;table table-responsive table-hover&quot;&gt;</span><br><span class=\"line\">           &lt;thead&gt;</span><br><span class=\"line\">               &lt;tr&gt;</span><br><span class=\"line\">                   &lt;td&gt;序号&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;姓名&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;年龄&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;职务&lt;/td&gt;</span><br><span class=\"line\">                   </span><br><span class=\"line\">               &lt;/tr&gt;</span><br><span class=\"line\">               &lt;tr&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot;&gt;编辑&lt;/span&gt;&lt;/td&gt;</span><br><span class=\"line\">               </span><br><span class=\"line\">                   &lt;td&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; ng-disabled=&quot;bool&quot;/&gt;&lt;/td&gt;</span><br><span class=\"line\">                   &lt;td&gt;&lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt;&lt;/td&gt;</span><br><span class=\"line\">                   </span><br><span class=\"line\">               &lt;/tr&gt;</span><br><span class=\"line\">           &lt;/thead&gt;</span><br><span class=\"line\">       &lt;/table&gt;</span><br><span class=\"line\">       </span><br><span class=\"line\">       &lt;button class=&quot;btn btn-success&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/i&gt;创建新用户&lt;/button&gt; \t</span><br><span class=\"line\">        &lt;/div&gt; </span><br><span class=\"line\">        &lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>3.4 ng指令系统的控制原理与规划过程 </p>\n<p>  3.4.1     指令构建</p>\n<pre><code>首先在表格上声明 `ng-app =&quot;myapp&quot;`\n\n并且声明控制器`ng-controller=&quot;ctrl&quot;`\n\n接着，在需要toggle切换的地方赋值，如果默认要false,可以使用 \n\n  ng-show=&quot;!bool&quot;或者 ng-disabled=&quot;bool&quot;\n\n这里因为初始值是：\n\n   `$scope.bool = true`\n</code></pre><p>  然后，在$<code>scope</code>上绑定初始数据，即一个对象组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      var app=angular.module(&apos;myApp&apos;,[]);</span><br><span class=\"line\">app.controller(&apos;ctrl&apos;,function($scope)&#123;</span><br><span class=\"line\">\t$scope.users = [</span><br><span class=\"line\">\t&#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;,</span><br><span class=\"line\">\t&#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t];</span><br></pre></td></tr></table></figure>\n<p>  有了元数据，就可以为所欲为了，在需要的位置，例如 table 中的 tr 进行ng - repeat</p>\n<p>循环，循环的结果是</p>\n<h1 id=\"对象数组中每一个对象！\"><a href=\"#对象数组中每一个对象！\" class=\"headerlink\" title=\"对象数组中每一个对象！\"></a>对象数组中每一个对象！</h1><p>然后在对应的<code>&lt;td&gt;&lt;/td&gt;</code>中使用或者balalala进行取值</p>\n<p>   为了完成自动化序号排列以及删除功能，需要$index服务，不需要依赖注入。</p>\n<pre><code>当每个删除按钮点击的一瞬间，Angular如何判断该删除哪个呢？\n\n\n我们为每一个删除按钮button添加一个指令 `ng-click = &apos;remove($index)&apos;`\n</code></pre><p>这里，Angular就是通过<code>$index</code>来自行判定当前的行序。来看这一块的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tr ng-repeat=&quot;user in users&quot;&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;span class=&quot;glyphicon glyphicon-pencil btn btn-info&quot; ng-click=&quot;toggle()&quot;&gt;编辑&lt;/span&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.name&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.age&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;user.job&#125;&#125;&quot; ng-disabled=&quot;bool&quot; /&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;</span><br><span class=\"line\">        &lt;button class=&quot;btn btn-danger&quot; ng-click=&quot;remove($index)&quot; ng-show=&quot;!bool&quot;&gt;删除&lt;/button&gt;</span><br><span class=\"line\">    &lt;/td&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>\n<p>OK，删除，排序，Toggle功能都完成了，还有一个增加新用户怎么完成呢？</p>\n<p>这个更简单了，直接往Object Array 里 push 对象即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/****这是增加用户按钮的指令*****/</span><br><span class=\"line\">ng-click = &quot;addUser()&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">/*****以下是js*****/</span><br><span class=\"line\"></span><br><span class=\"line\"> $scope.addUser = function()&#123;</span><br><span class=\"line\">       var index = $scope.users.length-1;  //确定当前最大的行序（ps.本来想自己实现 $index 功能的。。。）</span><br><span class=\"line\">  </span><br><span class=\"line\">       \t$scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>以上，就完成了一个后台管理系统，这是初始版本，后续我会增加新的功能在里面。</p>\n<h2 id=\"4-初步完成alpha版本，觉得还是有很多不足之处：\"><a href=\"#4-初步完成alpha版本，觉得还是有很多不足之处：\" class=\"headerlink\" title=\"4.初步完成alpha版本，觉得还是有很多不足之处：\"></a>4.初步完成alpha版本，觉得还是有很多不足之处：</h2><p>1.数据很糙，很杂，controller中的东西太过冗杂，而我并没有选择使用构建工具来模块</p>\n<p>化、打包、合并，这不是一个好习惯。</p>\n<p>2.所有的输入框没有加入过滤器，例如：姓名的位置我们可以用filter或者正则来强行限</p>\n<p>定只能输英文，而不是数字或者标点。 这是一个细节不够完善的地方。</p>\n<p>3.在点下编辑的时候，文本框变得可以编辑，再次点下编辑，文本框变成了丑丑的不可</p>\n<p>编辑，我在想：**</p>\n<h2 id=\"如何可以使得文字在不可编辑的状态下自动切换为-lt-p-gt-标签，而在可编辑的状态下变成-lt-input-gt-表单？\"><a href=\"#如何可以使得文字在不可编辑的状态下自动切换为-lt-p-gt-标签，而在可编辑的状态下变成-lt-input-gt-表单？\" class=\"headerlink\" title=\"如何可以使得文字在不可编辑的状态下自动切换为&lt;p&gt;标签，而在可编辑的状态下变成&lt;input&gt;表单？\"></a>如何可以使得文字在不可编辑的状态下自动切换为<code>&lt;p&gt;</code>标签，而在可编辑的状态下变成<code>&lt;input&gt;</code>表单？</h2><p>**<br>4.自学了这么久ajax,nodejs，然而并没有从后端拉任何数据，所有数据都是angular来</p>\n<p>进行操作的，这样也不好，我希望尽快精通express，来进行项目的全栈构建。</p>\n<p>以上问题留给自己去解决。</p>\n<p>最后，附上我的Github地址，fork 或者 download都可以</p>\n<p>地址：<a href=\"https://github.com/ZQ-jhon/Manage-system-By-AngularJs\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/Manage-system-By-AngularJs</a></p>\n<p>注意：将 index.html中的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;以及&lt;link&gt;的src 及 href 替换 成本地目录</span><br></pre></td></tr></table></figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"AngularJS学习笔记3","date":"2017-12-05T10:44:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78719707)\n**eg13.依赖注入**\n=========\n故事要从js说起，在js的function(){}中，参数可以传递为另外一个函数。举个例子：\n\n```\nfunction first(){\n\treturn 3\n}\n//参数函数1\nfunction second(){\n\treturn 5 \n}\n//参数函数2\n\nfunction add(a,b){\n\tvar a_  = a();\n\tvar b_= b();\n\talert(a_+b_)\n}\n//总函数\n\nadd(first,second);//调用总函数，其参数为first和second的返回值，弹出 8\n\n\n```\n不光如此，在回调函数中，大致也是这样的思路：\n```\nfunction callback(result){\n\tconsole.log(\"您的计算结果为:\"+result)\n}\nfunction fn(num,callback){\n\tnum = num*num\n\tcallback(num);\n}\nfn(10,callback);//控制台：您的计算结果为100\n```\n*简短回忆后，发现javaScript函数的特点，函数定义时的参数个数是定死的，但是如果传入的参数不达标/超出/太少，那么函数体就会报错。\n例如上面的add(first,second)只传入add(first)就会报错：b is not a function*\n**普通函数的参数往往是由调用它的人时候来决定的**\n回到angular中，依赖注入与javaScript函数正好相反，函数体一旦定义了参数，调用它的人就得老老实实的传入指定数量/类型的参数。\nfor eg1:\n\n```\n\t<script type=\"text/javascript\">\n\t\tvar app = angular.module('app',[]);\n\t\tapp.controller('c',function(){\n\t\t\talert(arguments.length);//这里打印出0，因为没参数，这个OK，接着往下看\n\t\t});\n\t</script>\n\n\n\n```\n```\n\n\t<script type=\"text/javascript\">\n\t\tvar app = angular.module('app',[]);\n\t\tapp.controller('c',function(s,b){\n\t\t\talert(arguments.length);\n\t\t});\n\t</script>\n这里我们发现，虽然传入了s,b两个参数，但是压根连弹窗都没有，只能说明，传入的参数不合法，函数不认。\n\n\n```\n```\n\tfor eg3:\n\t<script type=\"text/javascript\">\n\t\tvar app = angular.module('app',[]);\n\t\tapp.controller('c',function(){\n\t\t\talert(arguments.length);\n\t\t});\n\t</script>\n```\n\n```\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/AngularJS学习笔记3.md","raw":"---\ntitle: AngularJS学习笔记3\ndate: 2017-12-05 18:44:00\ntags: angularjs\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78719707)\n**eg13.依赖注入**\n=========\n故事要从js说起，在js的function(){}中，参数可以传递为另外一个函数。举个例子：\n\n```\nfunction first(){\n\treturn 3\n}\n//参数函数1\nfunction second(){\n\treturn 5 \n}\n//参数函数2\n\nfunction add(a,b){\n\tvar a_  = a();\n\tvar b_= b();\n\talert(a_+b_)\n}\n//总函数\n\nadd(first,second);//调用总函数，其参数为first和second的返回值，弹出 8\n\n\n```\n不光如此，在回调函数中，大致也是这样的思路：\n```\nfunction callback(result){\n\tconsole.log(\"您的计算结果为:\"+result)\n}\nfunction fn(num,callback){\n\tnum = num*num\n\tcallback(num);\n}\nfn(10,callback);//控制台：您的计算结果为100\n```\n*简短回忆后，发现javaScript函数的特点，函数定义时的参数个数是定死的，但是如果传入的参数不达标/超出/太少，那么函数体就会报错。\n例如上面的add(first,second)只传入add(first)就会报错：b is not a function*\n**普通函数的参数往往是由调用它的人时候来决定的**\n回到angular中，依赖注入与javaScript函数正好相反，函数体一旦定义了参数，调用它的人就得老老实实的传入指定数量/类型的参数。\nfor eg1:\n\n```\n\t<script type=\"text/javascript\">\n\t\tvar app = angular.module('app',[]);\n\t\tapp.controller('c',function(){\n\t\t\talert(arguments.length);//这里打印出0，因为没参数，这个OK，接着往下看\n\t\t});\n\t</script>\n\n\n\n```\n```\n\n\t<script type=\"text/javascript\">\n\t\tvar app = angular.module('app',[]);\n\t\tapp.controller('c',function(s,b){\n\t\t\talert(arguments.length);\n\t\t});\n\t</script>\n这里我们发现，虽然传入了s,b两个参数，但是压根连弹窗都没有，只能说明，传入的参数不合法，函数不认。\n\n\n```\n```\n\tfor eg3:\n\t<script type=\"text/javascript\">\n\t\tvar app = angular.module('app',[]);\n\t\tapp.controller('c',function(){\n\t\t\talert(arguments.length);\n\t\t});\n\t</script>\n```\n\n```\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"AngularJS学习笔记3","published":1,"updated":"2018-08-29T06:00:07.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdf2000ajgv4ov6cd24s","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78719707\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h1 id=\"eg13-依赖注入\"><a href=\"#eg13-依赖注入\" class=\"headerlink\" title=\"eg13.依赖注入\"></a><strong>eg13.依赖注入</strong></h1><p>故事要从js说起，在js的function(){}中，参数可以传递为另外一个函数。举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function first()&#123;</span><br><span class=\"line\">\treturn 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//参数函数1</span><br><span class=\"line\">function second()&#123;</span><br><span class=\"line\">\treturn 5 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//参数函数2</span><br><span class=\"line\"></span><br><span class=\"line\">function add(a,b)&#123;</span><br><span class=\"line\">\tvar a_  = a();</span><br><span class=\"line\">\tvar b_= b();</span><br><span class=\"line\">\talert(a_+b_)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//总函数</span><br><span class=\"line\"></span><br><span class=\"line\">add(first,second);//调用总函数，其参数为first和second的返回值，弹出 8</span><br></pre></td></tr></table></figure>\n<p>不光如此，在回调函数中，大致也是这样的思路：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function callback(result)&#123;</span><br><span class=\"line\">\tconsole.log(&quot;您的计算结果为:&quot;+result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function fn(num,callback)&#123;</span><br><span class=\"line\">\tnum = num*num</span><br><span class=\"line\">\tcallback(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(10,callback);//控制台：您的计算结果为100</span><br></pre></td></tr></table></figure></p>\n<p><em>简短回忆后，发现javaScript函数的特点，函数定义时的参数个数是定死的，但是如果传入的参数不达标/超出/太少，那么函数体就会报错。<br>例如上面的add(first,second)只传入add(first)就会报错：b is not a function</em><br><strong>普通函数的参数往往是由调用它的人时候来决定的</strong><br>回到angular中，依赖注入与javaScript函数正好相反，函数体一旦定义了参数，调用它的人就得老老实实的传入指定数量/类型的参数。<br>for eg1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\tvar app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">\tapp.controller(&apos;c&apos;,function()&#123;</span><br><span class=\"line\">\t\talert(arguments.length);//这里打印出0，因为没参数，这个OK，接着往下看</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\t\tvar app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">\t\tapp.controller(&apos;c&apos;,function(s,b)&#123;</span><br><span class=\"line\">\t\t\talert(arguments.length);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&lt;/script&gt;</span><br><span class=\"line\">这里我们发现，虽然传入了s,b两个参数，但是压根连弹窗都没有，只能说明，传入的参数不合法，函数不认。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for eg3:</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\tvar app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">\tapp.controller(&apos;c&apos;,function()&#123;</span><br><span class=\"line\">\t\talert(arguments.length);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><code>`</code></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78719707\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h1 id=\"eg13-依赖注入\"><a href=\"#eg13-依赖注入\" class=\"headerlink\" title=\"eg13.依赖注入\"></a><strong>eg13.依赖注入</strong></h1><p>故事要从js说起，在js的function(){}中，参数可以传递为另外一个函数。举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function first()&#123;</span><br><span class=\"line\">\treturn 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//参数函数1</span><br><span class=\"line\">function second()&#123;</span><br><span class=\"line\">\treturn 5 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//参数函数2</span><br><span class=\"line\"></span><br><span class=\"line\">function add(a,b)&#123;</span><br><span class=\"line\">\tvar a_  = a();</span><br><span class=\"line\">\tvar b_= b();</span><br><span class=\"line\">\talert(a_+b_)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//总函数</span><br><span class=\"line\"></span><br><span class=\"line\">add(first,second);//调用总函数，其参数为first和second的返回值，弹出 8</span><br></pre></td></tr></table></figure>\n<p>不光如此，在回调函数中，大致也是这样的思路：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function callback(result)&#123;</span><br><span class=\"line\">\tconsole.log(&quot;您的计算结果为:&quot;+result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function fn(num,callback)&#123;</span><br><span class=\"line\">\tnum = num*num</span><br><span class=\"line\">\tcallback(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(10,callback);//控制台：您的计算结果为100</span><br></pre></td></tr></table></figure></p>\n<p><em>简短回忆后，发现javaScript函数的特点，函数定义时的参数个数是定死的，但是如果传入的参数不达标/超出/太少，那么函数体就会报错。<br>例如上面的add(first,second)只传入add(first)就会报错：b is not a function</em><br><strong>普通函数的参数往往是由调用它的人时候来决定的</strong><br>回到angular中，依赖注入与javaScript函数正好相反，函数体一旦定义了参数，调用它的人就得老老实实的传入指定数量/类型的参数。<br>for eg1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\tvar app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">\tapp.controller(&apos;c&apos;,function()&#123;</span><br><span class=\"line\">\t\talert(arguments.length);//这里打印出0，因为没参数，这个OK，接着往下看</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\t\tvar app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">\t\tapp.controller(&apos;c&apos;,function(s,b)&#123;</span><br><span class=\"line\">\t\t\talert(arguments.length);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&lt;/script&gt;</span><br><span class=\"line\">这里我们发现，虽然传入了s,b两个参数，但是压根连弹窗都没有，只能说明，传入的参数不合法，函数不认。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for eg3:</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\tvar app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">\tapp.controller(&apos;c&apos;,function()&#123;</span><br><span class=\"line\">\t\talert(arguments.length);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><code>`</code></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Angular搭建后台人员管理系统 1.1.0","date":"2018-01-17T03:18:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78863387)\n\n\n今天基于原来的DEMO，将功能进行了调整。\n![这里写图片描述](http://img.blog.csdn.net/20171221142259866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，增加了一个新的controller，完成了增删改查的最后一步：查。\n\nstep1中还是使用ng-repeat遍历出的options，然后这个select又绑定了一个model，可以在controller用于判定用户的选项，然后根据这个选项，在users的数组中进行查找，最后，显示在查询结果的框中。\n\n今天遇到的几个问题：\n1.数据可视化和canvas视图留了一个坑。\n2.突然发现controller之间的方法、变量不可以共享，例如我在下面的控制器中创建的用户数组：\n\n```\n$scope.users=[\n{...},\n{...},\n{...},\n{...}\n]\n```\n在上面查询控制器中无法访问，网上查询之，得到结果，原因是作用域无法访问，这点跟js比较像，两个在树形结构上是兄弟层级关系的节点，不能访问对方的内部变量。但是angular 可以像js一样，变量继承，因此，可以吧users挂到 相对比较高的祖先节点上，这样，其子控制器就可以访问到了。\n3.在Step1的位置，出现了F5以后，默认出现一个空白options的现象，查看元素，得知该元素：\n\n```\n<option value=\"  undefind!\"></option>\n```\n于是采用了一个笨办法，手动添加一个\n`<option value=\"\" selected=\"\"></option>\n`\n然后，在ng-repeat的原始option选项中，也添加`selected=\"selected\"，这样就OK了！`\n4.今天对各个控制器进行合理的切分，达到模块化的效果，例如：\n\n```\n/*********根控制器的数据*********/\n \tapp.controller('rootctrl',function($scope){\n \t\t$scope.users = [\n \t\t{name:'LiMing',age:23,job:'fontAnggener'},\n \t\t{name:'Hanmeimei',age:22,job:'teacher'},\n \t\t{name:'Wangjie',age:25,job:'driver'},\n \t\t{name:'Liusir',age:27,job:'business'},\n \t\t{name:'guojingming',age:29,job:'editor'},\n \t\t{name:'Yaoming',age:33,job:'player'}\n \t\t\n \t\t];\n \t})\n/**********增加用户 控制器*************/\n $scope.addUser = function(){\n       var index = $scope.users.length-1;\n  \n       \t$scope.users.push({name:'',age:'',job:''});\n       \n       }\n /**********查询 控制器************ /\n $scope.jiansuo = function(){\n \t\t\tvar a = $scope.selectValue;\n \t\t\t$scope.result = a;\n \t\t\n \t\t\n \t\t    if(a==\"\"||null||undefined){\n \t\t    \tdocument.getElementById('sp').innerHTML=\"未选择/未输入!\";\n \t\t    \tdocument.getElementById('inputInfo').setAttribute('placeholder','请先选择分类')\n \t\t    }\n \t\t    else{\n \t\t    \tdocument.getElementById('sp').innerHTML=\"您要查询的\"+$scope.infos[a].name+\"是:\"+$scope.input;\n \t\t    \tdocument.getElementById('inputInfo').setAttribute('placeholder','请输入具体的'+$scope.infos[a].name+\"！\");\n \t\t    }\n \t\t\t\n \t\t\t\n \t\t\t\n \t\t};\n /********删除 控制器***********/\n    \n      $scope.remove = function(index){\n      \n//   if($scope.users.length<=1){\n//   \t$scope.users.splice(index,1)\n//   }\n//   else{}\n         \t$scope.users.splice(index,1)\n         \n         \n\n      \t \t\n            \n      };\n```\n在切分这些控制器的过程中，一定要注意各个控制器的作用域，以及能否访问到调用数据。\nGitHub:\nhttps://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Angular搭建后台人员管理系统-1-1-0.md","raw":"---\ntitle: Angular搭建后台人员管理系统 1.1.0 \ndate: 2018-01-17 11:18:00\ntags: angularjs\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78863387)\n\n\n今天基于原来的DEMO，将功能进行了调整。\n![这里写图片描述](http://img.blog.csdn.net/20171221142259866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，增加了一个新的controller，完成了增删改查的最后一步：查。\n\nstep1中还是使用ng-repeat遍历出的options，然后这个select又绑定了一个model，可以在controller用于判定用户的选项，然后根据这个选项，在users的数组中进行查找，最后，显示在查询结果的框中。\n\n今天遇到的几个问题：\n1.数据可视化和canvas视图留了一个坑。\n2.突然发现controller之间的方法、变量不可以共享，例如我在下面的控制器中创建的用户数组：\n\n```\n$scope.users=[\n{...},\n{...},\n{...},\n{...}\n]\n```\n在上面查询控制器中无法访问，网上查询之，得到结果，原因是作用域无法访问，这点跟js比较像，两个在树形结构上是兄弟层级关系的节点，不能访问对方的内部变量。但是angular 可以像js一样，变量继承，因此，可以吧users挂到 相对比较高的祖先节点上，这样，其子控制器就可以访问到了。\n3.在Step1的位置，出现了F5以后，默认出现一个空白options的现象，查看元素，得知该元素：\n\n```\n<option value=\"  undefind!\"></option>\n```\n于是采用了一个笨办法，手动添加一个\n`<option value=\"\" selected=\"\"></option>\n`\n然后，在ng-repeat的原始option选项中，也添加`selected=\"selected\"，这样就OK了！`\n4.今天对各个控制器进行合理的切分，达到模块化的效果，例如：\n\n```\n/*********根控制器的数据*********/\n \tapp.controller('rootctrl',function($scope){\n \t\t$scope.users = [\n \t\t{name:'LiMing',age:23,job:'fontAnggener'},\n \t\t{name:'Hanmeimei',age:22,job:'teacher'},\n \t\t{name:'Wangjie',age:25,job:'driver'},\n \t\t{name:'Liusir',age:27,job:'business'},\n \t\t{name:'guojingming',age:29,job:'editor'},\n \t\t{name:'Yaoming',age:33,job:'player'}\n \t\t\n \t\t];\n \t})\n/**********增加用户 控制器*************/\n $scope.addUser = function(){\n       var index = $scope.users.length-1;\n  \n       \t$scope.users.push({name:'',age:'',job:''});\n       \n       }\n /**********查询 控制器************ /\n $scope.jiansuo = function(){\n \t\t\tvar a = $scope.selectValue;\n \t\t\t$scope.result = a;\n \t\t\n \t\t\n \t\t    if(a==\"\"||null||undefined){\n \t\t    \tdocument.getElementById('sp').innerHTML=\"未选择/未输入!\";\n \t\t    \tdocument.getElementById('inputInfo').setAttribute('placeholder','请先选择分类')\n \t\t    }\n \t\t    else{\n \t\t    \tdocument.getElementById('sp').innerHTML=\"您要查询的\"+$scope.infos[a].name+\"是:\"+$scope.input;\n \t\t    \tdocument.getElementById('inputInfo').setAttribute('placeholder','请输入具体的'+$scope.infos[a].name+\"！\");\n \t\t    }\n \t\t\t\n \t\t\t\n \t\t\t\n \t\t};\n /********删除 控制器***********/\n    \n      $scope.remove = function(index){\n      \n//   if($scope.users.length<=1){\n//   \t$scope.users.splice(index,1)\n//   }\n//   else{}\n         \t$scope.users.splice(index,1)\n         \n         \n\n      \t \t\n            \n      };\n```\n在切分这些控制器的过程中，一定要注意各个控制器的作用域，以及能否访问到调用数据。\nGitHub:\nhttps://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Angular搭建后台人员管理系统-1-1-0","published":1,"updated":"2018-08-29T05:59:20.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdf4000bjgv4dwzw9zyi","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78863387\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>今天基于原来的DEMO，将功能进行了调整。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171221142259866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>如图所示，增加了一个新的controller，完成了增删改查的最后一步：查。</p>\n<p>step1中还是使用ng-repeat遍历出的options，然后这个select又绑定了一个model，可以在controller用于判定用户的选项，然后根据这个选项，在users的数组中进行查找，最后，显示在查询结果的框中。</p>\n<p>今天遇到的几个问题：<br>1.数据可视化和canvas视图留了一个坑。<br>2.突然发现controller之间的方法、变量不可以共享，例如我在下面的控制器中创建的用户数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.users=[</span><br><span class=\"line\">&#123;...&#125;,</span><br><span class=\"line\">&#123;...&#125;,</span><br><span class=\"line\">&#123;...&#125;,</span><br><span class=\"line\">&#123;...&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>在上面查询控制器中无法访问，网上查询之，得到结果，原因是作用域无法访问，这点跟js比较像，两个在树形结构上是兄弟层级关系的节点，不能访问对方的内部变量。但是angular 可以像js一样，变量继承，因此，可以吧users挂到 相对比较高的祖先节点上，这样，其子控制器就可以访问到了。<br>3.在Step1的位置，出现了F5以后，默认出现一个空白options的现象，查看元素，得知该元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;option value=&quot;  undefind!&quot;&gt;&lt;/option&gt;</span><br></pre></td></tr></table></figure>\n<p>于是采用了一个笨办法，手动添加一个<br><code>&lt;option value=&quot;&quot; selected=&quot;&quot;&gt;&lt;/option&gt;</code><br>然后，在ng-repeat的原始option选项中，也添加<code>selected=&quot;selected&quot;，这样就OK了！</code><br>4.今天对各个控制器进行合理的切分，达到模块化的效果，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*********根控制器的数据*********/</span><br><span class=\"line\"> \tapp.controller(&apos;rootctrl&apos;,function($scope)&#123;</span><br><span class=\"line\"> \t\t$scope.users = [</span><br><span class=\"line\"> \t\t&#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125;</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\"> \t\t];</span><br><span class=\"line\"> \t&#125;)</span><br><span class=\"line\">/**********增加用户 控制器*************/</span><br><span class=\"line\"> $scope.addUser = function()&#123;</span><br><span class=\"line\">       var index = $scope.users.length-1;</span><br><span class=\"line\">  </span><br><span class=\"line\">       \t$scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"> /**********查询 控制器************ /</span><br><span class=\"line\"> $scope.jiansuo = function()&#123;</span><br><span class=\"line\"> \t\t\tvar a = $scope.selectValue;</span><br><span class=\"line\"> \t\t\t$scope.result = a;</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\"> \t\t    if(a==&quot;&quot;||null||undefined)&#123;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;sp&apos;).innerHTML=&quot;未选择/未输入!&quot;;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请先选择分类&apos;)</span><br><span class=\"line\"> \t\t    &#125;</span><br><span class=\"line\"> \t\t    else&#123;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;sp&apos;).innerHTML=&quot;您要查询的&quot;+$scope.infos[a].name+&quot;是:&quot;+$scope.input;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请输入具体的&apos;+$scope.infos[a].name+&quot;！&quot;);</span><br><span class=\"line\"> \t\t    &#125;</span><br><span class=\"line\"> \t\t\t</span><br><span class=\"line\"> \t\t\t</span><br><span class=\"line\"> \t\t\t</span><br><span class=\"line\"> \t\t&#125;;</span><br><span class=\"line\"> /********删除 控制器***********/</span><br><span class=\"line\">    </span><br><span class=\"line\">      $scope.remove = function(index)&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">//   if($scope.users.length&lt;=1)&#123;</span><br><span class=\"line\">//   \t$scope.users.splice(index,1)</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">//   else&#123;&#125;</span><br><span class=\"line\">         \t$scope.users.splice(index,1)</span><br><span class=\"line\">         </span><br><span class=\"line\">         </span><br><span class=\"line\"></span><br><span class=\"line\">      \t \t</span><br><span class=\"line\">            </span><br><span class=\"line\">      &#125;;</span><br></pre></td></tr></table></figure>\n<p>在切分这些控制器的过程中，一定要注意各个控制器的作用域，以及能否访问到调用数据。<br>GitHub:<br><a href=\"https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master</a></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78863387\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>今天基于原来的DEMO，将功能进行了调整。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171221142259866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>如图所示，增加了一个新的controller，完成了增删改查的最后一步：查。</p>\n<p>step1中还是使用ng-repeat遍历出的options，然后这个select又绑定了一个model，可以在controller用于判定用户的选项，然后根据这个选项，在users的数组中进行查找，最后，显示在查询结果的框中。</p>\n<p>今天遇到的几个问题：<br>1.数据可视化和canvas视图留了一个坑。<br>2.突然发现controller之间的方法、变量不可以共享，例如我在下面的控制器中创建的用户数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.users=[</span><br><span class=\"line\">&#123;...&#125;,</span><br><span class=\"line\">&#123;...&#125;,</span><br><span class=\"line\">&#123;...&#125;,</span><br><span class=\"line\">&#123;...&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>在上面查询控制器中无法访问，网上查询之，得到结果，原因是作用域无法访问，这点跟js比较像，两个在树形结构上是兄弟层级关系的节点，不能访问对方的内部变量。但是angular 可以像js一样，变量继承，因此，可以吧users挂到 相对比较高的祖先节点上，这样，其子控制器就可以访问到了。<br>3.在Step1的位置，出现了F5以后，默认出现一个空白options的现象，查看元素，得知该元素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;option value=&quot;  undefind!&quot;&gt;&lt;/option&gt;</span><br></pre></td></tr></table></figure>\n<p>于是采用了一个笨办法，手动添加一个<br><code>&lt;option value=&quot;&quot; selected=&quot;&quot;&gt;&lt;/option&gt;</code><br>然后，在ng-repeat的原始option选项中，也添加<code>selected=&quot;selected&quot;，这样就OK了！</code><br>4.今天对各个控制器进行合理的切分，达到模块化的效果，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*********根控制器的数据*********/</span><br><span class=\"line\"> \tapp.controller(&apos;rootctrl&apos;,function($scope)&#123;</span><br><span class=\"line\"> \t\t$scope.users = [</span><br><span class=\"line\"> \t\t&#123;name:&apos;LiMing&apos;,age:23,job:&apos;fontAnggener&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Hanmeimei&apos;,age:22,job:&apos;teacher&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Wangjie&apos;,age:25,job:&apos;driver&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Liusir&apos;,age:27,job:&apos;business&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;guojingming&apos;,age:29,job:&apos;editor&apos;&#125;,</span><br><span class=\"line\"> \t\t&#123;name:&apos;Yaoming&apos;,age:33,job:&apos;player&apos;&#125;</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\"> \t\t];</span><br><span class=\"line\"> \t&#125;)</span><br><span class=\"line\">/**********增加用户 控制器*************/</span><br><span class=\"line\"> $scope.addUser = function()&#123;</span><br><span class=\"line\">       var index = $scope.users.length-1;</span><br><span class=\"line\">  </span><br><span class=\"line\">       \t$scope.users.push(&#123;name:&apos;&apos;,age:&apos;&apos;,job:&apos;&apos;&#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"> /**********查询 控制器************ /</span><br><span class=\"line\"> $scope.jiansuo = function()&#123;</span><br><span class=\"line\"> \t\t\tvar a = $scope.selectValue;</span><br><span class=\"line\"> \t\t\t$scope.result = a;</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\"> \t\t    if(a==&quot;&quot;||null||undefined)&#123;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;sp&apos;).innerHTML=&quot;未选择/未输入!&quot;;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请先选择分类&apos;)</span><br><span class=\"line\"> \t\t    &#125;</span><br><span class=\"line\"> \t\t    else&#123;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;sp&apos;).innerHTML=&quot;您要查询的&quot;+$scope.infos[a].name+&quot;是:&quot;+$scope.input;</span><br><span class=\"line\"> \t\t    \tdocument.getElementById(&apos;inputInfo&apos;).setAttribute(&apos;placeholder&apos;,&apos;请输入具体的&apos;+$scope.infos[a].name+&quot;！&quot;);</span><br><span class=\"line\"> \t\t    &#125;</span><br><span class=\"line\"> \t\t\t</span><br><span class=\"line\"> \t\t\t</span><br><span class=\"line\"> \t\t\t</span><br><span class=\"line\"> \t\t&#125;;</span><br><span class=\"line\"> /********删除 控制器***********/</span><br><span class=\"line\">    </span><br><span class=\"line\">      $scope.remove = function(index)&#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">//   if($scope.users.length&lt;=1)&#123;</span><br><span class=\"line\">//   \t$scope.users.splice(index,1)</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">//   else&#123;&#125;</span><br><span class=\"line\">         \t$scope.users.splice(index,1)</span><br><span class=\"line\">         </span><br><span class=\"line\">         </span><br><span class=\"line\"></span><br><span class=\"line\">      \t \t</span><br><span class=\"line\">            </span><br><span class=\"line\">      &#125;;</span><br></pre></td></tr></table></figure>\n<p>在切分这些控制器的过程中，一定要注意各个控制器的作用域，以及能否访问到调用数据。<br>GitHub:<br><a href=\"https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/Manage-system-By-AngularJs/commits/master</a></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Express快速构建应用(一)","date":"2017-12-25T03:27:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78890797)\n\nExpress是基于Nodejs的前端应用构建工具，可以快速开发基于Node的前端SPA，在Nodejs的基础上，又进行一些功能的扩充，使得应用的构建流程非常简单高效，应用也足够健壮。\n## 1.安装与 环境配置##\n首先使用IDE建一个工程目录，放在Nodejs.exe 的同域目录下。\n然后打开Git bash,输入，然后进入工程目录，接着 `$npm init` 表明我们要创建一个应用，最后疯狂回车，可以看到，在工程目录里自动生成了package.json文件。\n![这里写图片描述](http://img.blog.csdn.net/20171225112504969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n接下来安装Express，命令行敲：`$npm install express --save`将express包存放到我们的工程目录里，甚至还可以将其在json文件中声明依赖关系，只需要多加一个-dev：\n\n```\n$npm install express --save-dev\n```\n接着会看到工程目录里出现了modules子目录，并且已经为我们下载好了express及其依赖的包（看上图）。\n\n接下来，我们创建一个app.js，放在工程子目录，app.js代码如下：\n\n```\n//app.js\nvar express = require('express'); //require进来我们的Express\nvar app = express(); //实例化\n\n//匹配任意路由，都返回下面这句：first test success\napp.get('/',function(req,res){\nres.send('first test success!');\n});\n\n//接着配置server\nvar server = app.listen(3000,function(){\nconsole.log('绑定到了3000端口')\n});\n\n```\n在命令行敲：`$node app.js`，打开浏览器输入127.0.0.1:3000 可以看到\"first test success\"\n![这里写图片描述](http://img.blog.csdn.net/20171225113447312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n## 2.路由功能 ##\n在进入一些网页的时候，会看到后面的url坠着 index.html，这是网站的homepage，如果去列表页，则后缀会变成: list.html，这个其实就是路由，根据请求的url不同，服务器返回不同的路径。\n而express可以很好的胜任这个功能。下面来看\n在刚才的app.js中加入一些代码，并创建新的index.html文件：\n\n```\n//app.js\n//使用get请求到index.html时，会向页面吐出一个index.html的文件\napp.get('/index.html',function(req,res){\n\tres.sendfile('./index.html')\t\n\t\n});\n\n//index.html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title></title>\n\t</head>\n\t<body>\n\t\t<h1>gekki</h1>\n\t\t<h2>hello</h2>\n\t\t<h3>ke;llt</h3>\n\t</body>\n</html>\n\n```\n接着，继续运行`$node app.js`，网页中输入URL：127.0.0.1:3000/index.html\n效果如图：\n![这里写图片描述](http://img.blog.csdn.net/20171225130220554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n成功了！\n\n在命令行中，会提示\n![这里写图片描述](http://img.blog.csdn.net/20171225130107618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n提示我们 : res.sendfile不太赞成使用，应该使用驼峰式命名 res.sendFile。。。粗心了。\n由上述例子可知，express对于路由的配置非常之简单。设想一下，在一些需要密码和表单操作密集的地方，可以采用post请求来进行路由的配置。那么同理，如果想要加载图片或者加载其他问价，则可以：\n\n```\n//表单的html\napp.post('/form.html',function(req,res){\nres.sendFile('./form.html');\n});\n\n\n\n//访问路由的某个图片\n//all方法用于 匹配所有的请求类型，不管是post,get,put,delete等等都给他返回指定的东西，一视同仁。\napp.all('./longzhu.png',function(req,res){  \nres.sendFile('./img/longzhu.png');\n});\n```\n## 3.静态资源 ##\n所谓的静态资源，就是一旦网页生成，就不会再被改变了。例如：图片，CSS,JS文件等。\n我们可以将这些文件放置在一个统一的文件夹里面，命名为：public\n![这里写图片描述](http://img.blog.csdn.net/20171225130726717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n现在，在public下粘贴一张图片，接下来，我们来看这些静态资源应该如何配置以及访问：\n\n```\n//app.js\napp.use(express.static('./public'));//一句话就完成了静态资源的配置\n```\n接着，在浏览器中输入:127.0.0.1:3000/xxx.png ，我们可以得到效果：\n![这里写图片描述](http://img.blog.csdn.net/20171225130939742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n说明静态资源配置成功，同理，我们在来试试其他类型的文件:\n\n![这里写图片描述](http://img.blog.csdn.net/20171225131120326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![这里写图片描述](http://img.blog.csdn.net/20171225131151137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n都OK。\n\n有时候，可以在一个路由请求中写多个callback函数，来不断的匹配用户输入的需求路由：\n\n```\n//app.js\n\napp.get('/123.error',callback1,callback2);\n```\n此时，如果第一个callback捕获不到路由，则将皮球提给第二个callback函数来执行，不过要在第一个callback中写明白参数:\n```\n\nfunction(req,res,next){\nconsole.log('对不起，我没找到，现在请下一个回调函数帮你找')\nnext();\n},\nfunction (req,res){\nconsole.log('find it!');\nres.sendFile('123.error');\n}\n```\n整个回调函数甚至可以组成一个数组，来对用户的请求进行匹配：\n\n```\n回调函数1:  \nvar a = function(req,res,next){\n....\nnext();\n\n};\n回调函数2:\nvar b = function(req,res,next){\n....\nnext();\n\n};\n\n回调函数3:\nvar b = function(req,res){\n....\nconsole.log('找到了!');\n\n};\n\n\napp.get('/123.error',[a,b,c]);  //这样写很美观\n```\n当然也可以使用数组和function(){}的混合写法，但是这样写我想不出来哪个地方有好处？\n\n\n\n在访问不同的路由时，不必从新restar server，因为服务器是在返回本地的目录，这个状态是一直轮询的，如果有就返回，没有就老老实实报错404 .\n\n当然，整个路由匹配的时候，甚至可以使用正则魔法，以防止用户的误输入行为，防患于未然。\n\n\n## 4.API走马观花 ##\n1.res.download() \t提示下载文件。  //res.download('文件名')，\n2.res.end() \t终结响应处理流程。\n3.res.json() \t发送一个 JSON 格式的响应。\n4.res.jsonp() \t发送一个支持 JSONP 的 JSON 格式的响应。\n5.res.redirect() \t重定向请求。 //更改用于在根url之后的路由，例如用户输入了:127.0.0.1:3000/index.html\n我们可以`res.redirect('error.html');`，此时浏览器的url会自动变成：127.0.0.1:3000/error.html\n\n\n6.res.render() \t渲染视图模板。 \n7.res.send() \t发送各种类型的响应。\n8.res.sendFile \t以八位字节流的形式发送文件。\n9.res.sendStatus() \t设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。//express预设好了，我就试了两个:\n`res.sendStatus(200)//页面显示：OK `\n\n```\nres.sendStatus(404)//页面显示：Not Found\n```\n留坑。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Express快速构建应用.md","raw":"---\ntitle: Express快速构建应用(一) \ndate: 2017-12-25 11:27:00\ntags: Express\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78890797)\n\nExpress是基于Nodejs的前端应用构建工具，可以快速开发基于Node的前端SPA，在Nodejs的基础上，又进行一些功能的扩充，使得应用的构建流程非常简单高效，应用也足够健壮。\n## 1.安装与 环境配置##\n首先使用IDE建一个工程目录，放在Nodejs.exe 的同域目录下。\n然后打开Git bash,输入，然后进入工程目录，接着 `$npm init` 表明我们要创建一个应用，最后疯狂回车，可以看到，在工程目录里自动生成了package.json文件。\n![这里写图片描述](http://img.blog.csdn.net/20171225112504969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n接下来安装Express，命令行敲：`$npm install express --save`将express包存放到我们的工程目录里，甚至还可以将其在json文件中声明依赖关系，只需要多加一个-dev：\n\n```\n$npm install express --save-dev\n```\n接着会看到工程目录里出现了modules子目录，并且已经为我们下载好了express及其依赖的包（看上图）。\n\n接下来，我们创建一个app.js，放在工程子目录，app.js代码如下：\n\n```\n//app.js\nvar express = require('express'); //require进来我们的Express\nvar app = express(); //实例化\n\n//匹配任意路由，都返回下面这句：first test success\napp.get('/',function(req,res){\nres.send('first test success!');\n});\n\n//接着配置server\nvar server = app.listen(3000,function(){\nconsole.log('绑定到了3000端口')\n});\n\n```\n在命令行敲：`$node app.js`，打开浏览器输入127.0.0.1:3000 可以看到\"first test success\"\n![这里写图片描述](http://img.blog.csdn.net/20171225113447312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n## 2.路由功能 ##\n在进入一些网页的时候，会看到后面的url坠着 index.html，这是网站的homepage，如果去列表页，则后缀会变成: list.html，这个其实就是路由，根据请求的url不同，服务器返回不同的路径。\n而express可以很好的胜任这个功能。下面来看\n在刚才的app.js中加入一些代码，并创建新的index.html文件：\n\n```\n//app.js\n//使用get请求到index.html时，会向页面吐出一个index.html的文件\napp.get('/index.html',function(req,res){\n\tres.sendfile('./index.html')\t\n\t\n});\n\n//index.html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title></title>\n\t</head>\n\t<body>\n\t\t<h1>gekki</h1>\n\t\t<h2>hello</h2>\n\t\t<h3>ke;llt</h3>\n\t</body>\n</html>\n\n```\n接着，继续运行`$node app.js`，网页中输入URL：127.0.0.1:3000/index.html\n效果如图：\n![这里写图片描述](http://img.blog.csdn.net/20171225130220554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n成功了！\n\n在命令行中，会提示\n![这里写图片描述](http://img.blog.csdn.net/20171225130107618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n提示我们 : res.sendfile不太赞成使用，应该使用驼峰式命名 res.sendFile。。。粗心了。\n由上述例子可知，express对于路由的配置非常之简单。设想一下，在一些需要密码和表单操作密集的地方，可以采用post请求来进行路由的配置。那么同理，如果想要加载图片或者加载其他问价，则可以：\n\n```\n//表单的html\napp.post('/form.html',function(req,res){\nres.sendFile('./form.html');\n});\n\n\n\n//访问路由的某个图片\n//all方法用于 匹配所有的请求类型，不管是post,get,put,delete等等都给他返回指定的东西，一视同仁。\napp.all('./longzhu.png',function(req,res){  \nres.sendFile('./img/longzhu.png');\n});\n```\n## 3.静态资源 ##\n所谓的静态资源，就是一旦网页生成，就不会再被改变了。例如：图片，CSS,JS文件等。\n我们可以将这些文件放置在一个统一的文件夹里面，命名为：public\n![这里写图片描述](http://img.blog.csdn.net/20171225130726717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n现在，在public下粘贴一张图片，接下来，我们来看这些静态资源应该如何配置以及访问：\n\n```\n//app.js\napp.use(express.static('./public'));//一句话就完成了静态资源的配置\n```\n接着，在浏览器中输入:127.0.0.1:3000/xxx.png ，我们可以得到效果：\n![这里写图片描述](http://img.blog.csdn.net/20171225130939742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n说明静态资源配置成功，同理，我们在来试试其他类型的文件:\n\n![这里写图片描述](http://img.blog.csdn.net/20171225131120326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![这里写图片描述](http://img.blog.csdn.net/20171225131151137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n都OK。\n\n有时候，可以在一个路由请求中写多个callback函数，来不断的匹配用户输入的需求路由：\n\n```\n//app.js\n\napp.get('/123.error',callback1,callback2);\n```\n此时，如果第一个callback捕获不到路由，则将皮球提给第二个callback函数来执行，不过要在第一个callback中写明白参数:\n```\n\nfunction(req,res,next){\nconsole.log('对不起，我没找到，现在请下一个回调函数帮你找')\nnext();\n},\nfunction (req,res){\nconsole.log('find it!');\nres.sendFile('123.error');\n}\n```\n整个回调函数甚至可以组成一个数组，来对用户的请求进行匹配：\n\n```\n回调函数1:  \nvar a = function(req,res,next){\n....\nnext();\n\n};\n回调函数2:\nvar b = function(req,res,next){\n....\nnext();\n\n};\n\n回调函数3:\nvar b = function(req,res){\n....\nconsole.log('找到了!');\n\n};\n\n\napp.get('/123.error',[a,b,c]);  //这样写很美观\n```\n当然也可以使用数组和function(){}的混合写法，但是这样写我想不出来哪个地方有好处？\n\n\n\n在访问不同的路由时，不必从新restar server，因为服务器是在返回本地的目录，这个状态是一直轮询的，如果有就返回，没有就老老实实报错404 .\n\n当然，整个路由匹配的时候，甚至可以使用正则魔法，以防止用户的误输入行为，防患于未然。\n\n\n## 4.API走马观花 ##\n1.res.download() \t提示下载文件。  //res.download('文件名')，\n2.res.end() \t终结响应处理流程。\n3.res.json() \t发送一个 JSON 格式的响应。\n4.res.jsonp() \t发送一个支持 JSONP 的 JSON 格式的响应。\n5.res.redirect() \t重定向请求。 //更改用于在根url之后的路由，例如用户输入了:127.0.0.1:3000/index.html\n我们可以`res.redirect('error.html');`，此时浏览器的url会自动变成：127.0.0.1:3000/error.html\n\n\n6.res.render() \t渲染视图模板。 \n7.res.send() \t发送各种类型的响应。\n8.res.sendFile \t以八位字节流的形式发送文件。\n9.res.sendStatus() \t设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。//express预设好了，我就试了两个:\n`res.sendStatus(200)//页面显示：OK `\n\n```\nres.sendStatus(404)//页面显示：Not Found\n```\n留坑。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Express快速构建应用","published":1,"updated":"2018-08-29T05:59:20.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdf8000ejgv43vwvvj66","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78890797\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>Express是基于Nodejs的前端应用构建工具，可以快速开发基于Node的前端SPA，在Nodejs的基础上，又进行一些功能的扩充，使得应用的构建流程非常简单高效，应用也足够健壮。</p>\n<h2 id=\"1-安装与-环境配置\"><a href=\"#1-安装与-环境配置\" class=\"headerlink\" title=\"1.安装与 环境配置\"></a>1.安装与 环境配置</h2><p>首先使用IDE建一个工程目录，放在Nodejs.exe 的同域目录下。<br>然后打开Git bash,输入，然后进入工程目录，接着 <code>$npm init</code> 表明我们要创建一个应用，最后疯狂回车，可以看到，在工程目录里自动生成了package.json文件。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225112504969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>接下来安装Express，命令行敲：<code>$npm install express --save</code>将express包存放到我们的工程目录里，甚至还可以将其在json文件中声明依赖关系，只需要多加一个-dev：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$npm install express --save-dev</span><br></pre></td></tr></table></figure>\n<p>接着会看到工程目录里出现了modules子目录，并且已经为我们下载好了express及其依赖的包（看上图）。</p>\n<p>接下来，我们创建一个app.js，放在工程子目录，app.js代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\">var express = require(&apos;express&apos;); //require进来我们的Express</span><br><span class=\"line\">var app = express(); //实例化</span><br><span class=\"line\"></span><br><span class=\"line\">//匹配任意路由，都返回下面这句：first test success</span><br><span class=\"line\">app.get(&apos;/&apos;,function(req,res)&#123;</span><br><span class=\"line\">res.send(&apos;first test success!&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//接着配置server</span><br><span class=\"line\">var server = app.listen(3000,function()&#123;</span><br><span class=\"line\">console.log(&apos;绑定到了3000端口&apos;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在命令行敲：<code>$node app.js</code>，打开浏览器输入127.0.0.1:3000 可以看到”first test success”<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225113447312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<h2 id=\"2-路由功能\"><a href=\"#2-路由功能\" class=\"headerlink\" title=\"2.路由功能\"></a>2.路由功能</h2><p>在进入一些网页的时候，会看到后面的url坠着 index.html，这是网站的homepage，如果去列表页，则后缀会变成: list.html，这个其实就是路由，根据请求的url不同，服务器返回不同的路径。<br>而express可以很好的胜任这个功能。下面来看<br>在刚才的app.js中加入一些代码，并创建新的index.html文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\">//使用get请求到index.html时，会向页面吐出一个index.html的文件</span><br><span class=\"line\">app.get(&apos;/index.html&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tres.sendfile(&apos;./index.html&apos;)\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//index.html</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;h1&gt;gekki&lt;/h1&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;hello&lt;/h2&gt;</span><br><span class=\"line\">\t\t&lt;h3&gt;ke;llt&lt;/h3&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>接着，继续运行<code>$node app.js</code>，网页中输入URL：127.0.0.1:3000/index.html<br>效果如图：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130220554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>成功了！</p>\n<p>在命令行中，会提示<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130107618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>提示我们 : res.sendfile不太赞成使用，应该使用驼峰式命名 res.sendFile。。。粗心了。<br>由上述例子可知，express对于路由的配置非常之简单。设想一下，在一些需要密码和表单操作密集的地方，可以采用post请求来进行路由的配置。那么同理，如果想要加载图片或者加载其他问价，则可以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//表单的html</span><br><span class=\"line\">app.post(&apos;/form.html&apos;,function(req,res)&#123;</span><br><span class=\"line\">res.sendFile(&apos;./form.html&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//访问路由的某个图片</span><br><span class=\"line\">//all方法用于 匹配所有的请求类型，不管是post,get,put,delete等等都给他返回指定的东西，一视同仁。</span><br><span class=\"line\">app.all(&apos;./longzhu.png&apos;,function(req,res)&#123;  </span><br><span class=\"line\">res.sendFile(&apos;./img/longzhu.png&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-静态资源\"><a href=\"#3-静态资源\" class=\"headerlink\" title=\"3.静态资源\"></a>3.静态资源</h2><p>所谓的静态资源，就是一旦网页生成，就不会再被改变了。例如：图片，CSS,JS文件等。<br>我们可以将这些文件放置在一个统一的文件夹里面，命名为：public<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130726717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>现在，在public下粘贴一张图片，接下来，我们来看这些静态资源应该如何配置以及访问：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\">app.use(express.static(&apos;./public&apos;));//一句话就完成了静态资源的配置</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中输入:127.0.0.1:3000/xxx.png ，我们可以得到效果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130939742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>说明静态资源配置成功，同理，我们在来试试其他类型的文件:</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225131120326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225131151137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>都OK。</p>\n<p>有时候，可以在一个路由请求中写多个callback函数，来不断的匹配用户输入的需求路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/123.error&apos;,callback1,callback2);</span><br></pre></td></tr></table></figure>\n<p>此时，如果第一个callback捕获不到路由，则将皮球提给第二个callback函数来执行，不过要在第一个callback中写明白参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function(req,res,next)&#123;</span><br><span class=\"line\">console.log(&apos;对不起，我没找到，现在请下一个回调函数帮你找&apos;)</span><br><span class=\"line\">next();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">function (req,res)&#123;</span><br><span class=\"line\">console.log(&apos;find it!&apos;);</span><br><span class=\"line\">res.sendFile(&apos;123.error&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>整个回调函数甚至可以组成一个数组，来对用户的请求进行匹配：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回调函数1:  </span><br><span class=\"line\">var a = function(req,res,next)&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">next();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">回调函数2:</span><br><span class=\"line\">var b = function(req,res,next)&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">next();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">回调函数3:</span><br><span class=\"line\">var b = function(req,res)&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">console.log(&apos;找到了!&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/123.error&apos;,[a,b,c]);  //这样写很美观</span><br></pre></td></tr></table></figure>\n<p>当然也可以使用数组和function(){}的混合写法，但是这样写我想不出来哪个地方有好处？</p>\n<p>在访问不同的路由时，不必从新restar server，因为服务器是在返回本地的目录，这个状态是一直轮询的，如果有就返回，没有就老老实实报错404 .</p>\n<p>当然，整个路由匹配的时候，甚至可以使用正则魔法，以防止用户的误输入行为，防患于未然。</p>\n<h2 id=\"4-API走马观花\"><a href=\"#4-API走马观花\" class=\"headerlink\" title=\"4.API走马观花\"></a>4.API走马观花</h2><p>1.res.download()     提示下载文件。  //res.download(‘文件名’)，<br>2.res.end()     终结响应处理流程。<br>3.res.json()     发送一个 JSON 格式的响应。<br>4.res.jsonp()     发送一个支持 JSONP 的 JSON 格式的响应。<br>5.res.redirect()     重定向请求。 //更改用于在根url之后的路由，例如用户输入了:127.0.0.1:3000/index.html<br>我们可以<code>res.redirect(&#39;error.html&#39;);</code>，此时浏览器的url会自动变成：127.0.0.1:3000/error.html</p>\n<p>6.res.render()     渲染视图模板。<br>7.res.send()     发送各种类型的响应。<br>8.res.sendFile     以八位字节流的形式发送文件。<br>9.res.sendStatus()     设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。//express预设好了，我就试了两个:<br><code>res.sendStatus(200)//页面显示：OK</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.sendStatus(404)//页面显示：Not Found</span><br></pre></td></tr></table></figure>\n<p>留坑。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78890797\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>Express是基于Nodejs的前端应用构建工具，可以快速开发基于Node的前端SPA，在Nodejs的基础上，又进行一些功能的扩充，使得应用的构建流程非常简单高效，应用也足够健壮。</p>\n<h2 id=\"1-安装与-环境配置\"><a href=\"#1-安装与-环境配置\" class=\"headerlink\" title=\"1.安装与 环境配置\"></a>1.安装与 环境配置</h2><p>首先使用IDE建一个工程目录，放在Nodejs.exe 的同域目录下。<br>然后打开Git bash,输入，然后进入工程目录，接着 <code>$npm init</code> 表明我们要创建一个应用，最后疯狂回车，可以看到，在工程目录里自动生成了package.json文件。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225112504969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>接下来安装Express，命令行敲：<code>$npm install express --save</code>将express包存放到我们的工程目录里，甚至还可以将其在json文件中声明依赖关系，只需要多加一个-dev：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$npm install express --save-dev</span><br></pre></td></tr></table></figure>\n<p>接着会看到工程目录里出现了modules子目录，并且已经为我们下载好了express及其依赖的包（看上图）。</p>\n<p>接下来，我们创建一个app.js，放在工程子目录，app.js代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\">var express = require(&apos;express&apos;); //require进来我们的Express</span><br><span class=\"line\">var app = express(); //实例化</span><br><span class=\"line\"></span><br><span class=\"line\">//匹配任意路由，都返回下面这句：first test success</span><br><span class=\"line\">app.get(&apos;/&apos;,function(req,res)&#123;</span><br><span class=\"line\">res.send(&apos;first test success!&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//接着配置server</span><br><span class=\"line\">var server = app.listen(3000,function()&#123;</span><br><span class=\"line\">console.log(&apos;绑定到了3000端口&apos;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在命令行敲：<code>$node app.js</code>，打开浏览器输入127.0.0.1:3000 可以看到”first test success”<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225113447312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<h2 id=\"2-路由功能\"><a href=\"#2-路由功能\" class=\"headerlink\" title=\"2.路由功能\"></a>2.路由功能</h2><p>在进入一些网页的时候，会看到后面的url坠着 index.html，这是网站的homepage，如果去列表页，则后缀会变成: list.html，这个其实就是路由，根据请求的url不同，服务器返回不同的路径。<br>而express可以很好的胜任这个功能。下面来看<br>在刚才的app.js中加入一些代码，并创建新的index.html文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\">//使用get请求到index.html时，会向页面吐出一个index.html的文件</span><br><span class=\"line\">app.get(&apos;/index.html&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tres.sendfile(&apos;./index.html&apos;)\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//index.html</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;h1&gt;gekki&lt;/h1&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;hello&lt;/h2&gt;</span><br><span class=\"line\">\t\t&lt;h3&gt;ke;llt&lt;/h3&gt;</span><br><span class=\"line\">\t&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>接着，继续运行<code>$node app.js</code>，网页中输入URL：127.0.0.1:3000/index.html<br>效果如图：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130220554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>成功了！</p>\n<p>在命令行中，会提示<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130107618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>提示我们 : res.sendfile不太赞成使用，应该使用驼峰式命名 res.sendFile。。。粗心了。<br>由上述例子可知，express对于路由的配置非常之简单。设想一下，在一些需要密码和表单操作密集的地方，可以采用post请求来进行路由的配置。那么同理，如果想要加载图片或者加载其他问价，则可以：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//表单的html</span><br><span class=\"line\">app.post(&apos;/form.html&apos;,function(req,res)&#123;</span><br><span class=\"line\">res.sendFile(&apos;./form.html&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//访问路由的某个图片</span><br><span class=\"line\">//all方法用于 匹配所有的请求类型，不管是post,get,put,delete等等都给他返回指定的东西，一视同仁。</span><br><span class=\"line\">app.all(&apos;./longzhu.png&apos;,function(req,res)&#123;  </span><br><span class=\"line\">res.sendFile(&apos;./img/longzhu.png&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-静态资源\"><a href=\"#3-静态资源\" class=\"headerlink\" title=\"3.静态资源\"></a>3.静态资源</h2><p>所谓的静态资源，就是一旦网页生成，就不会再被改变了。例如：图片，CSS,JS文件等。<br>我们可以将这些文件放置在一个统一的文件夹里面，命名为：public<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130726717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>现在，在public下粘贴一张图片，接下来，我们来看这些静态资源应该如何配置以及访问：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\">app.use(express.static(&apos;./public&apos;));//一句话就完成了静态资源的配置</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中输入:127.0.0.1:3000/xxx.png ，我们可以得到效果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225130939742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>说明静态资源配置成功，同理，我们在来试试其他类型的文件:</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225131120326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171225131151137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>都OK。</p>\n<p>有时候，可以在一个路由请求中写多个callback函数，来不断的匹配用户输入的需求路由：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//app.js</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/123.error&apos;,callback1,callback2);</span><br></pre></td></tr></table></figure>\n<p>此时，如果第一个callback捕获不到路由，则将皮球提给第二个callback函数来执行，不过要在第一个callback中写明白参数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function(req,res,next)&#123;</span><br><span class=\"line\">console.log(&apos;对不起，我没找到，现在请下一个回调函数帮你找&apos;)</span><br><span class=\"line\">next();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">function (req,res)&#123;</span><br><span class=\"line\">console.log(&apos;find it!&apos;);</span><br><span class=\"line\">res.sendFile(&apos;123.error&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>整个回调函数甚至可以组成一个数组，来对用户的请求进行匹配：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回调函数1:  </span><br><span class=\"line\">var a = function(req,res,next)&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">next();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">回调函数2:</span><br><span class=\"line\">var b = function(req,res,next)&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">next();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">回调函数3:</span><br><span class=\"line\">var b = function(req,res)&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\">console.log(&apos;找到了!&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/123.error&apos;,[a,b,c]);  //这样写很美观</span><br></pre></td></tr></table></figure>\n<p>当然也可以使用数组和function(){}的混合写法，但是这样写我想不出来哪个地方有好处？</p>\n<p>在访问不同的路由时，不必从新restar server，因为服务器是在返回本地的目录，这个状态是一直轮询的，如果有就返回，没有就老老实实报错404 .</p>\n<p>当然，整个路由匹配的时候，甚至可以使用正则魔法，以防止用户的误输入行为，防患于未然。</p>\n<h2 id=\"4-API走马观花\"><a href=\"#4-API走马观花\" class=\"headerlink\" title=\"4.API走马观花\"></a>4.API走马观花</h2><p>1.res.download()     提示下载文件。  //res.download(‘文件名’)，<br>2.res.end()     终结响应处理流程。<br>3.res.json()     发送一个 JSON 格式的响应。<br>4.res.jsonp()     发送一个支持 JSONP 的 JSON 格式的响应。<br>5.res.redirect()     重定向请求。 //更改用于在根url之后的路由，例如用户输入了:127.0.0.1:3000/index.html<br>我们可以<code>res.redirect(&#39;error.html&#39;);</code>，此时浏览器的url会自动变成：127.0.0.1:3000/error.html</p>\n<p>6.res.render()     渲染视图模板。<br>7.res.send()     发送各种类型的响应。<br>8.res.sendFile     以八位字节流的形式发送文件。<br>9.res.sendStatus()     设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。//express预设好了，我就试了两个:<br><code>res.sendStatus(200)//页面显示：OK</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.sendStatus(404)//页面显示：Not Found</span><br></pre></td></tr></table></figure>\n<p>留坑。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Git与GitHub之本地仓库","date":"2017-12-11T08:07:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78773371)\n\n马上就要到年底了，再复习一下Git的相关知识，还有20天，再拼拼命！\n概念\nGit:分布式版本管理系统。\nGitHub:全球最大同性交友平台。(匿)\n\n**1.本地的版本库**\n==\n## 1.1环境搭建 ##\n首先确保已经安装了Nodejs的环境。\n首先，下载GitBash命令工具。\nhttps://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit\n运行之。\n命令行中敲入\n\n```\n$cd  g:\n$mkdir git\n$cd git\ng盘下创建git目录，并且进入该目录\n```\n## 1.2 建仓库 ##\n**1.创建本地仓库**\n\n```\n$git init  //创建OK，g:\\目录下多了一个 .git的文件夹\n```\n然后，在桌面上手动新建一个test.txt文本，里面输入 \"hllo,world\"，然后将该文本放到git目录下(就是刚才创建的那个目录)\n![这里写图片描述](http://img.blog.csdn.net/20171211152923042?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n**2.现在，将文件读取至工作区**\n\n```\n$ git add test.txt \n```\n这样，就完成了工作流的初步设置\n\n\n**3.对txt文件暗中做手脚**\n\n在test.txt文件中，将\"hello,world\"改为\"hey,boy\"，然后ctrl+s，ctrl+F4二连。\n\n\n**4.再次commit至暂存区**\n再次提交至暂存区（如果不再次提交，那么刚才的改变只是在仓库里改变了，而并非在我们的暂存区进行记录。）\n```\n$ git add test.txt \n```\n**5.然后读取暂存区文件的状态：**\n\n```\n$ git status\n```\n**6.接着上传到本地版本库:**\n\n```\n$git commit -m \"first change\"  //回车\n\n***************注意:!!!每次commit都会生成一个版本******\n```\n\nOK,这样，系统就记录下了这次改变。当然也可以随时$git status ，来查看当前的暂存区是否干净 (clean)。\n\n**7.要查看历次的修改记录，或者回滚到任一一个版本，可以:**\n\n```\n$git log\n或者$git reflog //reflog可以显示每次迭代的文件值，并进行排序\n```\n如果想要项目升级或降级到某一个版本，可以这样：\n\n```\n$git reflog //查看变更记录，与对应的入口文件值(自动生成)\n\n```\n想去哪里就去那里：\n\n```\n$git reset --hard \"对应的文件入口，例如35s421\"\n\n/*这里的入口文件值，可以写5位，4位甚至更少，因为计算机会自动根据名字来遍历检索，因此为了效率和不必要的麻烦，尽量写7位左右。*/\n```\n**8.撤销修改**\n改到一半发现还不如不改？如果没有commit，那么可以使用“一键还原”\n\n```\n$git checkout --test.txt\n\n//这会使test.txt回到版本库中的状态，即：还没有bei $git add test.txt的时候\n```\n如果已经commit了，那么只能回到最后一次commit的状态。\n\n```\n$git rm test.txt \n\n//做完测试，顺手清理\n```\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Git与GitHub之本地仓库.md","raw":"---\ntitle: Git与GitHub之本地仓库 \ndate: 2017-12-11 16:07:00\ntags: git\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78773371)\n\n马上就要到年底了，再复习一下Git的相关知识，还有20天，再拼拼命！\n概念\nGit:分布式版本管理系统。\nGitHub:全球最大同性交友平台。(匿)\n\n**1.本地的版本库**\n==\n## 1.1环境搭建 ##\n首先确保已经安装了Nodejs的环境。\n首先，下载GitBash命令工具。\nhttps://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit\n运行之。\n命令行中敲入\n\n```\n$cd  g:\n$mkdir git\n$cd git\ng盘下创建git目录，并且进入该目录\n```\n## 1.2 建仓库 ##\n**1.创建本地仓库**\n\n```\n$git init  //创建OK，g:\\目录下多了一个 .git的文件夹\n```\n然后，在桌面上手动新建一个test.txt文本，里面输入 \"hllo,world\"，然后将该文本放到git目录下(就是刚才创建的那个目录)\n![这里写图片描述](http://img.blog.csdn.net/20171211152923042?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n**2.现在，将文件读取至工作区**\n\n```\n$ git add test.txt \n```\n这样，就完成了工作流的初步设置\n\n\n**3.对txt文件暗中做手脚**\n\n在test.txt文件中，将\"hello,world\"改为\"hey,boy\"，然后ctrl+s，ctrl+F4二连。\n\n\n**4.再次commit至暂存区**\n再次提交至暂存区（如果不再次提交，那么刚才的改变只是在仓库里改变了，而并非在我们的暂存区进行记录。）\n```\n$ git add test.txt \n```\n**5.然后读取暂存区文件的状态：**\n\n```\n$ git status\n```\n**6.接着上传到本地版本库:**\n\n```\n$git commit -m \"first change\"  //回车\n\n***************注意:!!!每次commit都会生成一个版本******\n```\n\nOK,这样，系统就记录下了这次改变。当然也可以随时$git status ，来查看当前的暂存区是否干净 (clean)。\n\n**7.要查看历次的修改记录，或者回滚到任一一个版本，可以:**\n\n```\n$git log\n或者$git reflog //reflog可以显示每次迭代的文件值，并进行排序\n```\n如果想要项目升级或降级到某一个版本，可以这样：\n\n```\n$git reflog //查看变更记录，与对应的入口文件值(自动生成)\n\n```\n想去哪里就去那里：\n\n```\n$git reset --hard \"对应的文件入口，例如35s421\"\n\n/*这里的入口文件值，可以写5位，4位甚至更少，因为计算机会自动根据名字来遍历检索，因此为了效率和不必要的麻烦，尽量写7位左右。*/\n```\n**8.撤销修改**\n改到一半发现还不如不改？如果没有commit，那么可以使用“一键还原”\n\n```\n$git checkout --test.txt\n\n//这会使test.txt回到版本库中的状态，即：还没有bei $git add test.txt的时候\n```\n如果已经commit了，那么只能回到最后一次commit的状态。\n\n```\n$git rm test.txt \n\n//做完测试，顺手清理\n```\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Git与GitHub之本地仓库","published":1,"updated":"2018-08-29T05:59:20.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfa000fjgv4971hf84q","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78773371\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>马上就要到年底了，再复习一下Git的相关知识，还有20天，再拼拼命！<br>概念<br>Git:分布式版本管理系统。<br>GitHub:全球最大同性交友平台。(匿)</p>\n<h1 id=\"1-本地的版本库\"><a href=\"#1-本地的版本库\" class=\"headerlink\" title=\"1.本地的版本库\"></a><strong>1.本地的版本库</strong></h1><h2 id=\"1-1环境搭建\"><a href=\"#1-1环境搭建\" class=\"headerlink\" title=\"1.1环境搭建\"></a>1.1环境搭建</h2><p>首先确保已经安装了Nodejs的环境。<br>首先，下载GitBash命令工具。<br><a href=\"https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit</a><br>运行之。<br>命令行中敲入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cd  g:</span><br><span class=\"line\">$mkdir git</span><br><span class=\"line\">$cd git</span><br><span class=\"line\">g盘下创建git目录，并且进入该目录</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-建仓库\"><a href=\"#1-2-建仓库\" class=\"headerlink\" title=\"1.2 建仓库\"></a>1.2 建仓库</h2><p><strong>1.创建本地仓库</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git init  //创建OK，g:\\目录下多了一个 .git的文件夹</span><br></pre></td></tr></table></figure>\n<p>然后，在桌面上手动新建一个test.txt文本，里面输入 “hllo,world”，然后将该文本放到git目录下(就是刚才创建的那个目录)<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171211152923042?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p><strong>2.现在，将文件读取至工作区</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add test.txt</span><br></pre></td></tr></table></figure>\n<p>这样，就完成了工作流的初步设置</p>\n<p><strong>3.对txt文件暗中做手脚</strong></p>\n<p>在test.txt文件中，将”hello,world”改为”hey,boy”，然后ctrl+s，ctrl+F4二连。</p>\n<p><strong>4.再次commit至暂存区</strong><br>再次提交至暂存区（如果不再次提交，那么刚才的改变只是在仓库里改变了，而并非在我们的暂存区进行记录。）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add test.txt</span><br></pre></td></tr></table></figure></p>\n<p><strong>5.然后读取暂存区文件的状态：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p><strong>6.接着上传到本地版本库:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git commit -m &quot;first change&quot;  //回车</span><br><span class=\"line\"></span><br><span class=\"line\">***************注意:!!!每次commit都会生成一个版本******</span><br></pre></td></tr></table></figure>\n<p>OK,这样，系统就记录下了这次改变。当然也可以随时$git status ，来查看当前的暂存区是否干净 (clean)。</p>\n<p><strong>7.要查看历次的修改记录，或者回滚到任一一个版本，可以:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git log</span><br><span class=\"line\">或者$git reflog //reflog可以显示每次迭代的文件值，并进行排序</span><br></pre></td></tr></table></figure>\n<p>如果想要项目升级或降级到某一个版本，可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git reflog //查看变更记录，与对应的入口文件值(自动生成)</span><br></pre></td></tr></table></figure>\n<p>想去哪里就去那里：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git reset --hard &quot;对应的文件入口，例如35s421&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">/*这里的入口文件值，可以写5位，4位甚至更少，因为计算机会自动根据名字来遍历检索，因此为了效率和不必要的麻烦，尽量写7位左右。*/</span><br></pre></td></tr></table></figure>\n<p><strong>8.撤销修改</strong><br>改到一半发现还不如不改？如果没有commit，那么可以使用“一键还原”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git checkout --test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">//这会使test.txt回到版本库中的状态，即：还没有bei $git add test.txt的时候</span><br></pre></td></tr></table></figure>\n<p>如果已经commit了，那么只能回到最后一次commit的状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git rm test.txt </span><br><span class=\"line\"></span><br><span class=\"line\">//做完测试，顺手清理</span><br></pre></td></tr></table></figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78773371\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>马上就要到年底了，再复习一下Git的相关知识，还有20天，再拼拼命！<br>概念<br>Git:分布式版本管理系统。<br>GitHub:全球最大同性交友平台。(匿)</p>\n<h1 id=\"1-本地的版本库\"><a href=\"#1-本地的版本库\" class=\"headerlink\" title=\"1.本地的版本库\"></a><strong>1.本地的版本库</strong></h1><h2 id=\"1-1环境搭建\"><a href=\"#1-1环境搭建\" class=\"headerlink\" title=\"1.1环境搭建\"></a>1.1环境搭建</h2><p>首先确保已经安装了Nodejs的环境。<br>首先，下载GitBash命令工具。<br><a href=\"https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit</a><br>运行之。<br>命令行中敲入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cd  g:</span><br><span class=\"line\">$mkdir git</span><br><span class=\"line\">$cd git</span><br><span class=\"line\">g盘下创建git目录，并且进入该目录</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-建仓库\"><a href=\"#1-2-建仓库\" class=\"headerlink\" title=\"1.2 建仓库\"></a>1.2 建仓库</h2><p><strong>1.创建本地仓库</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git init  //创建OK，g:\\目录下多了一个 .git的文件夹</span><br></pre></td></tr></table></figure>\n<p>然后，在桌面上手动新建一个test.txt文本，里面输入 “hllo,world”，然后将该文本放到git目录下(就是刚才创建的那个目录)<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171211152923042?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p><strong>2.现在，将文件读取至工作区</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add test.txt</span><br></pre></td></tr></table></figure>\n<p>这样，就完成了工作流的初步设置</p>\n<p><strong>3.对txt文件暗中做手脚</strong></p>\n<p>在test.txt文件中，将”hello,world”改为”hey,boy”，然后ctrl+s，ctrl+F4二连。</p>\n<p><strong>4.再次commit至暂存区</strong><br>再次提交至暂存区（如果不再次提交，那么刚才的改变只是在仓库里改变了，而并非在我们的暂存区进行记录。）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add test.txt</span><br></pre></td></tr></table></figure></p>\n<p><strong>5.然后读取暂存区文件的状态：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br></pre></td></tr></table></figure>\n<p><strong>6.接着上传到本地版本库:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git commit -m &quot;first change&quot;  //回车</span><br><span class=\"line\"></span><br><span class=\"line\">***************注意:!!!每次commit都会生成一个版本******</span><br></pre></td></tr></table></figure>\n<p>OK,这样，系统就记录下了这次改变。当然也可以随时$git status ，来查看当前的暂存区是否干净 (clean)。</p>\n<p><strong>7.要查看历次的修改记录，或者回滚到任一一个版本，可以:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git log</span><br><span class=\"line\">或者$git reflog //reflog可以显示每次迭代的文件值，并进行排序</span><br></pre></td></tr></table></figure>\n<p>如果想要项目升级或降级到某一个版本，可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git reflog //查看变更记录，与对应的入口文件值(自动生成)</span><br></pre></td></tr></table></figure>\n<p>想去哪里就去那里：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git reset --hard &quot;对应的文件入口，例如35s421&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">/*这里的入口文件值，可以写5位，4位甚至更少，因为计算机会自动根据名字来遍历检索，因此为了效率和不必要的麻烦，尽量写7位左右。*/</span><br></pre></td></tr></table></figure>\n<p><strong>8.撤销修改</strong><br>改到一半发现还不如不改？如果没有commit，那么可以使用“一键还原”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git checkout --test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">//这会使test.txt回到版本库中的状态，即：还没有bei $git add test.txt的时候</span><br></pre></td></tr></table></figure>\n<p>如果已经commit了，那么只能回到最后一次commit的状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git rm test.txt </span><br><span class=\"line\"></span><br><span class=\"line\">//做完测试，顺手清理</span><br></pre></td></tr></table></figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Git与GitHub之远程仓库","date":"2017-12-11T08:46:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78774208)\n\n\n## 在GitHub上创建一个repository。 ##\n1.首先，生成私钥和公钥：\n\n$ ssh-keygen -t rsa -C \"350037310@qq.com\" (最好填写gitHub的注册邮箱)\n\n这里有个关键的地方：SSH，待会会用到。\n\n![这里写图片描述](http://img.blog.csdn.net/20171211161758024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n2.将本地的Git关联到GitHub\n\n在本地命令行中：` git remote add origin git@github.com:ZQ-jhon/test.git`即可关联远程仓库(这里的git@github.com对应上图。)\n\n狂敲回车，然后在C：/Administrator下会生成一个.ssh文件夹，找到里面_pub的文件，记事本打开，全部ctrl+c，来到:\n\ngitHub----->Settings------>SSH and GPG keys ,点New SSH Key ，title随便取个名字，底下内容粘贴刚才复制的_pub文件，OK。\n\nOK，至此，两个库已经关联起来了。关联的GitHub项目库仅仅是名为test的这个库。\n\n3.将本地库推到GitHub中。\n$ git push -u origin master \n\n4.提示信息\n第一次关联推送时，提示：\n\n```\nThe authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.\nRSA key fingerprint is xx.xx.xx.xx.xx.\nAre you sure you want to continue connecting (yes/no)?\n```\n输入yes，回车，OK，现在远程仓库和本地仓目录一摸一样了。\n\n以后每次推送，只需要$git push origin master就行。\n\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Git与GitHub之远程仓库.md","raw":"---\ntitle: Git与GitHub之远程仓库 \ndate: 2017-12-11 16:46:00\ntags: git\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78774208)\n\n\n## 在GitHub上创建一个repository。 ##\n1.首先，生成私钥和公钥：\n\n$ ssh-keygen -t rsa -C \"350037310@qq.com\" (最好填写gitHub的注册邮箱)\n\n这里有个关键的地方：SSH，待会会用到。\n\n![这里写图片描述](http://img.blog.csdn.net/20171211161758024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n2.将本地的Git关联到GitHub\n\n在本地命令行中：` git remote add origin git@github.com:ZQ-jhon/test.git`即可关联远程仓库(这里的git@github.com对应上图。)\n\n狂敲回车，然后在C：/Administrator下会生成一个.ssh文件夹，找到里面_pub的文件，记事本打开，全部ctrl+c，来到:\n\ngitHub----->Settings------>SSH and GPG keys ,点New SSH Key ，title随便取个名字，底下内容粘贴刚才复制的_pub文件，OK。\n\nOK，至此，两个库已经关联起来了。关联的GitHub项目库仅仅是名为test的这个库。\n\n3.将本地库推到GitHub中。\n$ git push -u origin master \n\n4.提示信息\n第一次关联推送时，提示：\n\n```\nThe authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.\nRSA key fingerprint is xx.xx.xx.xx.xx.\nAre you sure you want to continue connecting (yes/no)?\n```\n输入yes，回车，OK，现在远程仓库和本地仓目录一摸一样了。\n\n以后每次推送，只需要$git push origin master就行。\n\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Git与GitHub之远程仓库","published":1,"updated":"2018-08-29T05:59:20.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfc000hjgv44w2mxvbp","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78774208\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"在GitHub上创建一个repository。\"><a href=\"#在GitHub上创建一个repository。\" class=\"headerlink\" title=\"在GitHub上创建一个repository。\"></a>在GitHub上创建一个repository。</h2><p>1.首先，生成私钥和公钥：</p>\n<p>$ ssh-keygen -t rsa -C “<a href=\"mailto:350037310@qq.com\" target=\"_blank\" rel=\"noopener\">350037310@qq.com</a>“ (最好填写gitHub的注册邮箱)</p>\n<p>这里有个关键的地方：SSH，待会会用到。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171211161758024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>2.将本地的Git关联到GitHub</p>\n<p>在本地命令行中：<code>git remote add origin git@github.com:ZQ-jhon/test.git</code>即可关联远程仓库(这里的<a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>对应上图。)</p>\n<p>狂敲回车，然后在C：/Administrator下会生成一个.ssh文件夹，找到里面_pub的文件，记事本打开，全部ctrl+c，来到:</p>\n<p>gitHub—–&gt;Settings——&gt;SSH and GPG keys ,点New SSH Key ，title随便取个名字，底下内容粘贴刚才复制的_pub文件，OK。</p>\n<p>OK，至此，两个库已经关联起来了。关联的GitHub项目库仅仅是名为test的这个库。</p>\n<p>3.将本地库推到GitHub中。<br>$ git push -u origin master </p>\n<p>4.提示信息<br>第一次关联推送时，提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class=\"line\">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>\n<p>输入yes，回车，OK，现在远程仓库和本地仓目录一摸一样了。</p>\n<p>以后每次推送，只需要$git push origin master就行。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78774208\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"在GitHub上创建一个repository。\"><a href=\"#在GitHub上创建一个repository。\" class=\"headerlink\" title=\"在GitHub上创建一个repository。\"></a>在GitHub上创建一个repository。</h2><p>1.首先，生成私钥和公钥：</p>\n<p>$ ssh-keygen -t rsa -C “<a href=\"mailto:350037310@qq.com\" target=\"_blank\" rel=\"noopener\">350037310@qq.com</a>“ (最好填写gitHub的注册邮箱)</p>\n<p>这里有个关键的地方：SSH，待会会用到。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171211161758024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>2.将本地的Git关联到GitHub</p>\n<p>在本地命令行中：<code>git remote add origin git@github.com:ZQ-jhon/test.git</code>即可关联远程仓库(这里的<a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>对应上图。)</p>\n<p>狂敲回车，然后在C：/Administrator下会生成一个.ssh文件夹，找到里面_pub的文件，记事本打开，全部ctrl+c，来到:</p>\n<p>gitHub—–&gt;Settings——&gt;SSH and GPG keys ,点New SSH Key ，title随便取个名字，底下内容粘贴刚才复制的_pub文件，OK。</p>\n<p>OK，至此，两个库已经关联起来了。关联的GitHub项目库仅仅是名为test的这个库。</p>\n<p>3.将本地库推到GitHub中。<br>$ git push -u origin master </p>\n<p>4.提示信息<br>第一次关联推送时，提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class=\"line\">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>\n<p>输入yes，回车，OK，现在远程仓库和本地仓目录一摸一样了。</p>\n<p>以后每次推送，只需要$git push origin master就行。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Html5回顾总结","date":"2018-01-12T02:53:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79041618)\n\n## 1.新标签 ##\n**1.1 `<vedio>`** \n\n```\n<video width=\"320\" height=\"240\" controls=\"controls\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n  <source src=\"movie.mp4\" type=\"video/mp4\">\nYour browser does not support the video tag.\n</video>\n```\n两个video source源是为了最大程度的兼容所有浏览器，该标签IE8及以下不支持。\n比较重要的属性：\n\n```\n预加载   preload:preload\n自动播放 autoplay:autoplay\n循环播放 loop:loop\n```\n常见的高大上的背景视频上嵌套文字的效果可以这样实现：\n\n```\n<!DOCTYPE HTML>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\"/>\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\tvideo{z-index:-99999;float:left;position: relative;left:300px;}\n\t\t\th4{color:white}\n\t\t</style>\n\t\t\n\t</head>\n<body>\n\n<video width=\"320\" height=\"240\" autoplay=\"autoplay\" loop=\"loop\">\n  <source src=\"http://www.w3school.com.cn/i/movie.ogg\" type=\"video/ogg\">\n  <source src=\"http://www.w3school.com.cn/i/movie.ogg\" type=\"video/mp4\">\nYour browser does not support the video tag.\n</video>\n<div style=\"float:left;width:320px;height:240px;z-index:999\">\n   <h4>震惊！野生棕熊竟然对猎物熟视无睹</h4>\n</body>\n</html>\n\n```\n给`video`给z-index：负数 ，给嵌套层的文字给 z-index：正数，然后相对定位，接着取消`video` 的controls属性，这样会隐藏音量条，播放/暂停按钮等控件。\n![这里写图片描述](http://img.blog.csdn.net/20180112101024552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n类似于该网站的页头：[英雄之刃官网](http://cos.qq.com/)\n\n在js中，可以把`<video>` 完全当做一个Dom节点，操作他的相关属性。\n例如：\n\n```\ndocument.getElementById('video').pause()//暂停\n\ndocument.getElementById('video').play()//播放\n\ndocument.getElementById(\"video\").currentSrc;//获得原始播放地址\n\ndocument.getElementById(\"video\").currentTime//获得播放器当前播放位置，单位为s\n\ndocument.getElementById(\"video\").duration //获得视频的整个播放时长\n......\n```\n还有特别多的API，例 如 EVENT：刚开始播放、结束播放、视频的网络状态等等，甚至可以结合播放时间，来控制插入广告。。。\n**1.2 audio  **\n与上述视频同理。兼容度更狭隘：IE9及以上\n**1.3 拖放 Drag 和 drop**\n兼容度：IE9、IE9+\n示例：[W3C拖放示例](http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop)\n**1.4 Canvas**\n*\"始于苹果的一项技术，使得Javascript具有图像绘制的能力\"。*\n\n```\n//HTML:\n<canvas id=\"cvs\" height=\"200\" width=\"200\">\n  您的浏览器不支持<canvas>标签\n</canvas>\n\n//JS:\n<script type=\"text/javascript\">\nvar c=document.getElementById(\"cvs\");  //获取\nvar cxt=c.getContext(\"2d\");  //canvas对象特有的方法，目前仅仅支持到2D，未来可能会支持3D...\ncxt.fillStyle=\"green\"; //填充颜色 \ncxt.fillRect(0,0,150,75); //（x,y,width,height）绘制起始点坐标，绘制的宽高\n</script>\n\n```\n\n贴上自己做的demo\n![这里写图片描述](http://img.blog.csdn.net/20180112115334236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n未完待续。。。\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Html5回顾总结.md","raw":"---\ntitle: Html5回顾总结\ndate: 2018-01-12 10:53:00\ntags: html5\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79041618)\n\n## 1.新标签 ##\n**1.1 `<vedio>`** \n\n```\n<video width=\"320\" height=\"240\" controls=\"controls\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n  <source src=\"movie.mp4\" type=\"video/mp4\">\nYour browser does not support the video tag.\n</video>\n```\n两个video source源是为了最大程度的兼容所有浏览器，该标签IE8及以下不支持。\n比较重要的属性：\n\n```\n预加载   preload:preload\n自动播放 autoplay:autoplay\n循环播放 loop:loop\n```\n常见的高大上的背景视频上嵌套文字的效果可以这样实现：\n\n```\n<!DOCTYPE HTML>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\"/>\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\tvideo{z-index:-99999;float:left;position: relative;left:300px;}\n\t\t\th4{color:white}\n\t\t</style>\n\t\t\n\t</head>\n<body>\n\n<video width=\"320\" height=\"240\" autoplay=\"autoplay\" loop=\"loop\">\n  <source src=\"http://www.w3school.com.cn/i/movie.ogg\" type=\"video/ogg\">\n  <source src=\"http://www.w3school.com.cn/i/movie.ogg\" type=\"video/mp4\">\nYour browser does not support the video tag.\n</video>\n<div style=\"float:left;width:320px;height:240px;z-index:999\">\n   <h4>震惊！野生棕熊竟然对猎物熟视无睹</h4>\n</body>\n</html>\n\n```\n给`video`给z-index：负数 ，给嵌套层的文字给 z-index：正数，然后相对定位，接着取消`video` 的controls属性，这样会隐藏音量条，播放/暂停按钮等控件。\n![这里写图片描述](http://img.blog.csdn.net/20180112101024552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n类似于该网站的页头：[英雄之刃官网](http://cos.qq.com/)\n\n在js中，可以把`<video>` 完全当做一个Dom节点，操作他的相关属性。\n例如：\n\n```\ndocument.getElementById('video').pause()//暂停\n\ndocument.getElementById('video').play()//播放\n\ndocument.getElementById(\"video\").currentSrc;//获得原始播放地址\n\ndocument.getElementById(\"video\").currentTime//获得播放器当前播放位置，单位为s\n\ndocument.getElementById(\"video\").duration //获得视频的整个播放时长\n......\n```\n还有特别多的API，例 如 EVENT：刚开始播放、结束播放、视频的网络状态等等，甚至可以结合播放时间，来控制插入广告。。。\n**1.2 audio  **\n与上述视频同理。兼容度更狭隘：IE9及以上\n**1.3 拖放 Drag 和 drop**\n兼容度：IE9、IE9+\n示例：[W3C拖放示例](http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop)\n**1.4 Canvas**\n*\"始于苹果的一项技术，使得Javascript具有图像绘制的能力\"。*\n\n```\n//HTML:\n<canvas id=\"cvs\" height=\"200\" width=\"200\">\n  您的浏览器不支持<canvas>标签\n</canvas>\n\n//JS:\n<script type=\"text/javascript\">\nvar c=document.getElementById(\"cvs\");  //获取\nvar cxt=c.getContext(\"2d\");  //canvas对象特有的方法，目前仅仅支持到2D，未来可能会支持3D...\ncxt.fillStyle=\"green\"; //填充颜色 \ncxt.fillRect(0,0,150,75); //（x,y,width,height）绘制起始点坐标，绘制的宽高\n</script>\n\n```\n\n贴上自己做的demo\n![这里写图片描述](http://img.blog.csdn.net/20180112115334236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n未完待续。。。\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Html5回顾总结","published":1,"updated":"2018-08-29T05:59:20.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfd000jjgv4dh2clv7n","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79041618\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"1-新标签\"><a href=\"#1-新标签\" class=\"headerlink\" title=\"1.新标签\"></a>1.新标签</h2><p><strong>1.1 <code>&lt;vedio&gt;</code></strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class=\"line\">Your browser does not support the video tag.</span><br><span class=\"line\">&lt;/video&gt;</span><br></pre></td></tr></table></figure>\n<p>两个video source源是为了最大程度的兼容所有浏览器，该标签IE8及以下不支持。<br>比较重要的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">预加载   preload:preload</span><br><span class=\"line\">自动播放 autoplay:autoplay</span><br><span class=\"line\">循环播放 loop:loop</span><br></pre></td></tr></table></figure>\n<p>常见的高大上的背景视频上嵌套文字的效果可以这样实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">\t\t\tvideo&#123;z-index:-99999;float:left;position: relative;left:300px;&#125;</span><br><span class=\"line\">\t\t\th4&#123;color:white&#125;</span><br><span class=\"line\">\t\t&lt;/style&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;video width=&quot;320&quot; height=&quot;240&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class=\"line\">Your browser does not support the video tag.</span><br><span class=\"line\">&lt;/video&gt;</span><br><span class=\"line\">&lt;div style=&quot;float:left;width:320px;height:240px;z-index:999&quot;&gt;</span><br><span class=\"line\">   &lt;h4&gt;震惊！野生棕熊竟然对猎物熟视无睹&lt;/h4&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>给<code>video</code>给z-index：负数 ，给嵌套层的文字给 z-index：正数，然后相对定位，接着取消<code>video</code> 的controls属性，这样会隐藏音量条，播放/暂停按钮等控件。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180112101024552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>类似于该网站的页头：<a href=\"http://cos.qq.com/\" target=\"_blank\" rel=\"noopener\">英雄之刃官网</a></p>\n<p>在js中，可以把<code>&lt;video&gt;</code> 完全当做一个Dom节点，操作他的相关属性。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;video&apos;).pause()//暂停</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&apos;video&apos;).play()//播放</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&quot;video&quot;).currentSrc;//获得原始播放地址</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&quot;video&quot;).currentTime//获得播放器当前播放位置，单位为s</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&quot;video&quot;).duration //获得视频的整个播放时长</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>还有特别多的API，例 如 EVENT：刚开始播放、结束播放、视频的网络状态等等，甚至可以结合播放时间，来控制插入广告。。。<br><strong>1.2 audio  </strong><br>与上述视频同理。兼容度更狭隘：IE9及以上<br><strong>1.3 拖放 Drag 和 drop</strong><br>兼容度：IE9、IE9+<br>示例：<a href=\"http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop\" target=\"_blank\" rel=\"noopener\">W3C拖放示例</a><br><strong>1.4 Canvas</strong><br><em>“始于苹果的一项技术，使得Javascript具有图像绘制的能力”。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//HTML:</span><br><span class=\"line\">&lt;canvas id=&quot;cvs&quot; height=&quot;200&quot; width=&quot;200&quot;&gt;</span><br><span class=\"line\">  您的浏览器不支持&lt;canvas&gt;标签</span><br><span class=\"line\">&lt;/canvas&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//JS:</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">var c=document.getElementById(&quot;cvs&quot;);  //获取</span><br><span class=\"line\">var cxt=c.getContext(&quot;2d&quot;);  //canvas对象特有的方法，目前仅仅支持到2D，未来可能会支持3D...</span><br><span class=\"line\">cxt.fillStyle=&quot;green&quot;; //填充颜色 </span><br><span class=\"line\">cxt.fillRect(0,0,150,75); //（x,y,width,height）绘制起始点坐标，绘制的宽高</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>贴上自己做的demo<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180112115334236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>未完待续。。。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79041618\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"1-新标签\"><a href=\"#1-新标签\" class=\"headerlink\" title=\"1.新标签\"></a>1.新标签</h2><p><strong>1.1 <code>&lt;vedio&gt;</code></strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class=\"line\">Your browser does not support the video tag.</span><br><span class=\"line\">&lt;/video&gt;</span><br></pre></td></tr></table></figure>\n<p>两个video source源是为了最大程度的兼容所有浏览器，该标签IE8及以下不支持。<br>比较重要的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">预加载   preload:preload</span><br><span class=\"line\">自动播放 autoplay:autoplay</span><br><span class=\"line\">循环播放 loop:loop</span><br></pre></td></tr></table></figure>\n<p>常见的高大上的背景视频上嵌套文字的效果可以这样实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">\t\t&lt;style type=&quot;text/css&quot;&gt;</span><br><span class=\"line\">\t\t\tvideo&#123;z-index:-99999;float:left;position: relative;left:300px;&#125;</span><br><span class=\"line\">\t\t\th4&#123;color:white&#125;</span><br><span class=\"line\">\t\t&lt;/style&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;video width=&quot;320&quot; height=&quot;240&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class=\"line\">  &lt;source src=&quot;http://www.w3school.com.cn/i/movie.ogg&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class=\"line\">Your browser does not support the video tag.</span><br><span class=\"line\">&lt;/video&gt;</span><br><span class=\"line\">&lt;div style=&quot;float:left;width:320px;height:240px;z-index:999&quot;&gt;</span><br><span class=\"line\">   &lt;h4&gt;震惊！野生棕熊竟然对猎物熟视无睹&lt;/h4&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>给<code>video</code>给z-index：负数 ，给嵌套层的文字给 z-index：正数，然后相对定位，接着取消<code>video</code> 的controls属性，这样会隐藏音量条，播放/暂停按钮等控件。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180112101024552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>类似于该网站的页头：<a href=\"http://cos.qq.com/\" target=\"_blank\" rel=\"noopener\">英雄之刃官网</a></p>\n<p>在js中，可以把<code>&lt;video&gt;</code> 完全当做一个Dom节点，操作他的相关属性。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;video&apos;).pause()//暂停</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&apos;video&apos;).play()//播放</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&quot;video&quot;).currentSrc;//获得原始播放地址</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&quot;video&quot;).currentTime//获得播放器当前播放位置，单位为s</span><br><span class=\"line\"></span><br><span class=\"line\">document.getElementById(&quot;video&quot;).duration //获得视频的整个播放时长</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>还有特别多的API，例 如 EVENT：刚开始播放、结束播放、视频的网络状态等等，甚至可以结合播放时间，来控制插入广告。。。<br><strong>1.2 audio  </strong><br>与上述视频同理。兼容度更狭隘：IE9及以上<br><strong>1.3 拖放 Drag 和 drop</strong><br>兼容度：IE9、IE9+<br>示例：<a href=\"http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop\" target=\"_blank\" rel=\"noopener\">W3C拖放示例</a><br><strong>1.4 Canvas</strong><br><em>“始于苹果的一项技术，使得Javascript具有图像绘制的能力”。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//HTML:</span><br><span class=\"line\">&lt;canvas id=&quot;cvs&quot; height=&quot;200&quot; width=&quot;200&quot;&gt;</span><br><span class=\"line\">  您的浏览器不支持&lt;canvas&gt;标签</span><br><span class=\"line\">&lt;/canvas&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//JS:</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">var c=document.getElementById(&quot;cvs&quot;);  //获取</span><br><span class=\"line\">var cxt=c.getContext(&quot;2d&quot;);  //canvas对象特有的方法，目前仅仅支持到2D，未来可能会支持3D...</span><br><span class=\"line\">cxt.fillStyle=&quot;green&quot;; //填充颜色 </span><br><span class=\"line\">cxt.fillRect(0,0,150,75); //（x,y,width,height）绘制起始点坐标，绘制的宽高</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>贴上自己做的demo<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180112115334236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>未完待续。。。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"IONIC3 打包安卓apk详细过程（大量图文）","date":"2018-03-06T15:44:03.000Z","reward":true,"comment":true,"_content":"\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79319408)\n\n\n\n本文写于2018年2月12日 22:25:59。\n\n如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。\n\n经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。\n## 1.基本依赖环境 ##\n\n 1. nodejs环境 (作为一个前端相信你已经有了)![nodejs](http://img.blog.csdn.net/20180212223918473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)最好提前配置好node的环境变量，便于全局访问\n 2. jdk(下面细说)![JDK](http://img.blog.csdn.net/20180212224004766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 3. SDK(下面细说，其实主要难就难在SDK配置了)![SDK](http://img.blog.csdn.net/20180212224101120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 4. gradle(下面细说)![gradle](http://img.blog.csdn.net/20180212224141473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 2. 基本工具 ##\n\n 1. gitbash(就是用来替代windows自带的丑陋的CMD)![gitbash](http://img.blog.csdn.net/20180212224300075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 下载：我都打包了！\n链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m\n 2. windows自带的CMD(`window`+`R`输入CMD，管理员身份运行)![CMD](http://img.blog.csdn.net/20180212224327731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 3. VSCode(微软爸爸开发的前端IDE)![VSCode](http://img.blog.csdn.net/20180212224349157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n下载：请自行去微软爸爸官网下载。\n\n## 3.环境配置 ##\n**3.1 nodejs (需要配置环境变量)**\n前端必会，跳过。\n**3.2 jdk (无需配置环境变量)**\n下载：已经上传网盘↓\n链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m\n请自行根据系统安装32/64位的版本。\n安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\\Program Files\\Java \nOK，jdk安装完成，在cmd中，输入`$ java -version`验证是否安装成功。\n\n![jdk安装成功](http://img.blog.csdn.net/20180212225402220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\nOK。\n**3.3 sdk (需要配置环境变量)**\n下载：跟上面的一样，我都打包了。\n链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m\n\n解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。\n将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\\Program Files\\SDK\n接着配置环境变量，我的电脑------右键属性-------高级系统设置-------环境变量。\n在下面的系统变量(s)中，新建，键值对如下：\nname: ANDROID_HOME\nkey: C:\\Program Files\\SDK\n如图所示：\n\n![SDK环境变量](http://img.blog.csdn.net/20180212230110171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\\bin缀在最后面，前面有【;】分隔符。\n\n然后运行CMD，输入`$ android -h`，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。\n\n![ANDROID环境配置验证](http://img.blog.csdn.net/20180212230459827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n现在，打开SDK目录下的SDK Manager.exe\n打开界面上的Tools,选择options，先配置国内镜像：\n\n域名千万不要输入http或者https协议前缀，谁输谁哭。\n\n![配置镜像](http://img.blog.csdn.net/20180212231404498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n下面记得勾选。\n回到主界面，点packages再点reload\n先勾选如下图的三个Tools:\n分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools]\n![Tools](http://img.blog.csdn.net/20180212230934859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n别急，还没完，下面还有一个：\n[SDK platform]![SDK platform](http://img.blog.csdn.net/20180212231104690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n全部选中后，点右下角 install packages 来安装，耐心等待即可。\n**3.4 gradle安装(需要配置环境变量)**\n打开：http://services.gradle.org/distributions/\n下载：gradle-4.1-bin.zip\n同样安装在JDK,SDK的目录下，便于查找。\n同样的配置环境变量：\nGRADLE_HOME=C:\\Program Files\\SDK\\gradle-4.1\n;%GRADLE_HOME%\\bin\n\n测试命令（查看版本）：gradle -v\n \n## 3.基本流程 ##\n1.安装ionic和cordova \n \n打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）\n```\n$ cnpm install -g ionic cordova\n```\n![安装ionic和cordova ](http://img.blog.csdn.net/20180212224442812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.创建ionic项目\n\n桌面右键，在此处gitbash\n```\n$ ionic start app tabs\n```\n耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后\n\n```\n$ ionic serve\n```\n![ionic serve](http://img.blog.csdn.net/20180212224746544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示：\n\n\n![CHROME预览](http://img.blog.csdn.net/20180212224825825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n如果做到这一步没问题，说明：\n1.nodejs与gitbash没有问题。\n2.ionic和cordova没有问题。\n\n## 4.打包 ##\n\n确保SDK,JDK没问题以后，使用指令\n```\n$ ionic cordova build android --release\n```\n (如果这条命令有问题，可以去掉--release然后debug编译，编译完成Dos会显示apk目录位置)\n\n如若你聪慧的双眼发现如下字眼：Build Success!  即可关闭本网页，说明你已经成功打包了。\n\nOK，此时你已经有了debug的包，但是这个包没有签名，不能发布。\n\n此时，我们应该：\n    First：在JDK目录下的bin文件夹下（C:\\Program Files\\Java\\jdk1.8.0_71\\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。\n    \nSecond：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。\n执行完命令1，继续执行命令2即可完成签名打包。\n \n命令1：生成签名密钥\n\n```\n/*\n使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！\n*/\n\n```\n\nkeytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000\n\n\n命令2：给文件签名\n使用刚才生成的zhangqiang.keystore   -signedjar   签名后的apk   签名之前的apk  签名包别  \n\njarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore\n\n![签名完成](http://img.blog.csdn.net/20180212234119134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！\n后续的软件压缩打包可以百度：jarsigner打包\n## 5.疑难杂症 ##\n**5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.**\n\n 出现这个提示，说明配置不正确。\n \n 解决方法：\n  在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下：\n\n```javascript\n\tvar postcssOptions = {  \n\t\tfrom: undefined,  \n\t\tto: path_1.basename(sassConfig.outFile),  \n\t\tmap: autoPrefixerMapOptions  \n\t};  \n\n```\n**5.2 安卓SDK组件缺失/缺少/不匹配**\n报文：\n\n```\nA problem occurred configuring project ':CordovaLib'.\n> You have not accepted the license agreements of the following SDK components:\n  [Android SDK Build-Tools 26.0.2].\n```\n\n原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。\n解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。\n\n**5.3 缺少安卓构建/打包工具**\n报错报文：\n\n```\nUnhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,\nor on your system to install the gradle wrapper. Please include gradle\nin your path, or install Android Studio\n(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\n```\n\n原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。\n解决办法：\n去http://services.gradle.org/distributions/ 下载 gradle-4.1-bin.zip\n配置相应的环境变量：\n\nGRADLE_HOME=E:\\software\\gradle-3.0\nPATH=%PATH%;%GRADLE_HOME%\\bin\n\n测试命令（查看版本）：gradle -v\n\n完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。) \n\n感谢收看。\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/IONIC3 打包安卓apk详细过程（大量图文）.md","raw":"---\ntitle:  IONIC3 打包安卓apk详细过程（大量图文）\ndate:   2018-03-06 23:44:03\ntags: [android,SDK,JDK,APP,IONIC,gradle]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79319408)\n\n\n\n本文写于2018年2月12日 22:25:59。\n\n如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。\n\n经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。\n## 1.基本依赖环境 ##\n\n 1. nodejs环境 (作为一个前端相信你已经有了)![nodejs](http://img.blog.csdn.net/20180212223918473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)最好提前配置好node的环境变量，便于全局访问\n 2. jdk(下面细说)![JDK](http://img.blog.csdn.net/20180212224004766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 3. SDK(下面细说，其实主要难就难在SDK配置了)![SDK](http://img.blog.csdn.net/20180212224101120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 4. gradle(下面细说)![gradle](http://img.blog.csdn.net/20180212224141473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 2. 基本工具 ##\n\n 1. gitbash(就是用来替代windows自带的丑陋的CMD)![gitbash](http://img.blog.csdn.net/20180212224300075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 下载：我都打包了！\n链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m\n 2. windows自带的CMD(`window`+`R`输入CMD，管理员身份运行)![CMD](http://img.blog.csdn.net/20180212224327731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n 3. VSCode(微软爸爸开发的前端IDE)![VSCode](http://img.blog.csdn.net/20180212224349157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n下载：请自行去微软爸爸官网下载。\n\n## 3.环境配置 ##\n**3.1 nodejs (需要配置环境变量)**\n前端必会，跳过。\n**3.2 jdk (无需配置环境变量)**\n下载：已经上传网盘↓\n链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m\n请自行根据系统安装32/64位的版本。\n安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\\Program Files\\Java \nOK，jdk安装完成，在cmd中，输入`$ java -version`验证是否安装成功。\n\n![jdk安装成功](http://img.blog.csdn.net/20180212225402220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\nOK。\n**3.3 sdk (需要配置环境变量)**\n下载：跟上面的一样，我都打包了。\n链接：https://pan.baidu.com/s/1mje7ZHu 密码：ob6m\n\n解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。\n将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\\Program Files\\SDK\n接着配置环境变量，我的电脑------右键属性-------高级系统设置-------环境变量。\n在下面的系统变量(s)中，新建，键值对如下：\nname: ANDROID_HOME\nkey: C:\\Program Files\\SDK\n如图所示：\n\n![SDK环境变量](http://img.blog.csdn.net/20180212230110171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\\bin缀在最后面，前面有【;】分隔符。\n\n然后运行CMD，输入`$ android -h`，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。\n\n![ANDROID环境配置验证](http://img.blog.csdn.net/20180212230459827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n现在，打开SDK目录下的SDK Manager.exe\n打开界面上的Tools,选择options，先配置国内镜像：\n\n域名千万不要输入http或者https协议前缀，谁输谁哭。\n\n![配置镜像](http://img.blog.csdn.net/20180212231404498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n下面记得勾选。\n回到主界面，点packages再点reload\n先勾选如下图的三个Tools:\n分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools]\n![Tools](http://img.blog.csdn.net/20180212230934859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n别急，还没完，下面还有一个：\n[SDK platform]![SDK platform](http://img.blog.csdn.net/20180212231104690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n全部选中后，点右下角 install packages 来安装，耐心等待即可。\n**3.4 gradle安装(需要配置环境变量)**\n打开：http://services.gradle.org/distributions/\n下载：gradle-4.1-bin.zip\n同样安装在JDK,SDK的目录下，便于查找。\n同样的配置环境变量：\nGRADLE_HOME=C:\\Program Files\\SDK\\gradle-4.1\n;%GRADLE_HOME%\\bin\n\n测试命令（查看版本）：gradle -v\n \n## 3.基本流程 ##\n1.安装ionic和cordova \n \n打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）\n```\n$ cnpm install -g ionic cordova\n```\n![安装ionic和cordova ](http://img.blog.csdn.net/20180212224442812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.创建ionic项目\n\n桌面右键，在此处gitbash\n```\n$ ionic start app tabs\n```\n耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后\n\n```\n$ ionic serve\n```\n![ionic serve](http://img.blog.csdn.net/20180212224746544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示：\n\n\n![CHROME预览](http://img.blog.csdn.net/20180212224825825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n如果做到这一步没问题，说明：\n1.nodejs与gitbash没有问题。\n2.ionic和cordova没有问题。\n\n## 4.打包 ##\n\n确保SDK,JDK没问题以后，使用指令\n```\n$ ionic cordova build android --release\n```\n (如果这条命令有问题，可以去掉--release然后debug编译，编译完成Dos会显示apk目录位置)\n\n如若你聪慧的双眼发现如下字眼：Build Success!  即可关闭本网页，说明你已经成功打包了。\n\nOK，此时你已经有了debug的包，但是这个包没有签名，不能发布。\n\n此时，我们应该：\n    First：在JDK目录下的bin文件夹下（C:\\Program Files\\Java\\jdk1.8.0_71\\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。\n    \nSecond：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。\n执行完命令1，继续执行命令2即可完成签名打包。\n \n命令1：生成签名密钥\n\n```\n/*\n使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！\n*/\n\n```\n\nkeytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000\n\n\n命令2：给文件签名\n使用刚才生成的zhangqiang.keystore   -signedjar   签名后的apk   签名之前的apk  签名包别  \n\njarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore\n\n![签名完成](http://img.blog.csdn.net/20180212234119134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！\n后续的软件压缩打包可以百度：jarsigner打包\n## 5.疑难杂症 ##\n**5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.**\n\n 出现这个提示，说明配置不正确。\n \n 解决方法：\n  在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下：\n\n```javascript\n\tvar postcssOptions = {  \n\t\tfrom: undefined,  \n\t\tto: path_1.basename(sassConfig.outFile),  \n\t\tmap: autoPrefixerMapOptions  \n\t};  \n\n```\n**5.2 安卓SDK组件缺失/缺少/不匹配**\n报文：\n\n```\nA problem occurred configuring project ':CordovaLib'.\n> You have not accepted the license agreements of the following SDK components:\n  [Android SDK Build-Tools 26.0.2].\n```\n\n原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。\n解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。\n\n**5.3 缺少安卓构建/打包工具**\n报错报文：\n\n```\nUnhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,\nor on your system to install the gradle wrapper. Please include gradle\nin your path, or install Android Studio\n(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\n```\n\n原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。\n解决办法：\n去http://services.gradle.org/distributions/ 下载 gradle-4.1-bin.zip\n配置相应的环境变量：\n\nGRADLE_HOME=E:\\software\\gradle-3.0\nPATH=%PATH%;%GRADLE_HOME%\\bin\n\n测试命令（查看版本）：gradle -v\n\n完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。) \n\n感谢收看。\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"IONIC3 打包安卓apk详细过程（大量图文）","published":1,"updated":"2018-08-29T06:00:50.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdff000ljgv4pdvsk8tr","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79319408\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>本文写于2018年2月12日 22:25:59。</p>\n<p>如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。</p>\n<p>经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。</p>\n<h2 id=\"1-基本依赖环境\"><a href=\"#1-基本依赖环境\" class=\"headerlink\" title=\"1.基本依赖环境\"></a>1.基本依赖环境</h2><ol>\n<li>nodejs环境 (作为一个前端相信你已经有了)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212223918473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"nodejs\" title=\"\" class=\"\">\n                <p>nodejs</p>\n            </figure>最好提前配置好node的环境变量，便于全局访问</li>\n<li>jdk(下面细说)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224004766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"JDK\" title=\"\" class=\"\">\n                <p>JDK</p>\n            </figure></li>\n<li>SDK(下面细说，其实主要难就难在SDK配置了)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224101120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"SDK\" title=\"\" class=\"\">\n                <p>SDK</p>\n            </figure></li>\n<li>gradle(下面细说)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224141473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"gradle\" title=\"\" class=\"\">\n                <p>gradle</p>\n            </figure></li>\n</ol>\n<h2 id=\"2-基本工具\"><a href=\"#2-基本工具\" class=\"headerlink\" title=\"2. 基本工具\"></a>2. 基本工具</h2><ol>\n<li>gitbash(就是用来替代windows自带的丑陋的CMD)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224300075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"gitbash\" title=\"\" class=\"\">\n                <p>gitbash</p>\n            </figure><br>下载：我都打包了！<br>链接：<a href=\"https://pan.baidu.com/s/1mje7ZHu\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</li>\n<li>windows自带的CMD(<code>window</code>+<code>R</code>输入CMD，管理员身份运行)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224327731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"CMD\" title=\"\" class=\"\">\n                <p>CMD</p>\n            </figure></li>\n<li>VSCode(微软爸爸开发的前端IDE)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224349157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"VSCode\" title=\"\" class=\"\">\n                <p>VSCode</p>\n            </figure><br>下载：请自行去微软爸爸官网下载。</li>\n</ol>\n<h2 id=\"3-环境配置\"><a href=\"#3-环境配置\" class=\"headerlink\" title=\"3.环境配置\"></a>3.环境配置</h2><p><strong>3.1 nodejs (需要配置环境变量)</strong><br>前端必会，跳过。<br><strong>3.2 jdk (无需配置环境变量)</strong><br>下载：已经上传网盘↓<br>链接：<a href=\"https://pan.baidu.com/s/1mje7ZHu\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m<br>请自行根据系统安装32/64位的版本。<br>安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\\Program Files\\Java<br>OK，jdk安装完成，在cmd中，输入<code>$ java -version</code>验证是否安装成功。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212225402220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"jdk安装成功\" title=\"\" class=\"\">\n                <p>jdk安装成功</p>\n            </figure>\n<p>OK。<br><strong>3.3 sdk (需要配置环境变量)</strong><br>下载：跟上面的一样，我都打包了。<br>链接：<a href=\"https://pan.baidu.com/s/1mje7ZHu\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</p>\n<p>解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。<br>将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\\Program Files\\SDK<br>接着配置环境变量，我的电脑——右键属性——-高级系统设置——-环境变量。<br>在下面的系统变量(s)中，新建，键值对如下：<br>name: ANDROID_HOME<br>key: C:\\Program Files\\SDK<br>如图所示：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212230110171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"SDK环境变量\" title=\"\" class=\"\">\n                <p>SDK环境变量</p>\n            </figure>\n<p>然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\\bin缀在最后面，前面有【;】分隔符。</p>\n<p>然后运行CMD，输入<code>$ android -h</code>，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212230459827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"ANDROID环境配置验证\" title=\"\" class=\"\">\n                <p>ANDROID环境配置验证</p>\n            </figure>\n<p>现在，打开SDK目录下的SDK Manager.exe<br>打开界面上的Tools,选择options，先配置国内镜像：</p>\n<p>域名千万不要输入http或者https协议前缀，谁输谁哭。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212231404498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"配置镜像\" title=\"\" class=\"\">\n                <p>配置镜像</p>\n            </figure>\n<p>下面记得勾选。<br>回到主界面，点packages再点reload<br>先勾选如下图的三个Tools:<br>分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools]<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212230934859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Tools\" title=\"\" class=\"\">\n                <p>Tools</p>\n            </figure></p>\n<p>别急，还没完，下面还有一个：<br>[SDK platform]<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212231104690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"SDK platform\" title=\"\" class=\"\">\n                <p>SDK platform</p>\n            </figure></p>\n<p>全部选中后，点右下角 install packages 来安装，耐心等待即可。<br><strong>3.4 gradle安装(需要配置环境变量)</strong><br>打开：<a href=\"http://services.gradle.org/distributions/\" target=\"_blank\" rel=\"noopener\">http://services.gradle.org/distributions/</a><br>下载：gradle-4.1-bin.zip<br>同样安装在JDK,SDK的目录下，便于查找。<br>同样的配置环境变量：<br>GRADLE_HOME=C:\\Program Files\\SDK\\gradle-4.1<br>;%GRADLE_HOME%\\bin</p>\n<p>测试命令（查看版本）：gradle -v</p>\n<h2 id=\"3-基本流程\"><a href=\"#3-基本流程\" class=\"headerlink\" title=\"3.基本流程\"></a>3.基本流程</h2><p>1.安装ionic和cordova </p>\n<p>打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g ionic cordova</span><br></pre></td></tr></table></figure></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224442812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"安装ionic和cordova\" title=\"\" class=\"\">\n                <p>安装ionic和cordova</p>\n            </figure>\n<p>2.创建ionic项目</p>\n<p>桌面右键，在此处gitbash<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ionic start app tabs</span><br></pre></td></tr></table></figure></p>\n<p>耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ionic serve</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224746544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"ionic serve\" title=\"\" class=\"\">\n                <p>ionic serve</p>\n            </figure>\n<p>稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20180212224825825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"CHROME预览\"></p>\n<p>如果做到这一步没问题，说明：<br>1.nodejs与gitbash没有问题。<br>2.ionic和cordova没有问题。</p>\n<h2 id=\"4-打包\"><a href=\"#4-打包\" class=\"headerlink\" title=\"4.打包\"></a>4.打包</h2><p>确保SDK,JDK没问题以后，使用指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ionic cordova build android --release</span><br></pre></td></tr></table></figure></p>\n<p> (如果这条命令有问题，可以去掉–release然后debug编译，编译完成Dos会显示apk目录位置)</p>\n<p>如若你聪慧的双眼发现如下字眼：Build Success!  即可关闭本网页，说明你已经成功打包了。</p>\n<p>OK，此时你已经有了debug的包，但是这个包没有签名，不能发布。</p>\n<p>此时，我们应该：<br>    First：在JDK目录下的bin文件夹下（C:\\Program Files\\Java\\jdk1.8.0_71\\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。</p>\n<p>Second：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。<br>执行完命令1，继续执行命令2即可完成签名打包。</p>\n<p>命令1：生成签名密钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>keytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000</p>\n<p>命令2：给文件签名<br>使用刚才生成的zhangqiang.keystore   -signedjar   签名后的apk   签名之前的apk  签名包别  </p>\n<p>jarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212234119134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"签名完成\" title=\"\" class=\"\">\n                <p>签名完成</p>\n            </figure>\n<p>如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！<br>后续的软件压缩打包可以百度：jarsigner打包</p>\n<h2 id=\"5-疑难杂症\"><a href=\"#5-疑难杂症\" class=\"headerlink\" title=\"5.疑难杂症\"></a>5.疑难杂症</h2><p><strong>5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to <code>undefined</code> to prevent this warning.</strong></p>\n<p> 出现这个提示，说明配置不正确。</p>\n<p> 解决方法：<br>  在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> postcssOptions = &#123;  </span><br><span class=\"line\">\t<span class=\"keyword\">from</span>: <span class=\"literal\">undefined</span>,  </span><br><span class=\"line\">\tto: path_1.basename(sassConfig.outFile),  </span><br><span class=\"line\">\tmap: autoPrefixerMapOptions  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>5.2 安卓SDK组件缺失/缺少/不匹配</strong><br>报文：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A problem occurred configuring project &apos;:CordovaLib&apos;.</span><br><span class=\"line\">&gt; You have not accepted the license agreements of the following SDK components:</span><br><span class=\"line\">  [Android SDK Build-Tools 26.0.2].</span><br></pre></td></tr></table></figure>\n<p>原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。<br>解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。</p>\n<p><strong>5.3 缺少安卓构建/打包工具</strong><br>报错报文：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,</span><br><span class=\"line\">or on your system to install the gradle wrapper. Please include gradle</span><br><span class=\"line\">in your path, or install Android Studio</span><br><span class=\"line\">(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure>\n<p>原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。<br>解决办法：<br>去<a href=\"http://services.gradle.org/distributions/\" target=\"_blank\" rel=\"noopener\">http://services.gradle.org/distributions/</a> 下载 gradle-4.1-bin.zip<br>配置相应的环境变量：</p>\n<p>GRADLE_HOME=E:\\software\\gradle-3.0<br>PATH=%PATH%;%GRADLE_HOME%\\bin</p>\n<p>测试命令（查看版本）：gradle -v</p>\n<p>完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。) </p>\n<p>感谢收看。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79319408\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>本文写于2018年2月12日 22:25:59。</p>\n<p>如果2018年的新春之际，你遇到IONIC的开发问题，这将是一篇最为详尽的打包方案。</p>\n<p>经历三天的踩坑，跳坑，相信绝大多数的问题都已经覆盖到了，请仔细按照流程来对照操作及检查。</p>\n<h2 id=\"1-基本依赖环境\"><a href=\"#1-基本依赖环境\" class=\"headerlink\" title=\"1.基本依赖环境\"></a>1.基本依赖环境</h2><ol>\n<li>nodejs环境 (作为一个前端相信你已经有了)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212223918473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"nodejs\" title=\"\" class=\"\">\n                <p>nodejs</p>\n            </figure>最好提前配置好node的环境变量，便于全局访问</li>\n<li>jdk(下面细说)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224004766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"JDK\" title=\"\" class=\"\">\n                <p>JDK</p>\n            </figure></li>\n<li>SDK(下面细说，其实主要难就难在SDK配置了)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224101120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"SDK\" title=\"\" class=\"\">\n                <p>SDK</p>\n            </figure></li>\n<li>gradle(下面细说)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224141473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"gradle\" title=\"\" class=\"\">\n                <p>gradle</p>\n            </figure></li>\n</ol>\n<h2 id=\"2-基本工具\"><a href=\"#2-基本工具\" class=\"headerlink\" title=\"2. 基本工具\"></a>2. 基本工具</h2><ol>\n<li>gitbash(就是用来替代windows自带的丑陋的CMD)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224300075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"gitbash\" title=\"\" class=\"\">\n                <p>gitbash</p>\n            </figure><br>下载：我都打包了！<br>链接：<a href=\"https://pan.baidu.com/s/1mje7ZHu\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</li>\n<li>windows自带的CMD(<code>window</code>+<code>R</code>输入CMD，管理员身份运行)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224327731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"CMD\" title=\"\" class=\"\">\n                <p>CMD</p>\n            </figure></li>\n<li>VSCode(微软爸爸开发的前端IDE)<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224349157?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"VSCode\" title=\"\" class=\"\">\n                <p>VSCode</p>\n            </figure><br>下载：请自行去微软爸爸官网下载。</li>\n</ol>\n<h2 id=\"3-环境配置\"><a href=\"#3-环境配置\" class=\"headerlink\" title=\"3.环境配置\"></a>3.环境配置</h2><p><strong>3.1 nodejs (需要配置环境变量)</strong><br>前端必会，跳过。<br><strong>3.2 jdk (无需配置环境变量)</strong><br>下载：已经上传网盘↓<br>链接：<a href=\"https://pan.baidu.com/s/1mje7ZHu\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m<br>请自行根据系统安装32/64位的版本。<br>安装方法：下载完成，解压，直接按照提示安装，全局点确定，不出意外，最后的安装路径为：C:\\Program Files\\Java<br>OK，jdk安装完成，在cmd中，输入<code>$ java -version</code>验证是否安装成功。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212225402220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"jdk安装成功\" title=\"\" class=\"\">\n                <p>jdk安装成功</p>\n            </figure>\n<p>OK。<br><strong>3.3 sdk (需要配置环境变量)</strong><br>下载：跟上面的一样，我都打包了。<br>链接：<a href=\"https://pan.baidu.com/s/1mje7ZHu\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mje7ZHu</a> 密码：ob6m</p>\n<p>解压后（直接右键X解压并重命名。因为面还有个文件夹，不建议用右键+E解压）。<br>将重命名的文件夹，跟jdk放在一个父目录，便于查找：C:\\Program Files\\SDK<br>接着配置环境变量，我的电脑——右键属性——-高级系统设置——-环境变量。<br>在下面的系统变量(s)中，新建，键值对如下：<br>name: ANDROID_HOME<br>key: C:\\Program Files\\SDK<br>如图所示：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212230110171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"SDK环境变量\" title=\"\" class=\"\">\n                <p>SDK环境变量</p>\n            </figure>\n<p>然后在path中，全局声明一下，将;%PATH%;%GRADLE_HOME%\\bin缀在最后面，前面有【;】分隔符。</p>\n<p>然后运行CMD，输入<code>$ android -h</code>，如果出现一大堆指令，说明你的SDK安装无误，并且环境变量配置OK。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212230459827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"ANDROID环境配置验证\" title=\"\" class=\"\">\n                <p>ANDROID环境配置验证</p>\n            </figure>\n<p>现在，打开SDK目录下的SDK Manager.exe<br>打开界面上的Tools,选择options，先配置国内镜像：</p>\n<p>域名千万不要输入http或者https协议前缀，谁输谁哭。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212231404498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"配置镜像\" title=\"\" class=\"\">\n                <p>配置镜像</p>\n            </figure>\n<p>下面记得勾选。<br>回到主界面，点packages再点reload<br>先勾选如下图的三个Tools:<br>分别是[ Android SDK Tools,Android SDK platform-tools,Android SDK Build-tools]<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212230934859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Tools\" title=\"\" class=\"\">\n                <p>Tools</p>\n            </figure></p>\n<p>别急，还没完，下面还有一个：<br>[SDK platform]<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212231104690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"SDK platform\" title=\"\" class=\"\">\n                <p>SDK platform</p>\n            </figure></p>\n<p>全部选中后，点右下角 install packages 来安装，耐心等待即可。<br><strong>3.4 gradle安装(需要配置环境变量)</strong><br>打开：<a href=\"http://services.gradle.org/distributions/\" target=\"_blank\" rel=\"noopener\">http://services.gradle.org/distributions/</a><br>下载：gradle-4.1-bin.zip<br>同样安装在JDK,SDK的目录下，便于查找。<br>同样的配置环境变量：<br>GRADLE_HOME=C:\\Program Files\\SDK\\gradle-4.1<br>;%GRADLE_HOME%\\bin</p>\n<p>测试命令（查看版本）：gradle -v</p>\n<h2 id=\"3-基本流程\"><a href=\"#3-基本流程\" class=\"headerlink\" title=\"3.基本流程\"></a>3.基本流程</h2><p>1.安装ionic和cordova </p>\n<p>打开Gitbash,全局安装ionic和cordova（IONIC是UI，cordova负责打包成apk,并且可以调用原生安卓的各种API）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g ionic cordova</span><br></pre></td></tr></table></figure></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224442812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"安装ionic和cordova\" title=\"\" class=\"\">\n                <p>安装ionic和cordova</p>\n            </figure>\n<p>2.创建ionic项目</p>\n<p>桌面右键，在此处gitbash<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ionic start app tabs</span><br></pre></td></tr></table></figure></p>\n<p>耐心等待完成，在 cd 到 app 子目录(app是你的真实项目目录)，然后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ionic serve</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212224746544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"ionic serve\" title=\"\" class=\"\">\n                <p>ionic serve</p>\n            </figure>\n<p>稍等片刻，浏览器自动弹出预览界面(建议电脑安装Chrome浏览器)，并且支持持续热更新(Webpack的功能)，如下图所示：</p>\n<p><img src=\"http://img.blog.csdn.net/20180212224825825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"CHROME预览\"></p>\n<p>如果做到这一步没问题，说明：<br>1.nodejs与gitbash没有问题。<br>2.ionic和cordova没有问题。</p>\n<h2 id=\"4-打包\"><a href=\"#4-打包\" class=\"headerlink\" title=\"4.打包\"></a>4.打包</h2><p>确保SDK,JDK没问题以后，使用指令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ionic cordova build android --release</span><br></pre></td></tr></table></figure></p>\n<p> (如果这条命令有问题，可以去掉–release然后debug编译，编译完成Dos会显示apk目录位置)</p>\n<p>如若你聪慧的双眼发现如下字眼：Build Success!  即可关闭本网页，说明你已经成功打包了。</p>\n<p>OK，此时你已经有了debug的包，但是这个包没有签名，不能发布。</p>\n<p>此时，我们应该：<br>    First：在JDK目录下的bin文件夹下（C:\\Program Files\\Java\\jdk1.8.0_71\\bin），先看看有没有keytool.exe和jarsigner.exe文件，这两个程序用于给APK签名，签名以后即可发布。</p>\n<p>Second：将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。<br>执行完命令1，继续执行命令2即可完成签名打包。</p>\n<p>命令1：生成签名密钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">使用工具, 签名,-genkey表示构建签名文件，-v 显示在dos窗口中 -alias表示签名包的别名 -validity 签名有效期(天)，姓名:zhangqiang 城市:lz + lz 国家: cn 口令敲的时候不动，是因为保护隐私，别当做你电脑死机！</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>keytool -genkey -v -keystore zhangqiang.keystore -alias zhangqiang.keystore -keyalg RSA -validity 20000</p>\n<p>命令2：给文件签名<br>使用刚才生成的zhangqiang.keystore   -signedjar   签名后的apk   签名之前的apk  签名包别  </p>\n<p>jarsigner -verbose -keystore zhangqiang.keystore -signedjar complete.apk app.apk zhangqiang.keystore</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180212234119134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"签名完成\" title=\"\" class=\"\">\n                <p>签名完成</p>\n            </figure>\n<p>如上图所示，IONIC打包的文件为app.apk,签名后的文件为complete.apk，这时候，可以说，一个软件就诞生啦！<br>后续的软件压缩打包可以百度：jarsigner打包</p>\n<h2 id=\"5-疑难杂症\"><a href=\"#5-疑难杂症\" class=\"headerlink\" title=\"5.疑难杂症\"></a>5.疑难杂症</h2><p><strong>5.1 Without ·from· option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to <code>undefined</code> to prevent this warning.</strong></p>\n<p> 出现这个提示，说明配置不正确。</p>\n<p> 解决方法：<br>  在“/node_modules/@ionic/app-scripts/dist/sass.js”路径的“sass.js”文件，在postcssOptions参数中添加“from: undefined”。添加后效果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> postcssOptions = &#123;  </span><br><span class=\"line\">\t<span class=\"keyword\">from</span>: <span class=\"literal\">undefined</span>,  </span><br><span class=\"line\">\tto: path_1.basename(sassConfig.outFile),  </span><br><span class=\"line\">\tmap: autoPrefixerMapOptions  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>5.2 安卓SDK组件缺失/缺少/不匹配</strong><br>报文：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A problem occurred configuring project &apos;:CordovaLib&apos;.</span><br><span class=\"line\">&gt; You have not accepted the license agreements of the following SDK components:</span><br><span class=\"line\">  [Android SDK Build-Tools 26.0.2].</span><br></pre></td></tr></table></figure>\n<p>原因:SDK构建工具和platform工具不匹配，或者有东西遗漏了，没下载。<br>解决：如果中途报错SDK出问题，请打开C盘/profiles/SDK/manager.exe，使用东软的镜像，根绝报错信息，来down对应的platform或者build包。</p>\n<p><strong>5.3 缺少安卓构建/打包工具</strong><br>报错报文：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unhandled promise rejection (rejection id: 1): CordovaError: Could not find an installed version of Gradle either in Android Studio,</span><br><span class=\"line\">or on your system to install the gradle wrapper. Please include gradle</span><br><span class=\"line\">in your path, or install Android Studio</span><br><span class=\"line\">(node:3444) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure>\n<p>原因：缺少安卓构建打包工具，报文提示你可以用Android Studio，也可以安装一个Gradle。<br>解决办法：<br>去<a href=\"http://services.gradle.org/distributions/\" target=\"_blank\" rel=\"noopener\">http://services.gradle.org/distributions/</a> 下载 gradle-4.1-bin.zip<br>配置相应的环境变量：</p>\n<p>GRADLE_HOME=E:\\software\\gradle-3.0<br>PATH=%PATH%;%GRADLE_HOME%\\bin</p>\n<p>测试命令（查看版本）：gradle -v</p>\n<p>完成上述任务后，重新运行Gitbash,然后 $ ionic cordova build android ,发现build成功，会自动下载gradle-4.1-bin.zip (初步猜测是因为自己的gradle路径不对，可能没有被项目依赖，但是项目在全局空间中发现gradle环境，因此自己要下载gradle来依赖。) </p>\n<p>感谢收看。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"JavaScript开心消消乐中的迭代算法","date":"2017-10-22T05:35:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78309575)\n\n这两天玩开心消消乐，突然想琢磨一下每次这些小方块的生成算法。\n**不考虑4个相同颜色的情况**，理了一下初步的思路，大致如下：\n\n\n【一、游戏的初始化】\n1.首先有六种颜色：红、黄、蓝、绿、棕、紫。那么在一个4*4的矩阵里，要让这六种颜色分布于其中。\n2.初始化的颜色随机生成，并且每行、每列不能三个相同的颜色相连。\n3.为了能够进一步的游戏，必须在4*4的的矩阵中产生两个相连的颜色，并且在前者的左上、右上、左下、右下产生一个相同的颜色，否则整个游戏无法玩。\n\n\n【二、游戏的模拟点击操作】\n1.当点击第一个色块，再点击第二个色块，那么，交换这两个色块的颜色。\n2.如果这两个色块交换之后，并没有产生3个相同颜色相连，那么这种情况就应该保持两个点击色块的原本颜色。\n\n\n【三、色块消除以后的后续生成*(难点)】\n1.当三个色块消除后，上面的元素坍塌掉落。并用新的颜色填充坍塌元素的位置，并且还得遵循【一】中的生成原则。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/JavaScript开心消消乐中的迭代算法.md","raw":"---\ntitle: JavaScript开心消消乐中的迭代算法 \ndate: 2017-10-22 13:35:00\ntags: 算法\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78309575)\n\n这两天玩开心消消乐，突然想琢磨一下每次这些小方块的生成算法。\n**不考虑4个相同颜色的情况**，理了一下初步的思路，大致如下：\n\n\n【一、游戏的初始化】\n1.首先有六种颜色：红、黄、蓝、绿、棕、紫。那么在一个4*4的矩阵里，要让这六种颜色分布于其中。\n2.初始化的颜色随机生成，并且每行、每列不能三个相同的颜色相连。\n3.为了能够进一步的游戏，必须在4*4的的矩阵中产生两个相连的颜色，并且在前者的左上、右上、左下、右下产生一个相同的颜色，否则整个游戏无法玩。\n\n\n【二、游戏的模拟点击操作】\n1.当点击第一个色块，再点击第二个色块，那么，交换这两个色块的颜色。\n2.如果这两个色块交换之后，并没有产生3个相同颜色相连，那么这种情况就应该保持两个点击色块的原本颜色。\n\n\n【三、色块消除以后的后续生成*(难点)】\n1.当三个色块消除后，上面的元素坍塌掉落。并用新的颜色填充坍塌元素的位置，并且还得遵循【一】中的生成原则。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"JavaScript开心消消乐中的迭代算法","published":1,"updated":"2018-08-29T06:01:09.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfi000njgv4k1jaukww","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78309575\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>这两天玩开心消消乐，突然想琢磨一下每次这些小方块的生成算法。<br><strong>不考虑4个相同颜色的情况</strong>，理了一下初步的思路，大致如下：</p>\n<p>【一、游戏的初始化】<br>1.首先有六种颜色：红、黄、蓝、绿、棕、紫。那么在一个4<em>4的矩阵里，要让这六种颜色分布于其中。<br>2.初始化的颜色随机生成，并且每行、每列不能三个相同的颜色相连。<br>3.为了能够进一步的游戏，必须在4</em>4的的矩阵中产生两个相连的颜色，并且在前者的左上、右上、左下、右下产生一个相同的颜色，否则整个游戏无法玩。</p>\n<p>【二、游戏的模拟点击操作】<br>1.当点击第一个色块，再点击第二个色块，那么，交换这两个色块的颜色。<br>2.如果这两个色块交换之后，并没有产生3个相同颜色相连，那么这种情况就应该保持两个点击色块的原本颜色。</p>\n<p>【三、色块消除以后的后续生成*(难点)】<br>1.当三个色块消除后，上面的元素坍塌掉落。并用新的颜色填充坍塌元素的位置，并且还得遵循【一】中的生成原则。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78309575\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>这两天玩开心消消乐，突然想琢磨一下每次这些小方块的生成算法。<br><strong>不考虑4个相同颜色的情况</strong>，理了一下初步的思路，大致如下：</p>\n<p>【一、游戏的初始化】<br>1.首先有六种颜色：红、黄、蓝、绿、棕、紫。那么在一个4<em>4的矩阵里，要让这六种颜色分布于其中。<br>2.初始化的颜色随机生成，并且每行、每列不能三个相同的颜色相连。<br>3.为了能够进一步的游戏，必须在4</em>4的的矩阵中产生两个相连的颜色，并且在前者的左上、右上、左下、右下产生一个相同的颜色，否则整个游戏无法玩。</p>\n<p>【二、游戏的模拟点击操作】<br>1.当点击第一个色块，再点击第二个色块，那么，交换这两个色块的颜色。<br>2.如果这两个色块交换之后，并没有产生3个相同颜色相连，那么这种情况就应该保持两个点击色块的原本颜色。</p>\n<p>【三、色块消除以后的后续生成*(难点)】<br>1.当三个色块消除后，上面的元素坍塌掉落。并用新的颜色填充坍塌元素的位置，并且还得遵循【一】中的生成原则。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"NodeBB搭建过程（windows+Redis）+ 科学上网方法","date":"2018-06-22T02:04:36.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/80769624)\n\n\n\n\n1.首先去 github 把项目 clone 下来：\n--------------------------\n\n\nhttps://github.com/NodeBB/NodeBB\n\n然后cd到nodebb，安装依赖 cnpm i\n\n依赖在安装的时候，由于没有 package.json ，会自动 clone ，整个以来安装完成后，应该是这样：\n![install](https://img-blog.csdn.net/20180622095626833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n2.环境配置\n------\n\n附上中文文档：https://docs.nodebb-cn.org/\n\n\n1.Chocolatey 可以下载**离线包**，之后通过 Chocolatey 安装一些环境：\n\n```\nchoco install -y imagemagick github python2 nodejs-lts git\n```\n这里的 github , nodejs ，git 可以选择不安装，跳过。\n2.数据库（database）选择 Redis \nRedis 可以在菜鸟教程上面找到安装教程：\nhttp://www.runoob.com/redis/redis-install.html\n\n安装完成以后，WINDOWS + R 打开 services.msc ，找到 Redis 服务，启动之：\n![Redis](https://img-blog.csdn.net/20180622095820272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n3.Hello World Running\n---------------------\n\n首先，使用命令 ./nodebb build 构建静态资源，构建完如下：\n![helloworld](https://img-blog.csdn.net/2018062210001911?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n此时打开监听的 127.0.0.1:4567 (默认配置的端口)，如图所示：\n![installer](https://img-blog.csdn.net/20180622100114522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n上面的直接填写，下面的数据库配置如下：\n![database](https://img-blog.csdn.net/20180622100206278?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n点击最下面的 install NodeBB 后，整个项目总算 Running 了：\n![running](https://img-blog.csdn.net/20180622100409227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n4 . use LANTERN to cross wall (使用lantern 科学上网)\n-------\n\n下载lantern安装包 => 一路next安装，并启动 => 右下角图标右键 ，连接 => OK\n依赖环境 .net FrameWork 4.0 +\n我都打包好了 :\n链接：https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow 密码：yyfg\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/NodeBB搭建过程（windows+Redis）+ 科学上网方法.md","raw":"---\ntitle:  NodeBB搭建过程（windows+Redis）+ 科学上网方法 \ndate: 2018-06-22 10:04:36\ntags: [node,javascript]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/80769624)\n\n\n\n\n1.首先去 github 把项目 clone 下来：\n--------------------------\n\n\nhttps://github.com/NodeBB/NodeBB\n\n然后cd到nodebb，安装依赖 cnpm i\n\n依赖在安装的时候，由于没有 package.json ，会自动 clone ，整个以来安装完成后，应该是这样：\n![install](https://img-blog.csdn.net/20180622095626833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n2.环境配置\n------\n\n附上中文文档：https://docs.nodebb-cn.org/\n\n\n1.Chocolatey 可以下载**离线包**，之后通过 Chocolatey 安装一些环境：\n\n```\nchoco install -y imagemagick github python2 nodejs-lts git\n```\n这里的 github , nodejs ，git 可以选择不安装，跳过。\n2.数据库（database）选择 Redis \nRedis 可以在菜鸟教程上面找到安装教程：\nhttp://www.runoob.com/redis/redis-install.html\n\n安装完成以后，WINDOWS + R 打开 services.msc ，找到 Redis 服务，启动之：\n![Redis](https://img-blog.csdn.net/20180622095820272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n3.Hello World Running\n---------------------\n\n首先，使用命令 ./nodebb build 构建静态资源，构建完如下：\n![helloworld](https://img-blog.csdn.net/2018062210001911?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n此时打开监听的 127.0.0.1:4567 (默认配置的端口)，如图所示：\n![installer](https://img-blog.csdn.net/20180622100114522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n上面的直接填写，下面的数据库配置如下：\n![database](https://img-blog.csdn.net/20180622100206278?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n点击最下面的 install NodeBB 后，整个项目总算 Running 了：\n![running](https://img-blog.csdn.net/20180622100409227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n4 . use LANTERN to cross wall (使用lantern 科学上网)\n-------\n\n下载lantern安装包 => 一路next安装，并启动 => 右下角图标右键 ，连接 => OK\n依赖环境 .net FrameWork 4.0 +\n我都打包好了 :\n链接：https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow 密码：yyfg\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"NodeBB搭建过程（windows+Redis）+ 科学上网方法","published":1,"updated":"2018-08-29T05:59:20.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfk000pjgv4mkqxnrgs","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/80769624\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"1-首先去-github-把项目-clone-下来：\"><a href=\"#1-首先去-github-把项目-clone-下来：\" class=\"headerlink\" title=\"1.首先去 github 把项目 clone 下来：\"></a>1.首先去 github 把项目 clone 下来：</h2><p><a href=\"https://github.com/NodeBB/NodeBB\" target=\"_blank\" rel=\"noopener\">https://github.com/NodeBB/NodeBB</a></p>\n<p>然后cd到nodebb，安装依赖 cnpm i</p>\n<p>依赖在安装的时候，由于没有 package.json ，会自动 clone ，整个以来安装完成后，应该是这样：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622095626833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"install\" title=\"\" class=\"\">\n                <p>install</p>\n            </figure></p>\n<h2 id=\"2-环境配置\"><a href=\"#2-环境配置\" class=\"headerlink\" title=\"2.环境配置\"></a>2.环境配置</h2><p>附上中文文档：<a href=\"https://docs.nodebb-cn.org/\" target=\"_blank\" rel=\"noopener\">https://docs.nodebb-cn.org/</a></p>\n<p>1.Chocolatey 可以下载<strong>离线包</strong>，之后通过 Chocolatey 安装一些环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">choco install -y imagemagick github python2 nodejs-lts git</span><br></pre></td></tr></table></figure>\n<p>这里的 github , nodejs ，git 可以选择不安装，跳过。<br>2.数据库（database）选择 Redis<br>Redis 可以在菜鸟教程上面找到安装教程：<br><a href=\"http://www.runoob.com/redis/redis-install.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/redis/redis-install.html</a></p>\n<p>安装完成以后，WINDOWS + R 打开 services.msc ，找到 Redis 服务，启动之：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622095820272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"Redis\" title=\"\" class=\"\">\n                <p>Redis</p>\n            </figure></p>\n<h2 id=\"3-Hello-World-Running\"><a href=\"#3-Hello-World-Running\" class=\"headerlink\" title=\"3.Hello World Running\"></a>3.Hello World Running</h2><p>首先，使用命令 ./nodebb build 构建静态资源，构建完如下：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/2018062210001911?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"helloworld\" title=\"\" class=\"\">\n                <p>helloworld</p>\n            </figure></p>\n<p>此时打开监听的 127.0.0.1:4567 (默认配置的端口)，如图所示：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622100114522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"installer\" title=\"\" class=\"\">\n                <p>installer</p>\n            </figure></p>\n<p>上面的直接填写，下面的数据库配置如下：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622100206278?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"database\" title=\"\" class=\"\">\n                <p>database</p>\n            </figure><br>点击最下面的 install NodeBB 后，整个项目总算 Running 了：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622100409227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"running\" title=\"\" class=\"\">\n                <p>running</p>\n            </figure></p>\n<h2 id=\"4-use-LANTERN-to-cross-wall-使用lantern-科学上网\"><a href=\"#4-use-LANTERN-to-cross-wall-使用lantern-科学上网\" class=\"headerlink\" title=\"4 . use LANTERN to cross wall (使用lantern 科学上网)\"></a>4 . use LANTERN to cross wall (使用lantern 科学上网)</h2><p>下载lantern安装包 =&gt; 一路next安装，并启动 =&gt; 右下角图标右键 ，连接 =&gt; OK<br>依赖环境 .net FrameWork 4.0 +<br>我都打包好了 :<br>链接：<a href=\"https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow</a> 密码：yyfg</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/80769624\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"1-首先去-github-把项目-clone-下来：\"><a href=\"#1-首先去-github-把项目-clone-下来：\" class=\"headerlink\" title=\"1.首先去 github 把项目 clone 下来：\"></a>1.首先去 github 把项目 clone 下来：</h2><p><a href=\"https://github.com/NodeBB/NodeBB\" target=\"_blank\" rel=\"noopener\">https://github.com/NodeBB/NodeBB</a></p>\n<p>然后cd到nodebb，安装依赖 cnpm i</p>\n<p>依赖在安装的时候，由于没有 package.json ，会自动 clone ，整个以来安装完成后，应该是这样：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622095626833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"install\" title=\"\" class=\"\">\n                <p>install</p>\n            </figure></p>\n<h2 id=\"2-环境配置\"><a href=\"#2-环境配置\" class=\"headerlink\" title=\"2.环境配置\"></a>2.环境配置</h2><p>附上中文文档：<a href=\"https://docs.nodebb-cn.org/\" target=\"_blank\" rel=\"noopener\">https://docs.nodebb-cn.org/</a></p>\n<p>1.Chocolatey 可以下载<strong>离线包</strong>，之后通过 Chocolatey 安装一些环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">choco install -y imagemagick github python2 nodejs-lts git</span><br></pre></td></tr></table></figure>\n<p>这里的 github , nodejs ，git 可以选择不安装，跳过。<br>2.数据库（database）选择 Redis<br>Redis 可以在菜鸟教程上面找到安装教程：<br><a href=\"http://www.runoob.com/redis/redis-install.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/redis/redis-install.html</a></p>\n<p>安装完成以后，WINDOWS + R 打开 services.msc ，找到 Redis 服务，启动之：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622095820272?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"Redis\" title=\"\" class=\"\">\n                <p>Redis</p>\n            </figure></p>\n<h2 id=\"3-Hello-World-Running\"><a href=\"#3-Hello-World-Running\" class=\"headerlink\" title=\"3.Hello World Running\"></a>3.Hello World Running</h2><p>首先，使用命令 ./nodebb build 构建静态资源，构建完如下：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/2018062210001911?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"helloworld\" title=\"\" class=\"\">\n                <p>helloworld</p>\n            </figure></p>\n<p>此时打开监听的 127.0.0.1:4567 (默认配置的端口)，如图所示：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622100114522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"installer\" title=\"\" class=\"\">\n                <p>installer</p>\n            </figure></p>\n<p>上面的直接填写，下面的数据库配置如下：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622100206278?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"database\" title=\"\" class=\"\">\n                <p>database</p>\n            </figure><br>点击最下面的 install NodeBB 后，整个项目总算 Running 了：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180622100409227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"running\" title=\"\" class=\"\">\n                <p>running</p>\n            </figure></p>\n<h2 id=\"4-use-LANTERN-to-cross-wall-使用lantern-科学上网\"><a href=\"#4-use-LANTERN-to-cross-wall-使用lantern-科学上网\" class=\"headerlink\" title=\"4 . use LANTERN to cross wall (使用lantern 科学上网)\"></a>4 . use LANTERN to cross wall (使用lantern 科学上网)</h2><p>下载lantern安装包 =&gt; 一路next安装，并启动 =&gt; 右下角图标右键 ，连接 =&gt; OK<br>依赖环境 .net FrameWork 4.0 +<br>我都打包好了 :<br>链接：<a href=\"https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1-aMsEznQ76Tjd5vrfEwrow</a> 密码：yyfg</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"NodeJs基础配置、核心概念与学习路线回顾","date":"2017-12-12T14:07:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78786161)\n\nNodejs把前端开发带入一个全新的阶段，他使得js能够跑在服务端上，大大强化了js这门语言的可塑性。\nOK，环境配置不提，配置好了以后，直接来跑一些简单的demo\n\n以前一直没搞懂nodejs复杂的目录（其实是不懂linux），老把文件目录和运行时的目录搞错。\n\n在gitbash下，先进入对应的目录，例如我的js文件在 D:\\node\\nodejs下，那么应该：\n\n```\n$ cd d:\n$ cd node/nodejs\n\n```\n这样就OK啦，如果想跟IDE进行配合也不是不行，步骤如下：\n1.在node.exe同级下建立project，命名为 nodejs ：\n![这里写图片描述](http://img.blog.csdn.net/20171212205905914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.在IDE中添加新建项目，添加刚才的文件夹路径：\n![这里写图片描述](http://img.blog.csdn.net/20171212210012938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n欧~~尅！\n接着，在IDE里面新建几个js文件，然后在我们的Node上面跑一跑(CreateServer那个DEMO就不做了)。\n建立第一个文件:hello.js （null文件）\n建立第二个文件:world.js（null文件）\n两个文件可以在同级目录，也可以不在。\n\n将下列代码填入hello.js：\n\n```\nfunction hello(){\n\tconsole.log(\"hello\")\n}\nexports.hello =hello();\n \n```\n打开gitBash,找到IDE中工程的目录(最好把js文件放在工程目录下即可，或者单独建一个js文件夹)：\n然后输入：`$ node hello.js`\n\n![这里写图片描述](http://img.blog.csdn.net/20171212210405883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后将下列代码填入 world.js :\n\n```\nvar world = require(\"./hello.js\");\nworld.hello\n```\n运行之，得出下图：\n\n![这里写图片描述](http://img.blog.csdn.net/20171212210540891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可以看到，两次的运行结果一样。hello.js的运行结果为hello不足为奇，那么world.js为什么也输出hello呢？\n\n这是因为在hello.js中，打包出来一个公共模块，`exports.hello =function(){....}`\n而在world.js中，引入了这个模块，并且赋值给变量world:\n\n```\nvar world = require('./hello.js') /*引入【hello.js里面打包的\n\n模块】*/\n\n/*此时，world相当于拥有共有模块的所有属性和方法了，那么此时，这个\n\nworld有一个方法为hello,我们调用这个hello方法，world.hello ，自然\n\n而然输出hello*/\n\n\n\n```\n如果将hello.js改进一下，\n```\nvar i=0 ; \nfunction hello(){\n++i;\nconsole.log(\"hello for \" + i)\n};\n```\n运行 `node hello.js` 输出: //hello for 1\n\n同时更改world.js:\n\n```\nvar world = require('./hello.js')\nvar world1 = require('./hello.js')\nworld.hello\nworld1.hello\n```\n运行 `$node world.js` 输出//hello for 1甭管运行几次，都是这个结果\n\n这说明，引入模块时，只有第一次引入时会初始化模块。\n\n**模块的集合：包(package)**\n所谓的包，就是内部集成了好多模块，主要使用一个入口文件作为包的入口，该文件的导出对象作为包的公有模块：\n\n```\n一   ---nodejs\n|一   ----js\n   |       -----main.js\n   |       ------head.js\n   |       ------body.js\n   |       ------footer.js\n|一   ------package.json\n\n\n```\n此时，main.js是包的入口和导出对象模块，在main.js中，很有可能引入了head.js、body.js、footer.js的导出模块，然后写入一些功能和方法，最后导出一个公有方法，供其他的包或者模块使用。\n\n\n\n当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。\n\n\n当引用包的入口文件时，require('./node/nodejs/main.js')这样给人感觉仿佛在引用一个模块，而不是整个包。\n解决方法是，将Main.js命名为index.js，这样，在引入包的入口文件时，直接填写包入口文件的路径：\n```\nvar cat = require('./js/index.js');\nvar cat = require('/js');\n\n//上面两条语句等价\n```\n\n这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。\n\n也可以用json文件来声明入口：\n\n```\n｛\n\t  'main':'./main.js'\n｝\n```\n这样，在引入包的入口文件时 require('./node/nodejs')时，会优先查找json文件，并从中读取入口配置，注意，此时的json一定要在引用的路径之下。\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/NodeJs基础配置、核心概念与学习路线回顾.md","raw":"---\ntitle: NodeJs基础配置、核心概念与学习路线回顾 \ndate: 2017-12-12 22:07:00\ntags: nodejs\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78786161)\n\nNodejs把前端开发带入一个全新的阶段，他使得js能够跑在服务端上，大大强化了js这门语言的可塑性。\nOK，环境配置不提，配置好了以后，直接来跑一些简单的demo\n\n以前一直没搞懂nodejs复杂的目录（其实是不懂linux），老把文件目录和运行时的目录搞错。\n\n在gitbash下，先进入对应的目录，例如我的js文件在 D:\\node\\nodejs下，那么应该：\n\n```\n$ cd d:\n$ cd node/nodejs\n\n```\n这样就OK啦，如果想跟IDE进行配合也不是不行，步骤如下：\n1.在node.exe同级下建立project，命名为 nodejs ：\n![这里写图片描述](http://img.blog.csdn.net/20171212205905914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.在IDE中添加新建项目，添加刚才的文件夹路径：\n![这里写图片描述](http://img.blog.csdn.net/20171212210012938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n欧~~尅！\n接着，在IDE里面新建几个js文件，然后在我们的Node上面跑一跑(CreateServer那个DEMO就不做了)。\n建立第一个文件:hello.js （null文件）\n建立第二个文件:world.js（null文件）\n两个文件可以在同级目录，也可以不在。\n\n将下列代码填入hello.js：\n\n```\nfunction hello(){\n\tconsole.log(\"hello\")\n}\nexports.hello =hello();\n \n```\n打开gitBash,找到IDE中工程的目录(最好把js文件放在工程目录下即可，或者单独建一个js文件夹)：\n然后输入：`$ node hello.js`\n\n![这里写图片描述](http://img.blog.csdn.net/20171212210405883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n然后将下列代码填入 world.js :\n\n```\nvar world = require(\"./hello.js\");\nworld.hello\n```\n运行之，得出下图：\n\n![这里写图片描述](http://img.blog.csdn.net/20171212210540891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可以看到，两次的运行结果一样。hello.js的运行结果为hello不足为奇，那么world.js为什么也输出hello呢？\n\n这是因为在hello.js中，打包出来一个公共模块，`exports.hello =function(){....}`\n而在world.js中，引入了这个模块，并且赋值给变量world:\n\n```\nvar world = require('./hello.js') /*引入【hello.js里面打包的\n\n模块】*/\n\n/*此时，world相当于拥有共有模块的所有属性和方法了，那么此时，这个\n\nworld有一个方法为hello,我们调用这个hello方法，world.hello ，自然\n\n而然输出hello*/\n\n\n\n```\n如果将hello.js改进一下，\n```\nvar i=0 ; \nfunction hello(){\n++i;\nconsole.log(\"hello for \" + i)\n};\n```\n运行 `node hello.js` 输出: //hello for 1\n\n同时更改world.js:\n\n```\nvar world = require('./hello.js')\nvar world1 = require('./hello.js')\nworld.hello\nworld1.hello\n```\n运行 `$node world.js` 输出//hello for 1甭管运行几次，都是这个结果\n\n这说明，引入模块时，只有第一次引入时会初始化模块。\n\n**模块的集合：包(package)**\n所谓的包，就是内部集成了好多模块，主要使用一个入口文件作为包的入口，该文件的导出对象作为包的公有模块：\n\n```\n一   ---nodejs\n|一   ----js\n   |       -----main.js\n   |       ------head.js\n   |       ------body.js\n   |       ------footer.js\n|一   ------package.json\n\n\n```\n此时，main.js是包的入口和导出对象模块，在main.js中，很有可能引入了head.js、body.js、footer.js的导出模块，然后写入一些功能和方法，最后导出一个公有方法，供其他的包或者模块使用。\n\n\n\n当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。\n\n\n当引用包的入口文件时，require('./node/nodejs/main.js')这样给人感觉仿佛在引用一个模块，而不是整个包。\n解决方法是，将Main.js命名为index.js，这样，在引入包的入口文件时，直接填写包入口文件的路径：\n```\nvar cat = require('./js/index.js');\nvar cat = require('/js');\n\n//上面两条语句等价\n```\n\n这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。\n\n也可以用json文件来声明入口：\n\n```\n｛\n\t  'main':'./main.js'\n｝\n```\n这样，在引入包的入口文件时 require('./node/nodejs')时，会优先查找json文件，并从中读取入口配置，注意，此时的json一定要在引用的路径之下。\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"NodeJs基础配置、核心概念与学习路线回顾","published":1,"updated":"2018-08-29T05:59:20.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfl000rjgv4c9c4sltv","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78786161\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>Nodejs把前端开发带入一个全新的阶段，他使得js能够跑在服务端上，大大强化了js这门语言的可塑性。<br>OK，环境配置不提，配置好了以后，直接来跑一些简单的demo</p>\n<p>以前一直没搞懂nodejs复杂的目录（其实是不懂linux），老把文件目录和运行时的目录搞错。</p>\n<p>在gitbash下，先进入对应的目录，例如我的js文件在 D:\\node\\nodejs下，那么应该：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd d:</span><br><span class=\"line\">$ cd node/nodejs</span><br></pre></td></tr></table></figure>\n<p>这样就OK啦，如果想跟IDE进行配合也不是不行，步骤如下：<br>1.在node.exe同级下建立project，命名为 nodejs ：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212205905914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>2.在IDE中添加新建项目，添加刚才的文件夹路径：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212210012938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>欧~~尅！<br>接着，在IDE里面新建几个js文件，然后在我们的Node上面跑一跑(CreateServer那个DEMO就不做了)。<br>建立第一个文件:hello.js （null文件）<br>建立第二个文件:world.js（null文件）<br>两个文件可以在同级目录，也可以不在。</p>\n<p>将下列代码填入hello.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hello()&#123;</span><br><span class=\"line\">\tconsole.log(&quot;hello&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.hello =hello();</span><br></pre></td></tr></table></figure>\n<p>打开gitBash,找到IDE中工程的目录(最好把js文件放在工程目录下即可，或者单独建一个js文件夹)：<br>然后输入：<code>$ node hello.js</code></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212210405883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>然后将下列代码填入 world.js :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var world = require(&quot;./hello.js&quot;);</span><br><span class=\"line\">world.hello</span><br></pre></td></tr></table></figure>\n<p>运行之，得出下图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212210540891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>可以看到，两次的运行结果一样。hello.js的运行结果为hello不足为奇，那么world.js为什么也输出hello呢？</p>\n<p>这是因为在hello.js中，打包出来一个公共模块，<code>exports.hello =function(){....}</code><br>而在world.js中，引入了这个模块，并且赋值给变量world:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var world = require(&apos;./hello.js&apos;) /*引入【hello.js里面打包的</span><br><span class=\"line\"></span><br><span class=\"line\">模块】*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*此时，world相当于拥有共有模块的所有属性和方法了，那么此时，这个</span><br><span class=\"line\"></span><br><span class=\"line\">world有一个方法为hello,我们调用这个hello方法，world.hello ，自然</span><br><span class=\"line\"></span><br><span class=\"line\">而然输出hello*/</span><br></pre></td></tr></table></figure>\n<p>如果将hello.js改进一下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i=0 ; </span><br><span class=\"line\">function hello()&#123;</span><br><span class=\"line\">++i;</span><br><span class=\"line\">console.log(&quot;hello for &quot; + i)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行 <code>node hello.js</code> 输出: //hello for 1</p>\n<p>同时更改world.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var world = require(&apos;./hello.js&apos;)</span><br><span class=\"line\">var world1 = require(&apos;./hello.js&apos;)</span><br><span class=\"line\">world.hello</span><br><span class=\"line\">world1.hello</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$node world.js</code> 输出//hello for 1甭管运行几次，都是这个结果</p>\n<p>这说明，引入模块时，只有第一次引入时会初始化模块。</p>\n<p><strong>模块的集合：包(package)</strong><br>所谓的包，就是内部集成了好多模块，主要使用一个入口文件作为包的入口，该文件的导出对象作为包的公有模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一   ---nodejs</span><br><span class=\"line\">|一   ----js</span><br><span class=\"line\">   |       -----main.js</span><br><span class=\"line\">   |       ------head.js</span><br><span class=\"line\">   |       ------body.js</span><br><span class=\"line\">   |       ------footer.js</span><br><span class=\"line\">|一   ------package.json</span><br></pre></td></tr></table></figure>\n<p>此时，main.js是包的入口和导出对象模块，在main.js中，很有可能引入了head.js、body.js、footer.js的导出模块，然后写入一些功能和方法，最后导出一个公有方法，供其他的包或者模块使用。</p>\n<p>当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。</p>\n<p>当引用包的入口文件时，require(‘./node/nodejs/main.js’)这样给人感觉仿佛在引用一个模块，而不是整个包。<br>解决方法是，将Main.js命名为index.js，这样，在引入包的入口文件时，直接填写包入口文件的路径：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat = require(&apos;./js/index.js&apos;);</span><br><span class=\"line\">var cat = require(&apos;/js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//上面两条语句等价</span><br></pre></td></tr></table></figure></p>\n<p>这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>\n<p>也可以用json文件来声明入口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">｛</span><br><span class=\"line\">\t  &apos;main&apos;:&apos;./main.js&apos;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>这样，在引入包的入口文件时 require(‘./node/nodejs’)时，会优先查找json文件，并从中读取入口配置，注意，此时的json一定要在引用的路径之下。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78786161\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>Nodejs把前端开发带入一个全新的阶段，他使得js能够跑在服务端上，大大强化了js这门语言的可塑性。<br>OK，环境配置不提，配置好了以后，直接来跑一些简单的demo</p>\n<p>以前一直没搞懂nodejs复杂的目录（其实是不懂linux），老把文件目录和运行时的目录搞错。</p>\n<p>在gitbash下，先进入对应的目录，例如我的js文件在 D:\\node\\nodejs下，那么应该：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd d:</span><br><span class=\"line\">$ cd node/nodejs</span><br></pre></td></tr></table></figure>\n<p>这样就OK啦，如果想跟IDE进行配合也不是不行，步骤如下：<br>1.在node.exe同级下建立project，命名为 nodejs ：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212205905914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>2.在IDE中添加新建项目，添加刚才的文件夹路径：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212210012938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>欧~~尅！<br>接着，在IDE里面新建几个js文件，然后在我们的Node上面跑一跑(CreateServer那个DEMO就不做了)。<br>建立第一个文件:hello.js （null文件）<br>建立第二个文件:world.js（null文件）<br>两个文件可以在同级目录，也可以不在。</p>\n<p>将下列代码填入hello.js：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function hello()&#123;</span><br><span class=\"line\">\tconsole.log(&quot;hello&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.hello =hello();</span><br></pre></td></tr></table></figure>\n<p>打开gitBash,找到IDE中工程的目录(最好把js文件放在工程目录下即可，或者单独建一个js文件夹)：<br>然后输入：<code>$ node hello.js</code></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212210405883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>然后将下列代码填入 world.js :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var world = require(&quot;./hello.js&quot;);</span><br><span class=\"line\">world.hello</span><br></pre></td></tr></table></figure>\n<p>运行之，得出下图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212210540891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>可以看到，两次的运行结果一样。hello.js的运行结果为hello不足为奇，那么world.js为什么也输出hello呢？</p>\n<p>这是因为在hello.js中，打包出来一个公共模块，<code>exports.hello =function(){....}</code><br>而在world.js中，引入了这个模块，并且赋值给变量world:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var world = require(&apos;./hello.js&apos;) /*引入【hello.js里面打包的</span><br><span class=\"line\"></span><br><span class=\"line\">模块】*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*此时，world相当于拥有共有模块的所有属性和方法了，那么此时，这个</span><br><span class=\"line\"></span><br><span class=\"line\">world有一个方法为hello,我们调用这个hello方法，world.hello ，自然</span><br><span class=\"line\"></span><br><span class=\"line\">而然输出hello*/</span><br></pre></td></tr></table></figure>\n<p>如果将hello.js改进一下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i=0 ; </span><br><span class=\"line\">function hello()&#123;</span><br><span class=\"line\">++i;</span><br><span class=\"line\">console.log(&quot;hello for &quot; + i)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>运行 <code>node hello.js</code> 输出: //hello for 1</p>\n<p>同时更改world.js:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var world = require(&apos;./hello.js&apos;)</span><br><span class=\"line\">var world1 = require(&apos;./hello.js&apos;)</span><br><span class=\"line\">world.hello</span><br><span class=\"line\">world1.hello</span><br></pre></td></tr></table></figure>\n<p>运行 <code>$node world.js</code> 输出//hello for 1甭管运行几次，都是这个结果</p>\n<p>这说明，引入模块时，只有第一次引入时会初始化模块。</p>\n<p><strong>模块的集合：包(package)</strong><br>所谓的包，就是内部集成了好多模块，主要使用一个入口文件作为包的入口，该文件的导出对象作为包的公有模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一   ---nodejs</span><br><span class=\"line\">|一   ----js</span><br><span class=\"line\">   |       -----main.js</span><br><span class=\"line\">   |       ------head.js</span><br><span class=\"line\">   |       ------body.js</span><br><span class=\"line\">   |       ------footer.js</span><br><span class=\"line\">|一   ------package.json</span><br></pre></td></tr></table></figure>\n<p>此时，main.js是包的入口和导出对象模块，在main.js中，很有可能引入了head.js、body.js、footer.js的导出模块，然后写入一些功能和方法，最后导出一个公有方法，供其他的包或者模块使用。</p>\n<p>当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。</p>\n<p>当引用包的入口文件时，require(‘./node/nodejs/main.js’)这样给人感觉仿佛在引用一个模块，而不是整个包。<br>解决方法是，将Main.js命名为index.js，这样，在引入包的入口文件时，直接填写包入口文件的路径：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var cat = require(&apos;./js/index.js&apos;);</span><br><span class=\"line\">var cat = require(&apos;/js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//上面两条语句等价</span><br></pre></td></tr></table></figure></p>\n<p>这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>\n<p>也可以用json文件来声明入口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">｛</span><br><span class=\"line\">\t  &apos;main&apos;:&apos;./main.js&apos;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>这样，在引入包的入口文件时 require(‘./node/nodejs’)时，会优先查找json文件，并从中读取入口配置，注意，此时的json一定要在引用的路径之下。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"PHP初体验","date":"2017-12-09T06:29:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客]()\n\n\n**1.连接符**\n==\n\n```\n$color = 'red'\n第一种连接方式: echo \"my color is $color\"\n第二种连接方式: echo \"my color is\". $color .\"<br>\"//（VB是&链接，js+链接，这个.链接真的反人类）\n第三种连接方式: echo\"my colo is{$color}\"//花括号包住变量\n第四种连接方式(相当于js字符串的+=):\n$a=\"hello\";\necho $a.=\"world\"; //hello,world\n\n\n```\n\n**2.变量Scope**\n==\n\n**1.全局作用域**\n定义的变量只能在全局读取，函数内部都无法读取。\n**2.局部作用域**\n定义的变量只能在局部读取，全局无法读取。\n（js的变量是：父域的变量可以让子域读取，反过来则不能。）\n如果局部子域想要访问Global变量，则需要提前声明：爸爸，我要用你的变量：\n\n```\n\n$a = 5;\nfunction son(){\nglobal $a ;\n$b = 1;\nreturn a+b\n}\nson();//6\n```\n更或通过所有**全局变量**的数组来访问全局变量，因此上述的表达式\n\n```\nglobal $a等价于： $GLOBAL['a']  (下标注意，有引号)\n\n```\n如果想要局部变量的函数在函数执行完成以后不被销毁，即继续在全局域下使用，那么应该提前声明static(静态的)关键字：\n\n```\n<?php\n\nfunction myTest() {\n  static $x=2;\n  echo \"结果是:$x\";\n  $x=$x*$x;\n}\n\nmyTest();//2\nmyTest();//4\nmyTest();//16\n\n?>\n```\n\n**3.常量(真·全局量)**\n==\n\n相当于全局的变量，但是值不可更改或者撤销定义\n\n定义方法：define(name,value,bool)，参数很简单，关键在第三个参数，对大小写不敏感吗？默认flase，对大小写敏感，如果强行设置第三个参数为true,则对常量名字大小写不敏感。\n\n**4.运算符**\n==\n\n+，-，*，/，% ,==,===      大同小异。\n\n唯一和js不同的是，不等于可以写成 <>，啊哈哈，和vb有点像\n\n**5.超全局变量**\n==\nPHP 超全局变量\n```\n $_GET 和 $_POST \n```\n用于收集表单数据（form-data）。\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/PHP初体验.md","raw":"---\ntitle: PHP初体验 \ndate: 2017-12-09 14:29:00\ntags: php\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客]()\n\n\n**1.连接符**\n==\n\n```\n$color = 'red'\n第一种连接方式: echo \"my color is $color\"\n第二种连接方式: echo \"my color is\". $color .\"<br>\"//（VB是&链接，js+链接，这个.链接真的反人类）\n第三种连接方式: echo\"my colo is{$color}\"//花括号包住变量\n第四种连接方式(相当于js字符串的+=):\n$a=\"hello\";\necho $a.=\"world\"; //hello,world\n\n\n```\n\n**2.变量Scope**\n==\n\n**1.全局作用域**\n定义的变量只能在全局读取，函数内部都无法读取。\n**2.局部作用域**\n定义的变量只能在局部读取，全局无法读取。\n（js的变量是：父域的变量可以让子域读取，反过来则不能。）\n如果局部子域想要访问Global变量，则需要提前声明：爸爸，我要用你的变量：\n\n```\n\n$a = 5;\nfunction son(){\nglobal $a ;\n$b = 1;\nreturn a+b\n}\nson();//6\n```\n更或通过所有**全局变量**的数组来访问全局变量，因此上述的表达式\n\n```\nglobal $a等价于： $GLOBAL['a']  (下标注意，有引号)\n\n```\n如果想要局部变量的函数在函数执行完成以后不被销毁，即继续在全局域下使用，那么应该提前声明static(静态的)关键字：\n\n```\n<?php\n\nfunction myTest() {\n  static $x=2;\n  echo \"结果是:$x\";\n  $x=$x*$x;\n}\n\nmyTest();//2\nmyTest();//4\nmyTest();//16\n\n?>\n```\n\n**3.常量(真·全局量)**\n==\n\n相当于全局的变量，但是值不可更改或者撤销定义\n\n定义方法：define(name,value,bool)，参数很简单，关键在第三个参数，对大小写不敏感吗？默认flase，对大小写敏感，如果强行设置第三个参数为true,则对常量名字大小写不敏感。\n\n**4.运算符**\n==\n\n+，-，*，/，% ,==,===      大同小异。\n\n唯一和js不同的是，不等于可以写成 <>，啊哈哈，和vb有点像\n\n**5.超全局变量**\n==\nPHP 超全局变量\n```\n $_GET 和 $_POST \n```\n用于收集表单数据（form-data）。\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"PHP初体验","published":1,"updated":"2018-08-29T05:59:20.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfo000tjgv4y2ai2uxn","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"\">我的CSDN博客</a></p>\n<h1 id=\"1-连接符\"><a href=\"#1-连接符\" class=\"headerlink\" title=\"1.连接符\"></a><strong>1.连接符</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$color = &apos;red&apos;</span><br><span class=\"line\">第一种连接方式: echo &quot;my color is $color&quot;</span><br><span class=\"line\">第二种连接方式: echo &quot;my color is&quot;. $color .&quot;&lt;br&gt;&quot;//（VB是&amp;链接，js+链接，这个.链接真的反人类）</span><br><span class=\"line\">第三种连接方式: echo&quot;my colo is&#123;$color&#125;&quot;//花括号包住变量</span><br><span class=\"line\">第四种连接方式(相当于js字符串的+=):</span><br><span class=\"line\">$a=&quot;hello&quot;;</span><br><span class=\"line\">echo $a.=&quot;world&quot;; //hello,world</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-变量Scope\"><a href=\"#2-变量Scope\" class=\"headerlink\" title=\"2.变量Scope\"></a><strong>2.变量Scope</strong></h1><p><strong>1.全局作用域</strong><br>定义的变量只能在全局读取，函数内部都无法读取。<br><strong>2.局部作用域</strong><br>定义的变量只能在局部读取，全局无法读取。<br>（js的变量是：父域的变量可以让子域读取，反过来则不能。）<br>如果局部子域想要访问Global变量，则需要提前声明：爸爸，我要用你的变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$a = 5;</span><br><span class=\"line\">function son()&#123;</span><br><span class=\"line\">global $a ;</span><br><span class=\"line\">$b = 1;</span><br><span class=\"line\">return a+b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">son();//6</span><br></pre></td></tr></table></figure>\n<p>更或通过所有<strong>全局变量</strong>的数组来访问全局变量，因此上述的表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global $a等价于： $GLOBAL[&apos;a&apos;]  (下标注意，有引号)</span><br></pre></td></tr></table></figure>\n<p>如果想要局部变量的函数在函数执行完成以后不被销毁，即继续在全局域下使用，那么应该提前声明static(静态的)关键字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"></span><br><span class=\"line\">function myTest() &#123;</span><br><span class=\"line\">  static $x=2;</span><br><span class=\"line\">  echo &quot;结果是:$x&quot;;</span><br><span class=\"line\">  $x=$x*$x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTest();//2</span><br><span class=\"line\">myTest();//4</span><br><span class=\"line\">myTest();//16</span><br><span class=\"line\"></span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-常量-真·全局量\"><a href=\"#3-常量-真·全局量\" class=\"headerlink\" title=\"3.常量(真·全局量)\"></a><strong>3.常量(真·全局量)</strong></h1><p>相当于全局的变量，但是值不可更改或者撤销定义</p>\n<p>定义方法：define(name,value,bool)，参数很简单，关键在第三个参数，对大小写不敏感吗？默认flase，对大小写敏感，如果强行设置第三个参数为true,则对常量名字大小写不敏感。</p>\n<h1 id=\"4-运算符\"><a href=\"#4-运算符\" class=\"headerlink\" title=\"4.运算符\"></a><strong>4.运算符</strong></h1><p>+，-，*，/，% ,==,===      大同小异。</p>\n<p>唯一和js不同的是，不等于可以写成 &lt;&gt;，啊哈哈，和vb有点像</p>\n<h1 id=\"5-超全局变量\"><a href=\"#5-超全局变量\" class=\"headerlink\" title=\"5.超全局变量\"></a><strong>5.超全局变量</strong></h1><p>PHP 超全局变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$_GET 和 $_POST</span><br></pre></td></tr></table></figure></p>\n<p>用于收集表单数据（form-data）。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"\">我的CSDN博客</a></p>\n<h1 id=\"1-连接符\"><a href=\"#1-连接符\" class=\"headerlink\" title=\"1.连接符\"></a><strong>1.连接符</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$color = &apos;red&apos;</span><br><span class=\"line\">第一种连接方式: echo &quot;my color is $color&quot;</span><br><span class=\"line\">第二种连接方式: echo &quot;my color is&quot;. $color .&quot;&lt;br&gt;&quot;//（VB是&amp;链接，js+链接，这个.链接真的反人类）</span><br><span class=\"line\">第三种连接方式: echo&quot;my colo is&#123;$color&#125;&quot;//花括号包住变量</span><br><span class=\"line\">第四种连接方式(相当于js字符串的+=):</span><br><span class=\"line\">$a=&quot;hello&quot;;</span><br><span class=\"line\">echo $a.=&quot;world&quot;; //hello,world</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-变量Scope\"><a href=\"#2-变量Scope\" class=\"headerlink\" title=\"2.变量Scope\"></a><strong>2.变量Scope</strong></h1><p><strong>1.全局作用域</strong><br>定义的变量只能在全局读取，函数内部都无法读取。<br><strong>2.局部作用域</strong><br>定义的变量只能在局部读取，全局无法读取。<br>（js的变量是：父域的变量可以让子域读取，反过来则不能。）<br>如果局部子域想要访问Global变量，则需要提前声明：爸爸，我要用你的变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$a = 5;</span><br><span class=\"line\">function son()&#123;</span><br><span class=\"line\">global $a ;</span><br><span class=\"line\">$b = 1;</span><br><span class=\"line\">return a+b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">son();//6</span><br></pre></td></tr></table></figure>\n<p>更或通过所有<strong>全局变量</strong>的数组来访问全局变量，因此上述的表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global $a等价于： $GLOBAL[&apos;a&apos;]  (下标注意，有引号)</span><br></pre></td></tr></table></figure>\n<p>如果想要局部变量的函数在函数执行完成以后不被销毁，即继续在全局域下使用，那么应该提前声明static(静态的)关键字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\"></span><br><span class=\"line\">function myTest() &#123;</span><br><span class=\"line\">  static $x=2;</span><br><span class=\"line\">  echo &quot;结果是:$x&quot;;</span><br><span class=\"line\">  $x=$x*$x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTest();//2</span><br><span class=\"line\">myTest();//4</span><br><span class=\"line\">myTest();//16</span><br><span class=\"line\"></span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-常量-真·全局量\"><a href=\"#3-常量-真·全局量\" class=\"headerlink\" title=\"3.常量(真·全局量)\"></a><strong>3.常量(真·全局量)</strong></h1><p>相当于全局的变量，但是值不可更改或者撤销定义</p>\n<p>定义方法：define(name,value,bool)，参数很简单，关键在第三个参数，对大小写不敏感吗？默认flase，对大小写敏感，如果强行设置第三个参数为true,则对常量名字大小写不敏感。</p>\n<h1 id=\"4-运算符\"><a href=\"#4-运算符\" class=\"headerlink\" title=\"4.运算符\"></a><strong>4.运算符</strong></h1><p>+，-，*，/，% ,==,===      大同小异。</p>\n<p>唯一和js不同的是，不等于可以写成 &lt;&gt;，啊哈哈，和vb有点像</p>\n<h1 id=\"5-超全局变量\"><a href=\"#5-超全局变量\" class=\"headerlink\" title=\"5.超全局变量\"></a><strong>5.超全局变量</strong></h1><p>PHP 超全局变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$_GET 和 $_POST</span><br></pre></td></tr></table></figure></p>\n<p>用于收集表单数据（form-data）。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Webpack打包工具学习笔记","date":"2018-01-17T03:18:00.000Z","reward":true,"comment":true,"_content":"\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/u014717036/article/details/51001311)\n\n## 前言 ##\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79078776)\n前言：Webpack是一款基于node的前端打包工具，它可以将很多静态文件打包起来，自动处理依赖关系后，生成一个.js文件，然后让html来引用，不仅可以做到按需加载，而且可以减少HTTP请求，节约带宽。\n\n## 1.配置与安装 ##\n在node已经安装完成的前提下，全局安装webpack\n\n```\n$ cd d:\n\n$ mkdir test && cd test  //创建test ，并进入\n\n$ npm install -g webpack  //等待100s，安装完成，也可以使用淘宝镜像\n\n$ npm init //初始化package.json文件\n\n$ npm install --save-dev webpack //添加依赖 ，在package.json中声明依赖,等待安装完成\n\n```\n## 2.基本操作`$webpack main.js webpack.js`##\n\n当前目录下创建如下工作结构:\n\n```\n/---------test\n\n   ----app\n     ----main.js\n     ----index.js   \n     \n   ----index.html\n```\n项目目录下，app文件夹含有两个js文件，修改如下：\n\n```\n//main.js ，这是Webpack主要的入口文件\n\n  require('./index.js');\n\n\n\n//index.js ，这是被主文件引用的文件\n\ndocument.write('Hello,world!');\n\n\n\n//index.html ，供浏览器解读\n\n<html>\n\n...\n\n<script src=\"./webpack.js\">  // 引用同目录下的webpack.js\n\n...\n\n</html>\n\n```\n\nwebpack.js是哪来的呢？就是通过webpack打包生成的js文件，接下来，\n\n开始生成webpack.js文件：\n\n```\n$ webpack main.js webpack.js\n\n```\n![这里写图片描述](http://img.blog.csdn.net/20180116202114667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到已经打包成功了，此时查看IDE中的项目目录，根目录下已经多了一个webpack.js文件。然后用浏览器打开index.html，效果如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20180116202235717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n此时查看网页源代码：\n\n![这里写图片描述](http://img.blog.csdn.net/20180116202405946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n66666666666！\n## 3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）##\n每次在命令行敲目录调试，是很痛苦的，因此需要一次配置，多次使用的方法。\n\n在根目录下新建文件： webpack.config.js  (名字就是这样，规定，不能改)，内容如下：\n\n```\nmodule.exports  = {\n//入口文件位置\n    entry:__dirname+'/app/main.js',\n\n//出口\n    output:{\n   //路径\n        path:__dirname,\n        filename:'webpack.js'\n    }\n\n}\n```\n这里的 __dirname是一个node的全局变量，用于指向当前的工作目录，调皮的我console.log了一下这个变量：\n\n![这里写图片描述](http://img.blog.csdn.net/20180116203051747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n确认无疑。\n\n这样，我们的webpack.js写完以后，可以直接在命令行中敲：\n\n```\n$ webpack\n```\n可以发现，项目中也同样的会生成目标js文件，也就是webpack.js，这样非常方便，省事。 \n\n\n还有一种配置方法，将package.json文件中\"scripts\"里面添加键值对：\n![这里写图片描述](http://img.blog.csdn.net/20180116203453509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这样同样可以在项目目录生成目标js文件，直接在 命令行里敲\n\n```\n$ npm start //因为webpack是全局安装的，直接value给webpack，而不用跟路径\n```\n如果start被占用了/冲突了，也可以在scripts下面自定义一个键值对：\n\n```\n\"zq\":\"webpack\"\n\n$ npm run zq //稍作修改cmd 命令\n```\n最后还是可以生成。\n## 4.webpack服务器监听代码变动，自动刷新及source-map ##\n4.1关于source-map，也就是在webpack.config.js中配置 devtool (develpment tool)的值，例如我这样配置：\n\n![这里写图片描述](http://img.blog.csdn.net/20180117094811412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在webpack完成文件打包后，会自动生成一个与目标文件相同名的 .map文件，用来说明打包文件的每个地方对应的是哪些文件，简而言之，让你能知道源码是在哪里错的，帮你刨根问底，而不用开发者自己去Debug。\n\n参考文章1：[入门WEBPACK，看这篇文章就够了----简书](https://www.jianshu.com/p/42e11515c10f)\n\n参考文章2：[Webpack中的sourcemap](https://www.cnblogs.com/axl234/p/6500534.html)\n\n\n4.2 webpack服务器 \n\n首先单独安装 server 包 ：\n\n```\n$ npm install --save-dev webpack-dev-server\n```\n同样的，在webpack.config.js中做出相应的配置：\n\n```\nmodule.exports = {\n    devtool: 'source-map',\n    entry: __dirname + \"/app/main.js\",\n    output: {\n        path: __dirname,\n        filename: 'bundle.js'\n    },\n    module: {\n\n    },\n\n    devServer: {\n        contentBase: \"./\",//本地服务器加载index.html页面所在的目录，这里写的是根目录\n        historyApiFallback: true,//不跳转\n        inline: true//实时刷新,\n    } \n\n}\n```\n\n配置好config后，还得配置一下package.json，在scirpts里面添加server：\n\n```\n\n\"scripts\": {\n    \"start\": \"webpack\",\n    \"server\": \"webpack-dev-server --open\", \n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \n```\n\n接着，在命令行运行\n\n```\n\n$ npm run server \n\n/*届时服务器会自动启动， 并且打开浏览器,默认端口为8080，也可以\ndevServer:{\n\nport:4040 //自己配置端口为4040\n\n}\n\n```\n\n下面是一个服务器跑起来后的演示结果，我不断的修改work.js 中 `document.write`的值，从而服务器会自动检测并刷新页面：\n\n\n![这里写图片描述](http://img.blog.csdn.net/20180117100531064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n## 5.非JS文件的操作(img,json,css......),猪脚：Loaders ##\n\n **5.0 基本概念** \n 前面都在说js文件，官网说什么文件都可以当做模块打包，下面就来试试非js文件。\n\n首先要明确的是，webpack只能识别js文件，如果要识别非js文件，就需要loader来解析这些文件。\n\nloaders 需要单独安装，并且在webpack.config.js中的modules关键字下进行配置。\n\nWebpck2以上已经支持对json的解析打包，不需要额外的loaders，可以在main.js中\n\n```\nvar json = require('../package.json')//json在它的上级目录\n\ndocument.write(json.scripts.server);\n\n```\n\n运行结果 ：\n\n![这里写图片描述](http://img.blog.csdn.net/20180117101705406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可见，网页中，没有通过任何第三方loader，即可将json解析并打包成bundle.js。\n\n**5.1 Bable **\nBable可以使得开发者使用最新的ECMAscript标准来书写代码，而不用管新标准是否被当前使用的浏览器完全支持。\n\n还是需要单独安装Bable的包：\n\n```\n$ npm install --save-dev babel-core babel-loader babel-preset-env \n\n/\n```\n\n安装完成后，在webpack.config.js下的module关键字下进行配置：\n\n```\nmodule.exports = {\n  devtool: 'source-map',\n  \n    entry: __dirname + \"/app/main.js\",\n    \n    output: {\n    \n        path: __dirname,\n        \n        filename: 'bundle.js'\n        \n    },\n    \n    \n    devtool: 'eval-source-map',\n    \n    devServer: {\n    \n        contentBase: \"./public\",//本地服务器所加载的页面所在的目录\n        \n        historyApiFallback: true,//不跳转\n        \n        inline: true//实时刷新\n        \n    },\n    \n    module: {\n    \n        rules: [\n        \n            {\n            \n                test: /\\.js$/, //正则匹配，必须\n                \n                use: { //使用到的loader\n                \n                    loader: \"babel-loader\",  //loader名\n                    \n                    options: {   //选项\n                    \n                        presets: [ //预先配置\n                        \n                            \"env\"\n                            \n                        ]\n                        \n                    }\n                    \n                },\n                \n                exclude: /node_modules/ //不包含的目录或文件\n                \n            }\n            \n        ]\n        \n    }\n    \n};\n\n```\n\n\n**5.2 CSS文件处理 **\nwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。\n\n同样先安装两个包 style-loader和css-loader\n\n```\n$ npm install --save-dev style-loader css-loader\n```\n\n```\n module: {\n        rules: [\n          {.......}，\n {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: \"style-loader\"\n                    }, {\n                        loader: \"css-loader\"\n                    }\n也可以简写：\n{\ntest:/\\.css$/.\n\nuse:[{\n\nloader:\"style!css\"  //这里的执行顺序是从右往左，css应该在style之前执行\n\n}]\n}\n```\n*根目录下新建 ./src/index.css，写一个body的背景为green，然后在入口文件main.js中,require('../src/index.css')，接着通过命令行`$ webpack`*\n此时查看index.html，发现页面背景已经变成绿色\n![这里写图片描述](http://img.blog.csdn.net/20180117110627698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 6.插件plugins ##\n先安装插件的包：\n\n```\ncnpm install html-webpack-plugin\n```\n在webpack.config.js中 头部，引入依赖：\n\n```\nlet webpack = require('webpack');\n```\n\n然后在webpack.config.js中配置根键值对：\n\n```\n  plugins: [\n        new webpack.BannerPlugin('版权所有，翻版必究')\n    ],\n```\n![这里写图片描述](http://img.blog.csdn.net/20180117111652412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/Webpack打包工具学习笔记.md","raw":"---\ntitle: Webpack打包工具学习笔记\ndate: 2018-01-17 11:18:00\ntags: Webpack\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/u014717036/article/details/51001311)\n\n## 前言 ##\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79078776)\n前言：Webpack是一款基于node的前端打包工具，它可以将很多静态文件打包起来，自动处理依赖关系后，生成一个.js文件，然后让html来引用，不仅可以做到按需加载，而且可以减少HTTP请求，节约带宽。\n\n## 1.配置与安装 ##\n在node已经安装完成的前提下，全局安装webpack\n\n```\n$ cd d:\n\n$ mkdir test && cd test  //创建test ，并进入\n\n$ npm install -g webpack  //等待100s，安装完成，也可以使用淘宝镜像\n\n$ npm init //初始化package.json文件\n\n$ npm install --save-dev webpack //添加依赖 ，在package.json中声明依赖,等待安装完成\n\n```\n## 2.基本操作`$webpack main.js webpack.js`##\n\n当前目录下创建如下工作结构:\n\n```\n/---------test\n\n   ----app\n     ----main.js\n     ----index.js   \n     \n   ----index.html\n```\n项目目录下，app文件夹含有两个js文件，修改如下：\n\n```\n//main.js ，这是Webpack主要的入口文件\n\n  require('./index.js');\n\n\n\n//index.js ，这是被主文件引用的文件\n\ndocument.write('Hello,world!');\n\n\n\n//index.html ，供浏览器解读\n\n<html>\n\n...\n\n<script src=\"./webpack.js\">  // 引用同目录下的webpack.js\n\n...\n\n</html>\n\n```\n\nwebpack.js是哪来的呢？就是通过webpack打包生成的js文件，接下来，\n\n开始生成webpack.js文件：\n\n```\n$ webpack main.js webpack.js\n\n```\n![这里写图片描述](http://img.blog.csdn.net/20180116202114667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到已经打包成功了，此时查看IDE中的项目目录，根目录下已经多了一个webpack.js文件。然后用浏览器打开index.html，效果如下：\n\n![这里写图片描述](http://img.blog.csdn.net/20180116202235717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n此时查看网页源代码：\n\n![这里写图片描述](http://img.blog.csdn.net/20180116202405946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n66666666666！\n## 3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）##\n每次在命令行敲目录调试，是很痛苦的，因此需要一次配置，多次使用的方法。\n\n在根目录下新建文件： webpack.config.js  (名字就是这样，规定，不能改)，内容如下：\n\n```\nmodule.exports  = {\n//入口文件位置\n    entry:__dirname+'/app/main.js',\n\n//出口\n    output:{\n   //路径\n        path:__dirname,\n        filename:'webpack.js'\n    }\n\n}\n```\n这里的 __dirname是一个node的全局变量，用于指向当前的工作目录，调皮的我console.log了一下这个变量：\n\n![这里写图片描述](http://img.blog.csdn.net/20180116203051747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n确认无疑。\n\n这样，我们的webpack.js写完以后，可以直接在命令行中敲：\n\n```\n$ webpack\n```\n可以发现，项目中也同样的会生成目标js文件，也就是webpack.js，这样非常方便，省事。 \n\n\n还有一种配置方法，将package.json文件中\"scripts\"里面添加键值对：\n![这里写图片描述](http://img.blog.csdn.net/20180116203453509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这样同样可以在项目目录生成目标js文件，直接在 命令行里敲\n\n```\n$ npm start //因为webpack是全局安装的，直接value给webpack，而不用跟路径\n```\n如果start被占用了/冲突了，也可以在scripts下面自定义一个键值对：\n\n```\n\"zq\":\"webpack\"\n\n$ npm run zq //稍作修改cmd 命令\n```\n最后还是可以生成。\n## 4.webpack服务器监听代码变动，自动刷新及source-map ##\n4.1关于source-map，也就是在webpack.config.js中配置 devtool (develpment tool)的值，例如我这样配置：\n\n![这里写图片描述](http://img.blog.csdn.net/20180117094811412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在webpack完成文件打包后，会自动生成一个与目标文件相同名的 .map文件，用来说明打包文件的每个地方对应的是哪些文件，简而言之，让你能知道源码是在哪里错的，帮你刨根问底，而不用开发者自己去Debug。\n\n参考文章1：[入门WEBPACK，看这篇文章就够了----简书](https://www.jianshu.com/p/42e11515c10f)\n\n参考文章2：[Webpack中的sourcemap](https://www.cnblogs.com/axl234/p/6500534.html)\n\n\n4.2 webpack服务器 \n\n首先单独安装 server 包 ：\n\n```\n$ npm install --save-dev webpack-dev-server\n```\n同样的，在webpack.config.js中做出相应的配置：\n\n```\nmodule.exports = {\n    devtool: 'source-map',\n    entry: __dirname + \"/app/main.js\",\n    output: {\n        path: __dirname,\n        filename: 'bundle.js'\n    },\n    module: {\n\n    },\n\n    devServer: {\n        contentBase: \"./\",//本地服务器加载index.html页面所在的目录，这里写的是根目录\n        historyApiFallback: true,//不跳转\n        inline: true//实时刷新,\n    } \n\n}\n```\n\n配置好config后，还得配置一下package.json，在scirpts里面添加server：\n\n```\n\n\"scripts\": {\n    \"start\": \"webpack\",\n    \"server\": \"webpack-dev-server --open\", \n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \n```\n\n接着，在命令行运行\n\n```\n\n$ npm run server \n\n/*届时服务器会自动启动， 并且打开浏览器,默认端口为8080，也可以\ndevServer:{\n\nport:4040 //自己配置端口为4040\n\n}\n\n```\n\n下面是一个服务器跑起来后的演示结果，我不断的修改work.js 中 `document.write`的值，从而服务器会自动检测并刷新页面：\n\n\n![这里写图片描述](http://img.blog.csdn.net/20180117100531064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n## 5.非JS文件的操作(img,json,css......),猪脚：Loaders ##\n\n **5.0 基本概念** \n 前面都在说js文件，官网说什么文件都可以当做模块打包，下面就来试试非js文件。\n\n首先要明确的是，webpack只能识别js文件，如果要识别非js文件，就需要loader来解析这些文件。\n\nloaders 需要单独安装，并且在webpack.config.js中的modules关键字下进行配置。\n\nWebpck2以上已经支持对json的解析打包，不需要额外的loaders，可以在main.js中\n\n```\nvar json = require('../package.json')//json在它的上级目录\n\ndocument.write(json.scripts.server);\n\n```\n\n运行结果 ：\n\n![这里写图片描述](http://img.blog.csdn.net/20180117101705406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可见，网页中，没有通过任何第三方loader，即可将json解析并打包成bundle.js。\n\n**5.1 Bable **\nBable可以使得开发者使用最新的ECMAscript标准来书写代码，而不用管新标准是否被当前使用的浏览器完全支持。\n\n还是需要单独安装Bable的包：\n\n```\n$ npm install --save-dev babel-core babel-loader babel-preset-env \n\n/\n```\n\n安装完成后，在webpack.config.js下的module关键字下进行配置：\n\n```\nmodule.exports = {\n  devtool: 'source-map',\n  \n    entry: __dirname + \"/app/main.js\",\n    \n    output: {\n    \n        path: __dirname,\n        \n        filename: 'bundle.js'\n        \n    },\n    \n    \n    devtool: 'eval-source-map',\n    \n    devServer: {\n    \n        contentBase: \"./public\",//本地服务器所加载的页面所在的目录\n        \n        historyApiFallback: true,//不跳转\n        \n        inline: true//实时刷新\n        \n    },\n    \n    module: {\n    \n        rules: [\n        \n            {\n            \n                test: /\\.js$/, //正则匹配，必须\n                \n                use: { //使用到的loader\n                \n                    loader: \"babel-loader\",  //loader名\n                    \n                    options: {   //选项\n                    \n                        presets: [ //预先配置\n                        \n                            \"env\"\n                            \n                        ]\n                        \n                    }\n                    \n                },\n                \n                exclude: /node_modules/ //不包含的目录或文件\n                \n            }\n            \n        ]\n        \n    }\n    \n};\n\n```\n\n\n**5.2 CSS文件处理 **\nwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。\n\n同样先安装两个包 style-loader和css-loader\n\n```\n$ npm install --save-dev style-loader css-loader\n```\n\n```\n module: {\n        rules: [\n          {.......}，\n {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: \"style-loader\"\n                    }, {\n                        loader: \"css-loader\"\n                    }\n也可以简写：\n{\ntest:/\\.css$/.\n\nuse:[{\n\nloader:\"style!css\"  //这里的执行顺序是从右往左，css应该在style之前执行\n\n}]\n}\n```\n*根目录下新建 ./src/index.css，写一个body的背景为green，然后在入口文件main.js中,require('../src/index.css')，接着通过命令行`$ webpack`*\n此时查看index.html，发现页面背景已经变成绿色\n![这里写图片描述](http://img.blog.csdn.net/20180117110627698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 6.插件plugins ##\n先安装插件的包：\n\n```\ncnpm install html-webpack-plugin\n```\n在webpack.config.js中 头部，引入依赖：\n\n```\nlet webpack = require('webpack');\n```\n\n然后在webpack.config.js中配置根键值对：\n\n```\n  plugins: [\n        new webpack.BannerPlugin('版权所有，翻版必究')\n    ],\n```\n![这里写图片描述](http://img.blog.csdn.net/20180117111652412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"Webpack打包工具学习笔记","published":1,"updated":"2018-08-29T05:59:20.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfp000vjgv4n3ht3xsw","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/u014717036/article/details/51001311\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79078776\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a><br>前言：Webpack是一款基于node的前端打包工具，它可以将很多静态文件打包起来，自动处理依赖关系后，生成一个.js文件，然后让html来引用，不仅可以做到按需加载，而且可以减少HTTP请求，节约带宽。</p>\n<h2 id=\"1-配置与安装\"><a href=\"#1-配置与安装\" class=\"headerlink\" title=\"1.配置与安装\"></a>1.配置与安装</h2><p>在node已经安装完成的前提下，全局安装webpack</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd d:</span><br><span class=\"line\"></span><br><span class=\"line\">$ mkdir test &amp;&amp; cd test  //创建test ，并进入</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install -g webpack  //等待100s，安装完成，也可以使用淘宝镜像</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm init //初始化package.json文件</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install --save-dev webpack //添加依赖 ，在package.json中声明依赖,等待安装完成</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-基本操作-webpack-main-js-webpack-js\"><a href=\"#2-基本操作-webpack-main-js-webpack-js\" class=\"headerlink\" title=\"2.基本操作$webpack main.js webpack.js\"></a>2.基本操作<code>$webpack main.js webpack.js</code></h2><p>当前目录下创建如下工作结构:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/---------test</span><br><span class=\"line\"></span><br><span class=\"line\">   ----app</span><br><span class=\"line\">     ----main.js</span><br><span class=\"line\">     ----index.js   </span><br><span class=\"line\">     </span><br><span class=\"line\">   ----index.html</span><br></pre></td></tr></table></figure>\n<p>项目目录下，app文件夹含有两个js文件，修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main.js ，这是Webpack主要的入口文件</span><br><span class=\"line\"></span><br><span class=\"line\">  require(&apos;./index.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//index.js ，这是被主文件引用的文件</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(&apos;Hello,world!&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//index.html ，供浏览器解读</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=&quot;./webpack.js&quot;&gt;  // 引用同目录下的webpack.js</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>webpack.js是哪来的呢？就是通过webpack打包生成的js文件，接下来，</p>\n<p>开始生成webpack.js文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack main.js webpack.js</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116202114667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>可以看到已经打包成功了，此时查看IDE中的项目目录，根目录下已经多了一个webpack.js文件。然后用浏览器打开index.html，效果如下：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116202235717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>此时查看网页源代码：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116202405946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>66666666666！</p>\n<h2 id=\"3-进阶操作-（配置webpack-config-js或者配置package-json，后者依赖前者）\"><a href=\"#3-进阶操作-（配置webpack-config-js或者配置package-json，后者依赖前者）\" class=\"headerlink\" title=\"3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）\"></a>3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）</h2><p>每次在命令行敲目录调试，是很痛苦的，因此需要一次配置，多次使用的方法。</p>\n<p>在根目录下新建文件： webpack.config.js  (名字就是这样，规定，不能改)，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports  = &#123;</span><br><span class=\"line\">//入口文件位置</span><br><span class=\"line\">    entry:__dirname+&apos;/app/main.js&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">//出口</span><br><span class=\"line\">    output:&#123;</span><br><span class=\"line\">   //路径</span><br><span class=\"line\">        path:__dirname,</span><br><span class=\"line\">        filename:&apos;webpack.js&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 __dirname是一个node的全局变量，用于指向当前的工作目录，调皮的我console.log了一下这个变量：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116203051747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>确认无疑。</p>\n<p>这样，我们的webpack.js写完以后，可以直接在命令行中敲：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br></pre></td></tr></table></figure>\n<p>可以发现，项目中也同样的会生成目标js文件，也就是webpack.js，这样非常方便，省事。 </p>\n<p>还有一种配置方法，将package.json文件中”scripts”里面添加键值对：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116203453509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>这样同样可以在项目目录生成目标js文件，直接在 命令行里敲</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start //因为webpack是全局安装的，直接value给webpack，而不用跟路径</span><br></pre></td></tr></table></figure>\n<p>如果start被占用了/冲突了，也可以在scripts下面自定义一个键值对：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;zq&quot;:&quot;webpack&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm run zq //稍作修改cmd 命令</span><br></pre></td></tr></table></figure>\n<p>最后还是可以生成。</p>\n<h2 id=\"4-webpack服务器监听代码变动，自动刷新及source-map\"><a href=\"#4-webpack服务器监听代码变动，自动刷新及source-map\" class=\"headerlink\" title=\"4.webpack服务器监听代码变动，自动刷新及source-map\"></a>4.webpack服务器监听代码变动，自动刷新及source-map</h2><p>4.1关于source-map，也就是在webpack.config.js中配置 devtool (develpment tool)的值，例如我这样配置：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117094811412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>在webpack完成文件打包后，会自动生成一个与目标文件相同名的 .map文件，用来说明打包文件的每个地方对应的是哪些文件，简而言之，让你能知道源码是在哪里错的，帮你刨根问底，而不用开发者自己去Debug。</p>\n<p>参考文章1：<a href=\"https://www.jianshu.com/p/42e11515c10f\" target=\"_blank\" rel=\"noopener\">入门WEBPACK，看这篇文章就够了—-简书</a></p>\n<p>参考文章2：<a href=\"https://www.cnblogs.com/axl234/p/6500534.html\" target=\"_blank\" rel=\"noopener\">Webpack中的sourcemap</a></p>\n<p>4.2 webpack服务器 </p>\n<p>首先单独安装 server 包 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>\n<p>同样的，在webpack.config.js中做出相应的配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    devtool: &apos;source-map&apos;,</span><br><span class=\"line\">    entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: __dirname,</span><br><span class=\"line\">        filename: &apos;bundle.js&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        contentBase: &quot;./&quot;,//本地服务器加载index.html页面所在的目录，这里写的是根目录</span><br><span class=\"line\">        historyApiFallback: true,//不跳转</span><br><span class=\"line\">        inline: true//实时刷新,</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置好config后，还得配置一下package.json，在scirpts里面添加server：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class=\"line\">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;, </span><br><span class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>接着，在命令行运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm run server </span><br><span class=\"line\"></span><br><span class=\"line\">/*届时服务器会自动启动， 并且打开浏览器,默认端口为8080，也可以</span><br><span class=\"line\">devServer:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">port:4040 //自己配置端口为4040</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是一个服务器跑起来后的演示结果，我不断的修改work.js 中 <code>document.write</code>的值，从而服务器会自动检测并刷新页面：</p>\n<p><img src=\"http://img.blog.csdn.net/20180117100531064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"5-非JS文件的操作-img-json-css……-猪脚：Loaders\"><a href=\"#5-非JS文件的操作-img-json-css……-猪脚：Loaders\" class=\"headerlink\" title=\"5.非JS文件的操作(img,json,css……),猪脚：Loaders\"></a>5.非JS文件的操作(img,json,css……),猪脚：Loaders</h2><p> <strong>5.0 基本概念</strong><br> 前面都在说js文件，官网说什么文件都可以当做模块打包，下面就来试试非js文件。</p>\n<p>首先要明确的是，webpack只能识别js文件，如果要识别非js文件，就需要loader来解析这些文件。</p>\n<p>loaders 需要单独安装，并且在webpack.config.js中的modules关键字下进行配置。</p>\n<p>Webpck2以上已经支持对json的解析打包，不需要额外的loaders，可以在main.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var json = require(&apos;../package.json&apos;)//json在它的上级目录</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(json.scripts.server);</span><br></pre></td></tr></table></figure>\n<p>运行结果 ：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117101705406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>可见，网页中，没有通过任何第三方loader，即可将json解析并打包成bundle.js。</p>\n<p><strong>5.1 Bable </strong><br>Bable可以使得开发者使用最新的ECMAscript标准来书写代码，而不用管新标准是否被当前使用的浏览器完全支持。</p>\n<p>还是需要单独安装Bable的包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev babel-core babel-loader babel-preset-env </span><br><span class=\"line\"></span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在webpack.config.js下的module关键字下进行配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &apos;source-map&apos;,</span><br><span class=\"line\">  </span><br><span class=\"line\">    entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        path: __dirname,</span><br><span class=\"line\">        </span><br><span class=\"line\">        filename: &apos;bundle.js&apos;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    devtool: &apos;eval-source-map&apos;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class=\"line\">        </span><br><span class=\"line\">        historyApiFallback: true,//不跳转</span><br><span class=\"line\">        </span><br><span class=\"line\">        inline: true//实时刷新</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">        </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">                test: /\\.js$/, //正则匹配，必须</span><br><span class=\"line\">                </span><br><span class=\"line\">                use: &#123; //使用到的loader</span><br><span class=\"line\">                </span><br><span class=\"line\">                    loader: &quot;babel-loader&quot;,  //loader名</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    options: &#123;   //选项</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        presets: [ //预先配置</span><br><span class=\"line\">                        </span><br><span class=\"line\">                            &quot;env&quot;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                </span><br><span class=\"line\">                exclude: /node_modules/ //不包含的目录或文件</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        ]</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>5.2 CSS文件处理 </strong><br>webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p>\n<p>同样先安装两个包 style-loader和css-loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">          &#123;.......&#125;，</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">                test: /\\.css$/,</span><br><span class=\"line\">                use: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        loader: &quot;style-loader&quot;</span><br><span class=\"line\">                    &#125;, &#123;</span><br><span class=\"line\">                        loader: &quot;css-loader&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">也可以简写：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">test:/\\.css$/.</span><br><span class=\"line\"></span><br><span class=\"line\">use:[&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">loader:&quot;style!css&quot;  //这里的执行顺序是从右往左，css应该在style之前执行</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>根目录下新建 ./src/index.css，写一个body的背景为green，然后在入口文件main.js中,require(‘../src/index.css’)，接着通过命令行<code>$ webpack</code></em><br>此时查看index.html，发现页面背景已经变成绿色<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117110627698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<h2 id=\"6-插件plugins\"><a href=\"#6-插件plugins\" class=\"headerlink\" title=\"6.插件plugins\"></a>6.插件plugins</h2><p>先安装插件的包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm install html-webpack-plugin</span><br></pre></td></tr></table></figure>\n<p>在webpack.config.js中 头部，引入依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let webpack = require(&apos;webpack&apos;);</span><br></pre></td></tr></table></figure>\n<p>然后在webpack.config.js中配置根键值对：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">      new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;)</span><br><span class=\"line\">  ],</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117111652412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/u014717036/article/details/51001311\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79078776\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a><br>前言：Webpack是一款基于node的前端打包工具，它可以将很多静态文件打包起来，自动处理依赖关系后，生成一个.js文件，然后让html来引用，不仅可以做到按需加载，而且可以减少HTTP请求，节约带宽。</p>\n<h2 id=\"1-配置与安装\"><a href=\"#1-配置与安装\" class=\"headerlink\" title=\"1.配置与安装\"></a>1.配置与安装</h2><p>在node已经安装完成的前提下，全局安装webpack</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd d:</span><br><span class=\"line\"></span><br><span class=\"line\">$ mkdir test &amp;&amp; cd test  //创建test ，并进入</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install -g webpack  //等待100s，安装完成，也可以使用淘宝镜像</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm init //初始化package.json文件</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install --save-dev webpack //添加依赖 ，在package.json中声明依赖,等待安装完成</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-基本操作-webpack-main-js-webpack-js\"><a href=\"#2-基本操作-webpack-main-js-webpack-js\" class=\"headerlink\" title=\"2.基本操作$webpack main.js webpack.js\"></a>2.基本操作<code>$webpack main.js webpack.js</code></h2><p>当前目录下创建如下工作结构:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/---------test</span><br><span class=\"line\"></span><br><span class=\"line\">   ----app</span><br><span class=\"line\">     ----main.js</span><br><span class=\"line\">     ----index.js   </span><br><span class=\"line\">     </span><br><span class=\"line\">   ----index.html</span><br></pre></td></tr></table></figure>\n<p>项目目录下，app文件夹含有两个js文件，修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main.js ，这是Webpack主要的入口文件</span><br><span class=\"line\"></span><br><span class=\"line\">  require(&apos;./index.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//index.js ，这是被主文件引用的文件</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(&apos;Hello,world!&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//index.html ，供浏览器解读</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=&quot;./webpack.js&quot;&gt;  // 引用同目录下的webpack.js</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>webpack.js是哪来的呢？就是通过webpack打包生成的js文件，接下来，</p>\n<p>开始生成webpack.js文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack main.js webpack.js</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116202114667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>可以看到已经打包成功了，此时查看IDE中的项目目录，根目录下已经多了一个webpack.js文件。然后用浏览器打开index.html，效果如下：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116202235717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>此时查看网页源代码：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116202405946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>66666666666！</p>\n<h2 id=\"3-进阶操作-（配置webpack-config-js或者配置package-json，后者依赖前者）\"><a href=\"#3-进阶操作-（配置webpack-config-js或者配置package-json，后者依赖前者）\" class=\"headerlink\" title=\"3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）\"></a>3.进阶操作 （配置webpack.config.js或者配置package.json，后者依赖前者）</h2><p>每次在命令行敲目录调试，是很痛苦的，因此需要一次配置，多次使用的方法。</p>\n<p>在根目录下新建文件： webpack.config.js  (名字就是这样，规定，不能改)，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports  = &#123;</span><br><span class=\"line\">//入口文件位置</span><br><span class=\"line\">    entry:__dirname+&apos;/app/main.js&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">//出口</span><br><span class=\"line\">    output:&#123;</span><br><span class=\"line\">   //路径</span><br><span class=\"line\">        path:__dirname,</span><br><span class=\"line\">        filename:&apos;webpack.js&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 __dirname是一个node的全局变量，用于指向当前的工作目录，调皮的我console.log了一下这个变量：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116203051747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>确认无疑。</p>\n<p>这样，我们的webpack.js写完以后，可以直接在命令行中敲：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br></pre></td></tr></table></figure>\n<p>可以发现，项目中也同样的会生成目标js文件，也就是webpack.js，这样非常方便，省事。 </p>\n<p>还有一种配置方法，将package.json文件中”scripts”里面添加键值对：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180116203453509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>这样同样可以在项目目录生成目标js文件，直接在 命令行里敲</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start //因为webpack是全局安装的，直接value给webpack，而不用跟路径</span><br></pre></td></tr></table></figure>\n<p>如果start被占用了/冲突了，也可以在scripts下面自定义一个键值对：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;zq&quot;:&quot;webpack&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm run zq //稍作修改cmd 命令</span><br></pre></td></tr></table></figure>\n<p>最后还是可以生成。</p>\n<h2 id=\"4-webpack服务器监听代码变动，自动刷新及source-map\"><a href=\"#4-webpack服务器监听代码变动，自动刷新及source-map\" class=\"headerlink\" title=\"4.webpack服务器监听代码变动，自动刷新及source-map\"></a>4.webpack服务器监听代码变动，自动刷新及source-map</h2><p>4.1关于source-map，也就是在webpack.config.js中配置 devtool (develpment tool)的值，例如我这样配置：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117094811412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>在webpack完成文件打包后，会自动生成一个与目标文件相同名的 .map文件，用来说明打包文件的每个地方对应的是哪些文件，简而言之，让你能知道源码是在哪里错的，帮你刨根问底，而不用开发者自己去Debug。</p>\n<p>参考文章1：<a href=\"https://www.jianshu.com/p/42e11515c10f\" target=\"_blank\" rel=\"noopener\">入门WEBPACK，看这篇文章就够了—-简书</a></p>\n<p>参考文章2：<a href=\"https://www.cnblogs.com/axl234/p/6500534.html\" target=\"_blank\" rel=\"noopener\">Webpack中的sourcemap</a></p>\n<p>4.2 webpack服务器 </p>\n<p>首先单独安装 server 包 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>\n<p>同样的，在webpack.config.js中做出相应的配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    devtool: &apos;source-map&apos;,</span><br><span class=\"line\">    entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: __dirname,</span><br><span class=\"line\">        filename: &apos;bundle.js&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        contentBase: &quot;./&quot;,//本地服务器加载index.html页面所在的目录，这里写的是根目录</span><br><span class=\"line\">        historyApiFallback: true,//不跳转</span><br><span class=\"line\">        inline: true//实时刷新,</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置好config后，还得配置一下package.json，在scirpts里面添加server：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class=\"line\">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;, </span><br><span class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<p>接着，在命令行运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm run server </span><br><span class=\"line\"></span><br><span class=\"line\">/*届时服务器会自动启动， 并且打开浏览器,默认端口为8080，也可以</span><br><span class=\"line\">devServer:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">port:4040 //自己配置端口为4040</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是一个服务器跑起来后的演示结果，我不断的修改work.js 中 <code>document.write</code>的值，从而服务器会自动检测并刷新页面：</p>\n<p><img src=\"http://img.blog.csdn.net/20180117100531064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"5-非JS文件的操作-img-json-css……-猪脚：Loaders\"><a href=\"#5-非JS文件的操作-img-json-css……-猪脚：Loaders\" class=\"headerlink\" title=\"5.非JS文件的操作(img,json,css……),猪脚：Loaders\"></a>5.非JS文件的操作(img,json,css……),猪脚：Loaders</h2><p> <strong>5.0 基本概念</strong><br> 前面都在说js文件，官网说什么文件都可以当做模块打包，下面就来试试非js文件。</p>\n<p>首先要明确的是，webpack只能识别js文件，如果要识别非js文件，就需要loader来解析这些文件。</p>\n<p>loaders 需要单独安装，并且在webpack.config.js中的modules关键字下进行配置。</p>\n<p>Webpck2以上已经支持对json的解析打包，不需要额外的loaders，可以在main.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var json = require(&apos;../package.json&apos;)//json在它的上级目录</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(json.scripts.server);</span><br></pre></td></tr></table></figure>\n<p>运行结果 ：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117101705406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>可见，网页中，没有通过任何第三方loader，即可将json解析并打包成bundle.js。</p>\n<p><strong>5.1 Bable </strong><br>Bable可以使得开发者使用最新的ECMAscript标准来书写代码，而不用管新标准是否被当前使用的浏览器完全支持。</p>\n<p>还是需要单独安装Bable的包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev babel-core babel-loader babel-preset-env </span><br><span class=\"line\"></span><br><span class=\"line\">/</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在webpack.config.js下的module关键字下进行配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  devtool: &apos;source-map&apos;,</span><br><span class=\"line\">  </span><br><span class=\"line\">    entry: __dirname + &quot;/app/main.js&quot;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        path: __dirname,</span><br><span class=\"line\">        </span><br><span class=\"line\">        filename: &apos;bundle.js&apos;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    devtool: &apos;eval-source-map&apos;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class=\"line\">        </span><br><span class=\"line\">        historyApiFallback: true,//不跳转</span><br><span class=\"line\">        </span><br><span class=\"line\">        inline: true//实时刷新</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">        </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">                test: /\\.js$/, //正则匹配，必须</span><br><span class=\"line\">                </span><br><span class=\"line\">                use: &#123; //使用到的loader</span><br><span class=\"line\">                </span><br><span class=\"line\">                    loader: &quot;babel-loader&quot;,  //loader名</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    options: &#123;   //选项</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        presets: [ //预先配置</span><br><span class=\"line\">                        </span><br><span class=\"line\">                            &quot;env&quot;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                </span><br><span class=\"line\">                exclude: /node_modules/ //不包含的目录或文件</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        ]</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>5.2 CSS文件处理 </strong><br>webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p>\n<p>同样先安装两个包 style-loader和css-loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">          &#123;.......&#125;，</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">                test: /\\.css$/,</span><br><span class=\"line\">                use: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        loader: &quot;style-loader&quot;</span><br><span class=\"line\">                    &#125;, &#123;</span><br><span class=\"line\">                        loader: &quot;css-loader&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">也可以简写：</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">test:/\\.css$/.</span><br><span class=\"line\"></span><br><span class=\"line\">use:[&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">loader:&quot;style!css&quot;  //这里的执行顺序是从右往左，css应该在style之前执行</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>根目录下新建 ./src/index.css，写一个body的背景为green，然后在入口文件main.js中,require(‘../src/index.css’)，接着通过命令行<code>$ webpack</code></em><br>此时查看index.html，发现页面背景已经变成绿色<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117110627698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<h2 id=\"6-插件plugins\"><a href=\"#6-插件plugins\" class=\"headerlink\" title=\"6.插件plugins\"></a>6.插件plugins</h2><p>先安装插件的包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm install html-webpack-plugin</span><br></pre></td></tr></table></figure>\n<p>在webpack.config.js中 头部，引入依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let webpack = require(&apos;webpack&apos;);</span><br></pre></td></tr></table></figure>\n<p>然后在webpack.config.js中配置根键值对：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">      new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;)</span><br><span class=\"line\">  ],</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180117111652412?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"ajax回顾","date":"2017-12-12T09:04:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78781917)\n\n\n## **jq与原生以及angular中的ajax（长文）**##\n\nhttp://blog.csdn.net/qq_20264891/article/details/78457021\n\n上面是之前写的一篇关于ajax的帖子，里面的集成包xampp的配置方法有点不太科学，\n\n虽然这样可以运行，但感觉不是很美滋滋。\n\n感谢新浪博主@期待下一站幸福\n\n具体参考原文地址：http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html\n\n\n\n配置外部服务器，运行后端代码php？\n对于完全是小白的我而言，实在是想都不敢想。因为得学习Ajax，就必须得给服务器的发送请求和等待服务器响。所以就在老师的带领下，开始了服务器的配置。\n\n首先介绍一下，我用的IDE:​HBuilder. 后端语言是php。\n\n我使用的是模拟服务器的软件：XAMPP​\n\n(下载地址：https://www.apachefriends.org/download.html)\n\n然后说一下，我要做什么样的效果：\n\n让一个PHP文件在本地服务器上运行。（对！就是这么简单，我捣鼓了一个多小时...）​\n\n\n好了，接下来我们来看看吧。\n\n\n​\n\n1,安装一个模拟的服务器。\n\n如果你和我一样，没有任何的​Apache，MySQL，tomcat等WEB服务器。那就下载一个XAMPP.【好用于部署一个本地服务器】\n\n​安装完成后，打开的界面是这样子的：\n![这里写图片描述](http://img.blog.csdn.net/20171212150943894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n我们可以先点击“start”启动，这时候需要注意的是：可能出现错误。【错误是：端口被占用】。\n\n> ![引用块内容](http://img.blog.csdn.net/20171212151012172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n解决方法是：点击config--进入Apache（httpd.conf）--找到listen（监听的端口号）进行修改。如图：\n![这里写图片描述](http://img.blog.csdn.net/20171212151304609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n好了，可以重新启动Apache啦。\n\n**2.打开HBuilder，然后新建一个项目。**\n\n注意：新建的项目---一定要在我们刚刚打开的XMAPP安装目录下的​htdocs文件夹下面。\n\n（不要问为啥，这是我一晚上调试出来的经验）​\n![这里写图片描述](http://img.blog.csdn.net/20171212151354297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n﻿在安装目录下的htdocs，新建文件\n\n3.在HBuilder中的快捷工具栏中找到【浏览器】，打开它的下拉菜单，点击【设置web服务器】。\n\n进入页面点击”外置web服务器“​--选择”新建“\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151434576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151454782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n添加本地服务器\n\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151518701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n4.把你写的PHP文件可以在浏览器中，打开了。\n\n这是我的源文件：\n![这里写图片描述](http://img.blog.csdn.net/20171212151552039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151609984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n***OK,接下来才是正文：***\n==\n\n**一、javaScript原生Ajax**\n==\n\n**1.浏览器自带的与服务器交互的对象及附带API**\n\n**该对象是一个全局对象，即位于window对象下。IE与非IE，该对象不同**\n\n非IE && IE7+ : XMLHttpRequest\n\nIE5,IE6: ActiveXObject\n\n**2.兼容创建大法**\n\n```\nvar xhr=null;//初始化变量\n\nif(window.XMLHttpRequest){\n//非IE&&IE7+\n\nxhr = new XMLHttpRequest();\n}\nelse if(window.ActiveXObject){\n\nxhr = new ActiveXObject(\"Microsoft.XMLHTTP\");//不同的IE版本，里面写的东西不一样，具体请自行baidu\n\n}\n```\n**3.创建好之后的后续步骤**\n\nxhr.open()  //该方法用于 **创建**  连接服务端的请求。\n\nxhr.send();  //所有的事情完毕，正式发送请求。\n\n注意：\n\nxhr.open(method,url,async)  请求方式，请求地址，是否异步？(ps:默认为true,异步执行)\n\n设置好open中的传参，接着执行xhr.send()。\n\n**4.如何知道请求与相应成功不成功？？**\n\n这里，xhr对象自带 一个方法，用来检测连接是否成功，以及对xhr创建过程进行监听，\n\n为什么这样说呢？直接看代码：\n\n```\n xhr.onreadystatechange=function(){\n    \n    \tif(xhr.readyState=4&&xhr.status==200){\n    \t\t\n    \t\tdocument.getElementById('box').innerHTML = xhr.responseText;\n    \t}\n    }\n***************上面界定了，请求成功以后，将响应的内容放在我们的box盒子里********\n\n\txhr.open(\"GET\",\"01.php?a=5&b=1\",true);//传参a=5,b=1\n\txhr.send(); \n\t\n//因为上面的方法是异步执行的，因此不用纠结，xhr.open()和send()的位置。\n\n}\n```\n运行结果:\n![这里写图片描述](http://img.blog.csdn.net/20171212145801095?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n附上php的代码：\n\n```\n<?php\necho  \"a为{$_GET['a']},那么b为{$_GET['b']}\"  \n?>\n```\n这里php代码看不懂的话， 可以去http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP 的基本语法。作为一个前端，后端语言要了解其接口和语法，这是最起码的(这个B装的66666)。\n\n\n**说好的监听xhr对象的创建过程呢？**\n```\nxhr.onreadystatechange = function(){\n//这里加上一句话  :\nconsole.log(\"当前的XMLHttpRequest对象的创建进度为\"+xhr.readyState)\n...\n...\n }\n```\n来看打印结果:\n![这里写图片描述](http://img.blog.csdn.net/20171212150218442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可见，每次xhr对象自身状态值改变，都会调用函数，因此导致我们打印的结果发生变化。  由此可得，ajax的创建是分步进行的，查询资料可得：\n\n - 0 对象未创建\n - 1 已与服务器连接\n - 2 服务器已经接受请求\n - 3 服务器正在处理请求\n - 4 服务器将请求下发\n **同时，status也需要有响应的返回值，从服务器传递回来，有个状态值(xhr.status)： **\n如果响应成功，就返回200\n如果没找到，返回404\n其他还有403,5系列等等，不再赘述。\n\n**二、jQuery中的ajax**\n==\n1.load方法\n\n```\n兹有按钮与容器各一个：\n\n<input type=\"button\" value=\"点我加载\" id=\"btn\"/>\n\n<div id=\"box\"></div>\n\n//js如下\n\n\t<script type=\"text/javascript\">\n\t\n\t\t$('#btn').click(function(){\n\t\t\t$('#box').load('03.php')\n\n\t</script>\n\t\n//php如下\n\n<?php\necho \"hello,world!<br/>a  =  {$_POST['a']}<br/>b  =   {$_POST['b']}\"\n?>\n```\n这里，点击按钮，box载入响应值，这个方法是get方法。\n如图：![这里写图片描述](http://img.blog.csdn.net/20171212153748919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n如果，在load()多传一个json对象:\n\n```\n$('#box').load('03.php',{\n\t\t\t\ta:5,\n\t\t\t\tb:1\n\t\t\t})\n```\n那么这个请求会自动 变成post请求。\n![这里写图片描述](http://img.blog.csdn.net/20171212153930619?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在 Ajax数据载入完毕之后，就能执行回调函数 callback，也就是第三个参数。回调函数\n也可以传递三个可选参数：responseText（请求返回）、textStatus（请求状态)、XMLHttpRequest对象。\n\n```\n$('#btn').click(function () {\n  $('#box').load('03.php', {\n       a:5,\n       b:1\n  }, function (response, status, xhr) {\n        alert('返回的值为：' + response + '，状态为：' + status + '，\n           状态是：' + xhr.statusText);\n  });\n});\n```\n运行结果：\n![这里写图片描述](http://img.blog.csdn.net/20171212154422827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这里的status和xhr.statusText都是经过jQuery进行处理的，原本的值应该对应为：\n200 \n**2.`$.get()和$.post()`**\n\n.load()方法是局部方法，因为他需要一个包含元素的 jQuery对象作为前缀。而$.get()和\n$.post()是全局方法，无须指定某个元素。对于用途而言，.load()适合做静态文件的异步获取，\n而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。\n\n```\n$('#btn').click($.get(url,{json.data},callback(),type){})\n\n/*GET方法与load()方法相比，多了最后一个参数，返回类型，可以设置为\nxml,html,json,text等，一般不需要设置，都是jQuery智能判断返回的。第一个参数：请求\n地址，是必须的，后面的都是可选参数。\n*/\n```\n**`$.post()方法`**\n\n的使用和`$.get()`基本上一致，他们之间的区别也比较隐晦，基本都是背后的\n\n不同，在用户使用上体现不出。具体区别如下：\n\n1.GET请求是通过  URL提交的，而 POST请求则是  HTTP消息实体提交的；\n\n2.GET提交有大小限制（2KB），而  POST方式不受限制；\n\n3.GET方式会被缓存下来，可能有安全性问题，而  POST没有这个问题；\n\n4.GET方式通过`$_GET[]`获取，POST方式通过`$_POST[]`获取。\n**3.`load(),$.get(),$.post()` **的集合：$.ajax\n\n```\n//ajax是jQuery封装的最底层的方法\n\t\t$('btn[submit]')[0].click(function(){\n\t\t\t$.ajax({\n\t\t\t\ttype:\"get\",    //请求方式\n\t\t\t\turl:\"02.php\",  //地址\n\t\t\t\tasync:true,      //异步\n\t\t\t\tsuccess:function(response,status,xhr){alert(response)}, //成功回调函数\n\t\t\t\terror:function(){},//失败回调\n\t\t\t\tdata:$('form').serialize()//表单序列化\n\t\t\t});\n\t\t\t\n\n\t\t})\n```\n\n**三、AngularJs中的ajax**\n==\n\n\n```\n在任一一个控制器中注入http依赖\n\nvar app = angular.module('myApp',[]);\n\n\n//http模块注入到任一一个控制器中\n\napp.controller('ctrl1',function($scope,$http){\n\n$http({ \n\n    method: 'GET', //选择请求方式\n    \n    url: '02.php' //请求地址\n    \n}).then(function successCallback(response) {\n\n        // 请求成功执行代码\n    }, function errorCallback(response) {\n    \n        // 请求失败执行代码\n//语法为：$http.then(success(),fail())\n});\n\n\n\n```\n**声明：v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代。因此千万不要**\n\n```\n$http.success().error()//错误写法！z不能跟jQuery混淆\n```\n\n总结：\n==\nJs/jq/angularjs 中ajax的：\n\n\n**相同点**\n1.都是异步的请求，都支持get,post方法,jq,angular支持(put)。\n\n\n**不同点：**\n\n1.jq中，对于ajax请求的写法非常简单，非常直观。angular中，通过$http模块也进行相应的封装，非常方便。\n\n2.普通的javaScript AJAX请求，如果需要GET方法传参，只能强行用\"？\"追加到url后面，并且不同参数连接要用&进行，非常繁琐。\n\n3.所谓jq的success(),error()，以及angular的then方法，都是对原生ajax的\n\nstatus的不同返回值进行封装,例如：200就会执行success函数，404就执行error函数。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/ajax回顾.md","raw":"---\ntitle:  ajax回顾 \ndate: 2017-12-12 17:04:00\ntags: ajax\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78781917)\n\n\n## **jq与原生以及angular中的ajax（长文）**##\n\nhttp://blog.csdn.net/qq_20264891/article/details/78457021\n\n上面是之前写的一篇关于ajax的帖子，里面的集成包xampp的配置方法有点不太科学，\n\n虽然这样可以运行，但感觉不是很美滋滋。\n\n感谢新浪博主@期待下一站幸福\n\n具体参考原文地址：http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html\n\n\n\n配置外部服务器，运行后端代码php？\n对于完全是小白的我而言，实在是想都不敢想。因为得学习Ajax，就必须得给服务器的发送请求和等待服务器响。所以就在老师的带领下，开始了服务器的配置。\n\n首先介绍一下，我用的IDE:​HBuilder. 后端语言是php。\n\n我使用的是模拟服务器的软件：XAMPP​\n\n(下载地址：https://www.apachefriends.org/download.html)\n\n然后说一下，我要做什么样的效果：\n\n让一个PHP文件在本地服务器上运行。（对！就是这么简单，我捣鼓了一个多小时...）​\n\n\n好了，接下来我们来看看吧。\n\n\n​\n\n1,安装一个模拟的服务器。\n\n如果你和我一样，没有任何的​Apache，MySQL，tomcat等WEB服务器。那就下载一个XAMPP.【好用于部署一个本地服务器】\n\n​安装完成后，打开的界面是这样子的：\n![这里写图片描述](http://img.blog.csdn.net/20171212150943894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n我们可以先点击“start”启动，这时候需要注意的是：可能出现错误。【错误是：端口被占用】。\n\n> ![引用块内容](http://img.blog.csdn.net/20171212151012172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n解决方法是：点击config--进入Apache（httpd.conf）--找到listen（监听的端口号）进行修改。如图：\n![这里写图片描述](http://img.blog.csdn.net/20171212151304609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n好了，可以重新启动Apache啦。\n\n**2.打开HBuilder，然后新建一个项目。**\n\n注意：新建的项目---一定要在我们刚刚打开的XMAPP安装目录下的​htdocs文件夹下面。\n\n（不要问为啥，这是我一晚上调试出来的经验）​\n![这里写图片描述](http://img.blog.csdn.net/20171212151354297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n﻿在安装目录下的htdocs，新建文件\n\n3.在HBuilder中的快捷工具栏中找到【浏览器】，打开它的下拉菜单，点击【设置web服务器】。\n\n进入页面点击”外置web服务器“​--选择”新建“\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151434576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151454782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n添加本地服务器\n\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151518701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n4.把你写的PHP文件可以在浏览器中，打开了。\n\n这是我的源文件：\n![这里写图片描述](http://img.blog.csdn.net/20171212151552039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n![这里写图片描述](http://img.blog.csdn.net/20171212151609984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n***OK,接下来才是正文：***\n==\n\n**一、javaScript原生Ajax**\n==\n\n**1.浏览器自带的与服务器交互的对象及附带API**\n\n**该对象是一个全局对象，即位于window对象下。IE与非IE，该对象不同**\n\n非IE && IE7+ : XMLHttpRequest\n\nIE5,IE6: ActiveXObject\n\n**2.兼容创建大法**\n\n```\nvar xhr=null;//初始化变量\n\nif(window.XMLHttpRequest){\n//非IE&&IE7+\n\nxhr = new XMLHttpRequest();\n}\nelse if(window.ActiveXObject){\n\nxhr = new ActiveXObject(\"Microsoft.XMLHTTP\");//不同的IE版本，里面写的东西不一样，具体请自行baidu\n\n}\n```\n**3.创建好之后的后续步骤**\n\nxhr.open()  //该方法用于 **创建**  连接服务端的请求。\n\nxhr.send();  //所有的事情完毕，正式发送请求。\n\n注意：\n\nxhr.open(method,url,async)  请求方式，请求地址，是否异步？(ps:默认为true,异步执行)\n\n设置好open中的传参，接着执行xhr.send()。\n\n**4.如何知道请求与相应成功不成功？？**\n\n这里，xhr对象自带 一个方法，用来检测连接是否成功，以及对xhr创建过程进行监听，\n\n为什么这样说呢？直接看代码：\n\n```\n xhr.onreadystatechange=function(){\n    \n    \tif(xhr.readyState=4&&xhr.status==200){\n    \t\t\n    \t\tdocument.getElementById('box').innerHTML = xhr.responseText;\n    \t}\n    }\n***************上面界定了，请求成功以后，将响应的内容放在我们的box盒子里********\n\n\txhr.open(\"GET\",\"01.php?a=5&b=1\",true);//传参a=5,b=1\n\txhr.send(); \n\t\n//因为上面的方法是异步执行的，因此不用纠结，xhr.open()和send()的位置。\n\n}\n```\n运行结果:\n![这里写图片描述](http://img.blog.csdn.net/20171212145801095?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n附上php的代码：\n\n```\n<?php\necho  \"a为{$_GET['a']},那么b为{$_GET['b']}\"  \n?>\n```\n这里php代码看不懂的话， 可以去http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP 的基本语法。作为一个前端，后端语言要了解其接口和语法，这是最起码的(这个B装的66666)。\n\n\n**说好的监听xhr对象的创建过程呢？**\n```\nxhr.onreadystatechange = function(){\n//这里加上一句话  :\nconsole.log(\"当前的XMLHttpRequest对象的创建进度为\"+xhr.readyState)\n...\n...\n }\n```\n来看打印结果:\n![这里写图片描述](http://img.blog.csdn.net/20171212150218442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可见，每次xhr对象自身状态值改变，都会调用函数，因此导致我们打印的结果发生变化。  由此可得，ajax的创建是分步进行的，查询资料可得：\n\n - 0 对象未创建\n - 1 已与服务器连接\n - 2 服务器已经接受请求\n - 3 服务器正在处理请求\n - 4 服务器将请求下发\n **同时，status也需要有响应的返回值，从服务器传递回来，有个状态值(xhr.status)： **\n如果响应成功，就返回200\n如果没找到，返回404\n其他还有403,5系列等等，不再赘述。\n\n**二、jQuery中的ajax**\n==\n1.load方法\n\n```\n兹有按钮与容器各一个：\n\n<input type=\"button\" value=\"点我加载\" id=\"btn\"/>\n\n<div id=\"box\"></div>\n\n//js如下\n\n\t<script type=\"text/javascript\">\n\t\n\t\t$('#btn').click(function(){\n\t\t\t$('#box').load('03.php')\n\n\t</script>\n\t\n//php如下\n\n<?php\necho \"hello,world!<br/>a  =  {$_POST['a']}<br/>b  =   {$_POST['b']}\"\n?>\n```\n这里，点击按钮，box载入响应值，这个方法是get方法。\n如图：![这里写图片描述](http://img.blog.csdn.net/20171212153748919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n如果，在load()多传一个json对象:\n\n```\n$('#box').load('03.php',{\n\t\t\t\ta:5,\n\t\t\t\tb:1\n\t\t\t})\n```\n那么这个请求会自动 变成post请求。\n![这里写图片描述](http://img.blog.csdn.net/20171212153930619?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在 Ajax数据载入完毕之后，就能执行回调函数 callback，也就是第三个参数。回调函数\n也可以传递三个可选参数：responseText（请求返回）、textStatus（请求状态)、XMLHttpRequest对象。\n\n```\n$('#btn').click(function () {\n  $('#box').load('03.php', {\n       a:5,\n       b:1\n  }, function (response, status, xhr) {\n        alert('返回的值为：' + response + '，状态为：' + status + '，\n           状态是：' + xhr.statusText);\n  });\n});\n```\n运行结果：\n![这里写图片描述](http://img.blog.csdn.net/20171212154422827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这里的status和xhr.statusText都是经过jQuery进行处理的，原本的值应该对应为：\n200 \n**2.`$.get()和$.post()`**\n\n.load()方法是局部方法，因为他需要一个包含元素的 jQuery对象作为前缀。而$.get()和\n$.post()是全局方法，无须指定某个元素。对于用途而言，.load()适合做静态文件的异步获取，\n而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。\n\n```\n$('#btn').click($.get(url,{json.data},callback(),type){})\n\n/*GET方法与load()方法相比，多了最后一个参数，返回类型，可以设置为\nxml,html,json,text等，一般不需要设置，都是jQuery智能判断返回的。第一个参数：请求\n地址，是必须的，后面的都是可选参数。\n*/\n```\n**`$.post()方法`**\n\n的使用和`$.get()`基本上一致，他们之间的区别也比较隐晦，基本都是背后的\n\n不同，在用户使用上体现不出。具体区别如下：\n\n1.GET请求是通过  URL提交的，而 POST请求则是  HTTP消息实体提交的；\n\n2.GET提交有大小限制（2KB），而  POST方式不受限制；\n\n3.GET方式会被缓存下来，可能有安全性问题，而  POST没有这个问题；\n\n4.GET方式通过`$_GET[]`获取，POST方式通过`$_POST[]`获取。\n**3.`load(),$.get(),$.post()` **的集合：$.ajax\n\n```\n//ajax是jQuery封装的最底层的方法\n\t\t$('btn[submit]')[0].click(function(){\n\t\t\t$.ajax({\n\t\t\t\ttype:\"get\",    //请求方式\n\t\t\t\turl:\"02.php\",  //地址\n\t\t\t\tasync:true,      //异步\n\t\t\t\tsuccess:function(response,status,xhr){alert(response)}, //成功回调函数\n\t\t\t\terror:function(){},//失败回调\n\t\t\t\tdata:$('form').serialize()//表单序列化\n\t\t\t});\n\t\t\t\n\n\t\t})\n```\n\n**三、AngularJs中的ajax**\n==\n\n\n```\n在任一一个控制器中注入http依赖\n\nvar app = angular.module('myApp',[]);\n\n\n//http模块注入到任一一个控制器中\n\napp.controller('ctrl1',function($scope,$http){\n\n$http({ \n\n    method: 'GET', //选择请求方式\n    \n    url: '02.php' //请求地址\n    \n}).then(function successCallback(response) {\n\n        // 请求成功执行代码\n    }, function errorCallback(response) {\n    \n        // 请求失败执行代码\n//语法为：$http.then(success(),fail())\n});\n\n\n\n```\n**声明：v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代。因此千万不要**\n\n```\n$http.success().error()//错误写法！z不能跟jQuery混淆\n```\n\n总结：\n==\nJs/jq/angularjs 中ajax的：\n\n\n**相同点**\n1.都是异步的请求，都支持get,post方法,jq,angular支持(put)。\n\n\n**不同点：**\n\n1.jq中，对于ajax请求的写法非常简单，非常直观。angular中，通过$http模块也进行相应的封装，非常方便。\n\n2.普通的javaScript AJAX请求，如果需要GET方法传参，只能强行用\"？\"追加到url后面，并且不同参数连接要用&进行，非常繁琐。\n\n3.所谓jq的success(),error()，以及angular的then方法，都是对原生ajax的\n\nstatus的不同返回值进行封装,例如：200就会执行success函数，404就执行error函数。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"ajax回顾","published":1,"updated":"2018-08-29T05:59:20.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfr000xjgv45vkx1x2u","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78781917\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"jq与原生以及angular中的ajax（长文）\"><a href=\"#jq与原生以及angular中的ajax（长文）\" class=\"headerlink\" title=\"jq与原生以及angular中的ajax（长文）\"></a><strong>jq与原生以及angular中的ajax（长文）</strong></h2><p><a href=\"http://blog.csdn.net/qq_20264891/article/details/78457021\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20264891/article/details/78457021</a></p>\n<p>上面是之前写的一篇关于ajax的帖子，里面的集成包xampp的配置方法有点不太科学，</p>\n<p>虽然这样可以运行，但感觉不是很美滋滋。</p>\n<p>感谢新浪博主@期待下一站幸福</p>\n<p>具体参考原文地址：<a href=\"http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html</a></p>\n<p>配置外部服务器，运行后端代码php？<br>对于完全是小白的我而言，实在是想都不敢想。因为得学习Ajax，就必须得给服务器的发送请求和等待服务器响。所以就在老师的带领下，开始了服务器的配置。</p>\n<p>首先介绍一下，我用的IDE:​HBuilder. 后端语言是php。</p>\n<p>我使用的是模拟服务器的软件：XAMPP​</p>\n<p>(下载地址：<a href=\"https://www.apachefriends.org/download.html\" target=\"_blank\" rel=\"noopener\">https://www.apachefriends.org/download.html</a>)</p>\n<p>然后说一下，我要做什么样的效果：</p>\n<p>让一个PHP文件在本地服务器上运行。（对！就是这么简单，我捣鼓了一个多小时…）​</p>\n<p>好了，接下来我们来看看吧。</p>\n<p>​</p>\n<p>1,安装一个模拟的服务器。</p>\n<p>如果你和我一样，没有任何的​Apache，MySQL，tomcat等WEB服务器。那就下载一个XAMPP.【好用于部署一个本地服务器】</p>\n<p>​安装完成后，打开的界面是这样子的：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212150943894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>我们可以先点击“start”启动，这时候需要注意的是：可能出现错误。【错误是：端口被占用】。</p>\n<blockquote>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151012172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用块内容\" title=\"\" class=\"\">\n                <p>引用块内容</p>\n            </figure>\n</blockquote>\n<p>解决方法是：点击config–进入Apache（httpd.conf）–找到listen（监听的端口号）进行修改。如图：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151304609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>好了，可以重新启动Apache啦。</p>\n<p><strong>2.打开HBuilder，然后新建一个项目。</strong></p>\n<p>注意：新建的项目—一定要在我们刚刚打开的XMAPP安装目录下的​htdocs文件夹下面。</p>\n<p>（不要问为啥，这是我一晚上调试出来的经验）​<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151354297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>﻿在安装目录下的htdocs，新建文件</p>\n<p>3.在HBuilder中的快捷工具栏中找到【浏览器】，打开它的下拉菜单，点击【设置web服务器】。</p>\n<p>进入页面点击”外置web服务器“​–选择”新建“</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151434576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151454782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>添加本地服务器</p>\n<p><img src=\"http://img.blog.csdn.net/20171212151518701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>4.把你写的PHP文件可以在浏览器中，打开了。</p>\n<p>这是我的源文件：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151552039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151609984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h1 id=\"OK-接下来才是正文：\"><a href=\"#OK-接下来才是正文：\" class=\"headerlink\" title=\"OK,接下来才是正文：\"></a><strong><em>OK,接下来才是正文：</em></strong></h1><h1 id=\"一、javaScript原生Ajax\"><a href=\"#一、javaScript原生Ajax\" class=\"headerlink\" title=\"一、javaScript原生Ajax\"></a><strong>一、javaScript原生Ajax</strong></h1><p><strong>1.浏览器自带的与服务器交互的对象及附带API</strong></p>\n<p><strong>该对象是一个全局对象，即位于window对象下。IE与非IE，该对象不同</strong></p>\n<p>非IE &amp;&amp; IE7+ : XMLHttpRequest</p>\n<p>IE5,IE6: ActiveXObject</p>\n<p><strong>2.兼容创建大法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr=null;//初始化变量</span><br><span class=\"line\"></span><br><span class=\"line\">if(window.XMLHttpRequest)&#123;</span><br><span class=\"line\">//非IE&amp;&amp;IE7+</span><br><span class=\"line\"></span><br><span class=\"line\">xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if(window.ActiveXObject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//不同的IE版本，里面写的东西不一样，具体请自行baidu</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3.创建好之后的后续步骤</strong></p>\n<p>xhr.open()  //该方法用于 <strong>创建</strong>  连接服务端的请求。</p>\n<p>xhr.send();  //所有的事情完毕，正式发送请求。</p>\n<p>注意：</p>\n<p>xhr.open(method,url,async)  请求方式，请求地址，是否异步？(ps:默认为true,异步执行)</p>\n<p>设置好open中的传参，接着执行xhr.send()。</p>\n<p><strong>4.如何知道请求与相应成功不成功？？</strong></p>\n<p>这里，xhr对象自带 一个方法，用来检测连接是否成功，以及对xhr创建过程进行监听，</p>\n<p>为什么这样说呢？直接看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \tif(xhr.readyState=4&amp;&amp;xhr.status==200)&#123;</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">    \t\tdocument.getElementById(&apos;box&apos;).innerHTML = xhr.responseText;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">***************上面界定了，请求成功以后，将响应的内容放在我们的box盒子里********</span><br><span class=\"line\"></span><br><span class=\"line\">\txhr.open(&quot;GET&quot;,&quot;01.php?a=5&amp;b=1&quot;,true);//传参a=5,b=1</span><br><span class=\"line\">\txhr.send(); </span><br><span class=\"line\">\t</span><br><span class=\"line\">//因为上面的方法是异步执行的，因此不用纠结，xhr.open()和send()的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果:<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212145801095?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>附上php的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo  &quot;a为&#123;$_GET[&apos;a&apos;]&#125;,那么b为&#123;$_GET[&apos;b&apos;]&#125;&quot;  </span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>这里php代码看不懂的话， 可以去<a href=\"http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP</a> 的基本语法。作为一个前端，后端语言要了解其接口和语法，这是最起码的(这个B装的66666)。</p>\n<p><strong>说好的监听xhr对象的创建过程呢？</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">//这里加上一句话  :</span><br><span class=\"line\">console.log(&quot;当前的XMLHttpRequest对象的创建进度为&quot;+xhr.readyState)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>来看打印结果:<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212150218442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>可见，每次xhr对象自身状态值改变，都会调用函数，因此导致我们打印的结果发生变化。  由此可得，ajax的创建是分步进行的，查询资料可得：</p>\n<ul>\n<li>0 对象未创建</li>\n<li>1 已与服务器连接</li>\n<li>2 服务器已经接受请求</li>\n<li>3 服务器正在处理请求</li>\n<li>4 服务器将请求下发<br><strong>同时，status也需要有响应的返回值，从服务器传递回来，有个状态值(xhr.status)： </strong><br>如果响应成功，就返回200<br>如果没找到，返回404<br>其他还有403,5系列等等，不再赘述。</li>\n</ul>\n<h1 id=\"二、jQuery中的ajax\"><a href=\"#二、jQuery中的ajax\" class=\"headerlink\" title=\"二、jQuery中的ajax\"></a><strong>二、jQuery中的ajax</strong></h1><p>1.load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">兹有按钮与容器各一个：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input type=&quot;button&quot; value=&quot;点我加载&quot; id=&quot;btn&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//js如下</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t$(&apos;#btn&apos;).click(function()&#123;</span><br><span class=\"line\">\t\t\t$(&apos;#box&apos;).load(&apos;03.php&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;/script&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">//php如下</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo &quot;hello,world!&lt;br/&gt;a  =  &#123;$_POST[&apos;a&apos;]&#125;&lt;br/&gt;b  =   &#123;$_POST[&apos;b&apos;]&#125;&quot;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>这里，点击按钮，box载入响应值，这个方法是get方法。<br>如图：<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212153748919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>如果，在load()多传一个json对象:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#box&apos;).load(&apos;03.php&apos;,&#123;</span><br><span class=\"line\">\t\t\t\ta:5,</span><br><span class=\"line\">\t\t\t\tb:1</span><br><span class=\"line\">\t\t\t&#125;)</span><br></pre></td></tr></table></figure>\n<p>那么这个请求会自动 变成post请求。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212153930619?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>在 Ajax数据载入完毕之后，就能执行回调函数 callback，也就是第三个参数。回调函数<br>也可以传递三个可选参数：responseText（请求返回）、textStatus（请求状态)、XMLHttpRequest对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).click(function () &#123;</span><br><span class=\"line\">  $(&apos;#box&apos;).load(&apos;03.php&apos;, &#123;</span><br><span class=\"line\">       a:5,</span><br><span class=\"line\">       b:1</span><br><span class=\"line\">  &#125;, function (response, status, xhr) &#123;</span><br><span class=\"line\">        alert(&apos;返回的值为：&apos; + response + &apos;，状态为：&apos; + status + &apos;，</span><br><span class=\"line\">           状态是：&apos; + xhr.statusText);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212154422827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>这里的status和xhr.statusText都是经过jQuery进行处理的，原本的值应该对应为：<br>200<br><strong>2.<code>$.get()和$.post()</code></strong></p>\n<p>.load()方法是局部方法，因为他需要一个包含元素的 jQuery对象作为前缀。而$.get()和<br>$.post()是全局方法，无须指定某个元素。对于用途而言，.load()适合做静态文件的异步获取，<br>而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).click($.get(url,&#123;json.data&#125;,callback(),type)&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">/*GET方法与load()方法相比，多了最后一个参数，返回类型，可以设置为</span><br><span class=\"line\">xml,html,json,text等，一般不需要设置，都是jQuery智能判断返回的。第一个参数：请求</span><br><span class=\"line\">地址，是必须的，后面的都是可选参数。</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p><strong><code>$.post()方法</code></strong></p>\n<p>的使用和<code>$.get()</code>基本上一致，他们之间的区别也比较隐晦，基本都是背后的</p>\n<p>不同，在用户使用上体现不出。具体区别如下：</p>\n<p>1.GET请求是通过  URL提交的，而 POST请求则是  HTTP消息实体提交的；</p>\n<p>2.GET提交有大小限制（2KB），而  POST方式不受限制；</p>\n<p>3.GET方式会被缓存下来，可能有安全性问题，而  POST没有这个问题；</p>\n<p>4.GET方式通过<code>$_GET[]</code>获取，POST方式通过<code>$_POST[]</code>获取。<br><strong>3.<code>load(),$.get(),$.post()</code> </strong>的集合：$.ajax</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ajax是jQuery封装的最底层的方法</span><br><span class=\"line\">\t\t$(&apos;btn[submit]&apos;)[0].click(function()&#123;</span><br><span class=\"line\">\t\t\t$.ajax(&#123;</span><br><span class=\"line\">\t\t\t\ttype:&quot;get&quot;,    //请求方式</span><br><span class=\"line\">\t\t\t\turl:&quot;02.php&quot;,  //地址</span><br><span class=\"line\">\t\t\t\tasync:true,      //异步</span><br><span class=\"line\">\t\t\t\tsuccess:function(response,status,xhr)&#123;alert(response)&#125;, //成功回调函数</span><br><span class=\"line\">\t\t\t\terror:function()&#123;&#125;,//失败回调</span><br><span class=\"line\">\t\t\t\tdata:$(&apos;form&apos;).serialize()//表单序列化</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、AngularJs中的ajax\"><a href=\"#三、AngularJs中的ajax\" class=\"headerlink\" title=\"三、AngularJs中的ajax\"></a><strong>三、AngularJs中的ajax</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在任一一个控制器中注入http依赖</span><br><span class=\"line\"></span><br><span class=\"line\">var app = angular.module(&apos;myApp&apos;,[]);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//http模块注入到任一一个控制器中</span><br><span class=\"line\"></span><br><span class=\"line\">app.controller(&apos;ctrl1&apos;,function($scope,$http)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">$http(&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">    method: &apos;GET&apos;, //选择请求方式</span><br><span class=\"line\">    </span><br><span class=\"line\">    url: &apos;02.php&apos; //请求地址</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;).then(function successCallback(response) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 请求成功执行代码</span><br><span class=\"line\">    &#125;, function errorCallback(response) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        // 请求失败执行代码</span><br><span class=\"line\">//语法为：$http.then(success(),fail())</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>声明：v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代。因此千万不要</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$http.success().error()//错误写法！z不能跟jQuery混淆</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>Js/jq/angularjs 中ajax的：</p>\n<p><strong>相同点</strong><br>1.都是异步的请求，都支持get,post方法,jq,angular支持(put)。</p>\n<p><strong>不同点：</strong></p>\n<p>1.jq中，对于ajax请求的写法非常简单，非常直观。angular中，通过$http模块也进行相应的封装，非常方便。</p>\n<p>2.普通的javaScript AJAX请求，如果需要GET方法传参，只能强行用”？”追加到url后面，并且不同参数连接要用&amp;进行，非常繁琐。</p>\n<p>3.所谓jq的success(),error()，以及angular的then方法，都是对原生ajax的</p>\n<p>status的不同返回值进行封装,例如：200就会执行success函数，404就执行error函数。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78781917\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"jq与原生以及angular中的ajax（长文）\"><a href=\"#jq与原生以及angular中的ajax（长文）\" class=\"headerlink\" title=\"jq与原生以及angular中的ajax（长文）\"></a><strong>jq与原生以及angular中的ajax（长文）</strong></h2><p><a href=\"http://blog.csdn.net/qq_20264891/article/details/78457021\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20264891/article/details/78457021</a></p>\n<p>上面是之前写的一篇关于ajax的帖子，里面的集成包xampp的配置方法有点不太科学，</p>\n<p>虽然这样可以运行，但感觉不是很美滋滋。</p>\n<p>感谢新浪博主@期待下一站幸福</p>\n<p>具体参考原文地址：<a href=\"http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_ae1d0a810102wvy6.html</a></p>\n<p>配置外部服务器，运行后端代码php？<br>对于完全是小白的我而言，实在是想都不敢想。因为得学习Ajax，就必须得给服务器的发送请求和等待服务器响。所以就在老师的带领下，开始了服务器的配置。</p>\n<p>首先介绍一下，我用的IDE:​HBuilder. 后端语言是php。</p>\n<p>我使用的是模拟服务器的软件：XAMPP​</p>\n<p>(下载地址：<a href=\"https://www.apachefriends.org/download.html\" target=\"_blank\" rel=\"noopener\">https://www.apachefriends.org/download.html</a>)</p>\n<p>然后说一下，我要做什么样的效果：</p>\n<p>让一个PHP文件在本地服务器上运行。（对！就是这么简单，我捣鼓了一个多小时…）​</p>\n<p>好了，接下来我们来看看吧。</p>\n<p>​</p>\n<p>1,安装一个模拟的服务器。</p>\n<p>如果你和我一样，没有任何的​Apache，MySQL，tomcat等WEB服务器。那就下载一个XAMPP.【好用于部署一个本地服务器】</p>\n<p>​安装完成后，打开的界面是这样子的：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212150943894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>我们可以先点击“start”启动，这时候需要注意的是：可能出现错误。【错误是：端口被占用】。</p>\n<blockquote>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151012172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用块内容\" title=\"\" class=\"\">\n                <p>引用块内容</p>\n            </figure>\n</blockquote>\n<p>解决方法是：点击config–进入Apache（httpd.conf）–找到listen（监听的端口号）进行修改。如图：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151304609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>好了，可以重新启动Apache啦。</p>\n<p><strong>2.打开HBuilder，然后新建一个项目。</strong></p>\n<p>注意：新建的项目—一定要在我们刚刚打开的XMAPP安装目录下的​htdocs文件夹下面。</p>\n<p>（不要问为啥，这是我一晚上调试出来的经验）​<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151354297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>﻿在安装目录下的htdocs，新建文件</p>\n<p>3.在HBuilder中的快捷工具栏中找到【浏览器】，打开它的下拉菜单，点击【设置web服务器】。</p>\n<p>进入页面点击”外置web服务器“​–选择”新建“</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151434576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151454782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>添加本地服务器</p>\n<p><img src=\"http://img.blog.csdn.net/20171212151518701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>4.把你写的PHP文件可以在浏览器中，打开了。</p>\n<p>这是我的源文件：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151552039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212151609984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h1 id=\"OK-接下来才是正文：\"><a href=\"#OK-接下来才是正文：\" class=\"headerlink\" title=\"OK,接下来才是正文：\"></a><strong><em>OK,接下来才是正文：</em></strong></h1><h1 id=\"一、javaScript原生Ajax\"><a href=\"#一、javaScript原生Ajax\" class=\"headerlink\" title=\"一、javaScript原生Ajax\"></a><strong>一、javaScript原生Ajax</strong></h1><p><strong>1.浏览器自带的与服务器交互的对象及附带API</strong></p>\n<p><strong>该对象是一个全局对象，即位于window对象下。IE与非IE，该对象不同</strong></p>\n<p>非IE &amp;&amp; IE7+ : XMLHttpRequest</p>\n<p>IE5,IE6: ActiveXObject</p>\n<p><strong>2.兼容创建大法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr=null;//初始化变量</span><br><span class=\"line\"></span><br><span class=\"line\">if(window.XMLHttpRequest)&#123;</span><br><span class=\"line\">//非IE&amp;&amp;IE7+</span><br><span class=\"line\"></span><br><span class=\"line\">xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else if(window.ActiveXObject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//不同的IE版本，里面写的东西不一样，具体请自行baidu</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3.创建好之后的后续步骤</strong></p>\n<p>xhr.open()  //该方法用于 <strong>创建</strong>  连接服务端的请求。</p>\n<p>xhr.send();  //所有的事情完毕，正式发送请求。</p>\n<p>注意：</p>\n<p>xhr.open(method,url,async)  请求方式，请求地址，是否异步？(ps:默认为true,异步执行)</p>\n<p>设置好open中的传参，接着执行xhr.send()。</p>\n<p><strong>4.如何知道请求与相应成功不成功？？</strong></p>\n<p>这里，xhr对象自带 一个方法，用来检测连接是否成功，以及对xhr创建过程进行监听，</p>\n<p>为什么这样说呢？直接看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> xhr.onreadystatechange=function()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \tif(xhr.readyState=4&amp;&amp;xhr.status==200)&#123;</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">    \t\tdocument.getElementById(&apos;box&apos;).innerHTML = xhr.responseText;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">***************上面界定了，请求成功以后，将响应的内容放在我们的box盒子里********</span><br><span class=\"line\"></span><br><span class=\"line\">\txhr.open(&quot;GET&quot;,&quot;01.php?a=5&amp;b=1&quot;,true);//传参a=5,b=1</span><br><span class=\"line\">\txhr.send(); </span><br><span class=\"line\">\t</span><br><span class=\"line\">//因为上面的方法是异步执行的，因此不用纠结，xhr.open()和send()的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果:<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212145801095?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>附上php的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo  &quot;a为&#123;$_GET[&apos;a&apos;]&#125;,那么b为&#123;$_GET[&apos;b&apos;]&#125;&quot;  </span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>这里php代码看不懂的话， 可以去<a href=\"http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20264891/article/details/78748217回顾一下PHP</a> 的基本语法。作为一个前端，后端语言要了解其接口和语法，这是最起码的(这个B装的66666)。</p>\n<p><strong>说好的监听xhr对象的创建过程呢？</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\">//这里加上一句话  :</span><br><span class=\"line\">console.log(&quot;当前的XMLHttpRequest对象的创建进度为&quot;+xhr.readyState)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>来看打印结果:<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212150218442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>可见，每次xhr对象自身状态值改变，都会调用函数，因此导致我们打印的结果发生变化。  由此可得，ajax的创建是分步进行的，查询资料可得：</p>\n<ul>\n<li>0 对象未创建</li>\n<li>1 已与服务器连接</li>\n<li>2 服务器已经接受请求</li>\n<li>3 服务器正在处理请求</li>\n<li>4 服务器将请求下发<br><strong>同时，status也需要有响应的返回值，从服务器传递回来，有个状态值(xhr.status)： </strong><br>如果响应成功，就返回200<br>如果没找到，返回404<br>其他还有403,5系列等等，不再赘述。</li>\n</ul>\n<h1 id=\"二、jQuery中的ajax\"><a href=\"#二、jQuery中的ajax\" class=\"headerlink\" title=\"二、jQuery中的ajax\"></a><strong>二、jQuery中的ajax</strong></h1><p>1.load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">兹有按钮与容器各一个：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input type=&quot;button&quot; value=&quot;点我加载&quot; id=&quot;btn&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//js如下</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t$(&apos;#btn&apos;).click(function()&#123;</span><br><span class=\"line\">\t\t\t$(&apos;#box&apos;).load(&apos;03.php&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;/script&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">//php如下</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo &quot;hello,world!&lt;br/&gt;a  =  &#123;$_POST[&apos;a&apos;]&#125;&lt;br/&gt;b  =   &#123;$_POST[&apos;b&apos;]&#125;&quot;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>这里，点击按钮，box载入响应值，这个方法是get方法。<br>如图：<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212153748919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>如果，在load()多传一个json对象:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#box&apos;).load(&apos;03.php&apos;,&#123;</span><br><span class=\"line\">\t\t\t\ta:5,</span><br><span class=\"line\">\t\t\t\tb:1</span><br><span class=\"line\">\t\t\t&#125;)</span><br></pre></td></tr></table></figure>\n<p>那么这个请求会自动 变成post请求。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212153930619?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>在 Ajax数据载入完毕之后，就能执行回调函数 callback，也就是第三个参数。回调函数<br>也可以传递三个可选参数：responseText（请求返回）、textStatus（请求状态)、XMLHttpRequest对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).click(function () &#123;</span><br><span class=\"line\">  $(&apos;#box&apos;).load(&apos;03.php&apos;, &#123;</span><br><span class=\"line\">       a:5,</span><br><span class=\"line\">       b:1</span><br><span class=\"line\">  &#125;, function (response, status, xhr) &#123;</span><br><span class=\"line\">        alert(&apos;返回的值为：&apos; + response + &apos;，状态为：&apos; + status + &apos;，</span><br><span class=\"line\">           状态是：&apos; + xhr.statusText);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171212154422827?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>这里的status和xhr.statusText都是经过jQuery进行处理的，原本的值应该对应为：<br>200<br><strong>2.<code>$.get()和$.post()</code></strong></p>\n<p>.load()方法是局部方法，因为他需要一个包含元素的 jQuery对象作为前缀。而$.get()和<br>$.post()是全局方法，无须指定某个元素。对于用途而言，.load()适合做静态文件的异步获取，<br>而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).click($.get(url,&#123;json.data&#125;,callback(),type)&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">/*GET方法与load()方法相比，多了最后一个参数，返回类型，可以设置为</span><br><span class=\"line\">xml,html,json,text等，一般不需要设置，都是jQuery智能判断返回的。第一个参数：请求</span><br><span class=\"line\">地址，是必须的，后面的都是可选参数。</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p><strong><code>$.post()方法</code></strong></p>\n<p>的使用和<code>$.get()</code>基本上一致，他们之间的区别也比较隐晦，基本都是背后的</p>\n<p>不同，在用户使用上体现不出。具体区别如下：</p>\n<p>1.GET请求是通过  URL提交的，而 POST请求则是  HTTP消息实体提交的；</p>\n<p>2.GET提交有大小限制（2KB），而  POST方式不受限制；</p>\n<p>3.GET方式会被缓存下来，可能有安全性问题，而  POST没有这个问题；</p>\n<p>4.GET方式通过<code>$_GET[]</code>获取，POST方式通过<code>$_POST[]</code>获取。<br><strong>3.<code>load(),$.get(),$.post()</code> </strong>的集合：$.ajax</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ajax是jQuery封装的最底层的方法</span><br><span class=\"line\">\t\t$(&apos;btn[submit]&apos;)[0].click(function()&#123;</span><br><span class=\"line\">\t\t\t$.ajax(&#123;</span><br><span class=\"line\">\t\t\t\ttype:&quot;get&quot;,    //请求方式</span><br><span class=\"line\">\t\t\t\turl:&quot;02.php&quot;,  //地址</span><br><span class=\"line\">\t\t\t\tasync:true,      //异步</span><br><span class=\"line\">\t\t\t\tsuccess:function(response,status,xhr)&#123;alert(response)&#125;, //成功回调函数</span><br><span class=\"line\">\t\t\t\terror:function()&#123;&#125;,//失败回调</span><br><span class=\"line\">\t\t\t\tdata:$(&apos;form&apos;).serialize()//表单序列化</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、AngularJs中的ajax\"><a href=\"#三、AngularJs中的ajax\" class=\"headerlink\" title=\"三、AngularJs中的ajax\"></a><strong>三、AngularJs中的ajax</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在任一一个控制器中注入http依赖</span><br><span class=\"line\"></span><br><span class=\"line\">var app = angular.module(&apos;myApp&apos;,[]);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//http模块注入到任一一个控制器中</span><br><span class=\"line\"></span><br><span class=\"line\">app.controller(&apos;ctrl1&apos;,function($scope,$http)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">$http(&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">    method: &apos;GET&apos;, //选择请求方式</span><br><span class=\"line\">    </span><br><span class=\"line\">    url: &apos;02.php&apos; //请求地址</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;).then(function successCallback(response) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 请求成功执行代码</span><br><span class=\"line\">    &#125;, function errorCallback(response) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        // 请求失败执行代码</span><br><span class=\"line\">//语法为：$http.then(success(),fail())</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>声明：v1.5 中$http 的 success 和 error 方法已废弃。使用 then 方法替代。因此千万不要</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$http.success().error()//错误写法！z不能跟jQuery混淆</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h1><p>Js/jq/angularjs 中ajax的：</p>\n<p><strong>相同点</strong><br>1.都是异步的请求，都支持get,post方法,jq,angular支持(put)。</p>\n<p><strong>不同点：</strong></p>\n<p>1.jq中，对于ajax请求的写法非常简单，非常直观。angular中，通过$http模块也进行相应的封装，非常方便。</p>\n<p>2.普通的javaScript AJAX请求，如果需要GET方法传参，只能强行用”？”追加到url后面，并且不同参数连接要用&amp;进行，非常繁琐。</p>\n<p>3.所谓jq的success(),error()，以及angular的then方法，都是对原生ajax的</p>\n<p>status的不同返回值进行封装,例如：200就会执行success函数，404就执行error函数。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"Cookie、Session、Token","date":"2018-08-26T15:57:08.000Z","reward":true,"comment":true,"_content":"\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://mp.csdn.net/postedit/82085958)\n\nCookie 是比较早的服务端和客户端验证身份的方法。\n因为 http 是无状态的，因此，每次 http 请求，服务端不知道是谁在来访，因此，对于每次来访，回传字段中会设置 set-cookie 字段，浏览器会将 cookie 保存在本地，等下次 http 请求，再发送给这个域名的服务器。\n\n\n\nCookie 可以由服务端来设置生命周期。\n\n\n\nCookie 存储在客户端本地 。\n\n\n\nCookie 挂载在 Document 对象下，可以用 js 修改，因此有安全风险，所以后面又引入 Session 来补全不足。\n\n\n\n一般情况， cookie 直接写入请求头。\n\n\n\nFor eg:\n\n\n\n```javascript\n\n// 首次访问\n\nclient => 访问 www.example.com\n\nserver => 收到来访，在回传字段中，包含 set-cookie 字段：\n\n{ set-cookie: username=uuidtest123;Domail=.example.com ... }\n\n// 第二次访问\n\nclient => 判断访问的域名，检查是否存在该域名的 cookie, 有的话就带上一起请求\n\nserver => 收到来访，并含有 cookie ，回传不用再加新 cookie 了。\n\n```\n\n\n\n\n\nSession 一般通过 set-cookie 一起传过来，配合 cookie 保存会话信息。\n\n\nSession 的出现是为了保持用户的连接状态而做出的努力。\n\n\n\n比如有一个场景，用户登录了 a.com ，如果登陆 a.com/profile ，查看一下个人资料，难道还要用户重新登陆吗?不合适吧？\n\n\n\n用户判断 Cookie 所在的客户端是否还“在线”，每次客户端进行请求(动作)，都会刷新 Session 的时间值。\n\n\n\nFor eg:\n\n\n\n```javascript\n\n// 首次访问\n\nclient => 访问 www.example.com\n\nserver => 收到来访，在回传字段中，包含 set-cookie 字段：\n\n{ set-cookie: username=uuidtest123;Domail=.example.com;sessionId=xxx;sessionFresh=30min;}\n\n// 第二次访问\n\nclient => 访问 www.example.com ，并自动携带 session\n\nserver => 收到来访，刷新 session 的新鲜值，并通过 set-cookie 回传给客户端。\n\n如果在限定的时间内（此处是30分钟）， session 新鲜值没有被刷新，就会被销毁。\n\n```\n\n\n\n\n其中 cookie 的作用就是为了解决HTTP协议无状态的现状所作出的努力。至于 session 机制则是又一种在客户端与服务器之间保持状态的解决方案。 \n\n\n\n简而言之， cookie 是辨别来访者，session 是看该来访者是否保持连接\n\n\n\n​​​​​\ntoken 和 session 很像，也是为了保持状态，一般是登陆以后，后端会返回 sessinId ,其实就是 token=> 用户唯一标识，通过 Cookie 来传给后台。\n\n\ntoken 在前端传给后端时，直接写入请求体，当做普通参数缀在后面即可。\n\n\n\n参考： https://zhuanlan.zhihu.com/p/27736893\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n\n","source":"_posts/cookie,session,token.md","raw":"---\ntitle: Cookie、Session、Token\ndate: 2018-08-26 23:57:08\ntags: http\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://mp.csdn.net/postedit/82085958)\n\nCookie 是比较早的服务端和客户端验证身份的方法。\n因为 http 是无状态的，因此，每次 http 请求，服务端不知道是谁在来访，因此，对于每次来访，回传字段中会设置 set-cookie 字段，浏览器会将 cookie 保存在本地，等下次 http 请求，再发送给这个域名的服务器。\n\n\n\nCookie 可以由服务端来设置生命周期。\n\n\n\nCookie 存储在客户端本地 。\n\n\n\nCookie 挂载在 Document 对象下，可以用 js 修改，因此有安全风险，所以后面又引入 Session 来补全不足。\n\n\n\n一般情况， cookie 直接写入请求头。\n\n\n\nFor eg:\n\n\n\n```javascript\n\n// 首次访问\n\nclient => 访问 www.example.com\n\nserver => 收到来访，在回传字段中，包含 set-cookie 字段：\n\n{ set-cookie: username=uuidtest123;Domail=.example.com ... }\n\n// 第二次访问\n\nclient => 判断访问的域名，检查是否存在该域名的 cookie, 有的话就带上一起请求\n\nserver => 收到来访，并含有 cookie ，回传不用再加新 cookie 了。\n\n```\n\n\n\n\n\nSession 一般通过 set-cookie 一起传过来，配合 cookie 保存会话信息。\n\n\nSession 的出现是为了保持用户的连接状态而做出的努力。\n\n\n\n比如有一个场景，用户登录了 a.com ，如果登陆 a.com/profile ，查看一下个人资料，难道还要用户重新登陆吗?不合适吧？\n\n\n\n用户判断 Cookie 所在的客户端是否还“在线”，每次客户端进行请求(动作)，都会刷新 Session 的时间值。\n\n\n\nFor eg:\n\n\n\n```javascript\n\n// 首次访问\n\nclient => 访问 www.example.com\n\nserver => 收到来访，在回传字段中，包含 set-cookie 字段：\n\n{ set-cookie: username=uuidtest123;Domail=.example.com;sessionId=xxx;sessionFresh=30min;}\n\n// 第二次访问\n\nclient => 访问 www.example.com ，并自动携带 session\n\nserver => 收到来访，刷新 session 的新鲜值，并通过 set-cookie 回传给客户端。\n\n如果在限定的时间内（此处是30分钟）， session 新鲜值没有被刷新，就会被销毁。\n\n```\n\n\n\n\n其中 cookie 的作用就是为了解决HTTP协议无状态的现状所作出的努力。至于 session 机制则是又一种在客户端与服务器之间保持状态的解决方案。 \n\n\n\n简而言之， cookie 是辨别来访者，session 是看该来访者是否保持连接\n\n\n\n​​​​​\ntoken 和 session 很像，也是为了保持状态，一般是登陆以后，后端会返回 sessinId ,其实就是 token=> 用户唯一标识，通过 Cookie 来传给后台。\n\n\ntoken 在前端传给后端时，直接写入请求体，当做普通参数缀在后面即可。\n\n\n\n参考： https://zhuanlan.zhihu.com/p/27736893\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n\n","slug":"cookie,session,token","published":1,"updated":"2018-08-29T07:21:28.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdft000zjgv4tt5zrqss","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://mp.csdn.net/postedit/82085958\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>Cookie 是比较早的服务端和客户端验证身份的方法。<br>因为 http 是无状态的，因此，每次 http 请求，服务端不知道是谁在来访，因此，对于每次来访，回传字段中会设置 set-cookie 字段，浏览器会将 cookie 保存在本地，等下次 http 请求，再发送给这个域名的服务器。</p>\n<p>Cookie 可以由服务端来设置生命周期。</p>\n<p>Cookie 存储在客户端本地 。</p>\n<p>Cookie 挂载在 Document 对象下，可以用 js 修改，因此有安全风险，所以后面又引入 Session 来补全不足。</p>\n<p>一般情况， cookie 直接写入请求头。</p>\n<p>For eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 访问 www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; set-cookie: username=uuidtest123;Domail=.example.com ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 判断访问的域名，检查是否存在该域名的 cookie, 有的话就带上一起请求</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，并含有 cookie ，回传不用再加新 cookie 了。</span><br></pre></td></tr></table></figure>\n<p>Session 一般通过 set-cookie 一起传过来，配合 cookie 保存会话信息。</p>\n<p>Session 的出现是为了保持用户的连接状态而做出的努力。</p>\n<p>比如有一个场景，用户登录了 a.com ，如果登陆 a.com/profile ，查看一下个人资料，难道还要用户重新登陆吗?不合适吧？</p>\n<p>用户判断 Cookie 所在的客户端是否还“在线”，每次客户端进行请求(动作)，都会刷新 Session 的时间值。</p>\n<p>For eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 访问 www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; set-cookie: username=uuidtest123;Domail=.example.com;sessionId=xxx;sessionFresh=<span class=\"number\">30</span>min;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 访问 www.example.com ，并自动携带 session</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，刷新 session 的新鲜值，并通过 set-cookie 回传给客户端。</span><br><span class=\"line\"></span><br><span class=\"line\">如果在限定的时间内（此处是<span class=\"number\">30</span>分钟）， session 新鲜值没有被刷新，就会被销毁。</span><br></pre></td></tr></table></figure>\n<p>其中 cookie 的作用就是为了解决HTTP协议无状态的现状所作出的努力。至于 session 机制则是又一种在客户端与服务器之间保持状态的解决方案。 </p>\n<p>简而言之， cookie 是辨别来访者，session 是看该来访者是否保持连接</p>\n<p>​​​​​<br>token 和 session 很像，也是为了保持状态，一般是登陆以后，后端会返回 sessinId ,其实就是 token=&gt; 用户唯一标识，通过 Cookie 来传给后台。</p>\n<p>token 在前端传给后端时，直接写入请求体，当做普通参数缀在后面即可。</p>\n<p>参考： <a href=\"https://zhuanlan.zhihu.com/p/27736893\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/27736893</a></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://mp.csdn.net/postedit/82085958\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>Cookie 是比较早的服务端和客户端验证身份的方法。<br>因为 http 是无状态的，因此，每次 http 请求，服务端不知道是谁在来访，因此，对于每次来访，回传字段中会设置 set-cookie 字段，浏览器会将 cookie 保存在本地，等下次 http 请求，再发送给这个域名的服务器。</p>\n<p>Cookie 可以由服务端来设置生命周期。</p>\n<p>Cookie 存储在客户端本地 。</p>\n<p>Cookie 挂载在 Document 对象下，可以用 js 修改，因此有安全风险，所以后面又引入 Session 来补全不足。</p>\n<p>一般情况， cookie 直接写入请求头。</p>\n<p>For eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 访问 www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; set-cookie: username=uuidtest123;Domail=.example.com ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 判断访问的域名，检查是否存在该域名的 cookie, 有的话就带上一起请求</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，并含有 cookie ，回传不用再加新 cookie 了。</span><br></pre></td></tr></table></figure>\n<p>Session 一般通过 set-cookie 一起传过来，配合 cookie 保存会话信息。</p>\n<p>Session 的出现是为了保持用户的连接状态而做出的努力。</p>\n<p>比如有一个场景，用户登录了 a.com ，如果登陆 a.com/profile ，查看一下个人资料，难道还要用户重新登陆吗?不合适吧？</p>\n<p>用户判断 Cookie 所在的客户端是否还“在线”，每次客户端进行请求(动作)，都会刷新 Session 的时间值。</p>\n<p>For eg:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 访问 www.example.com</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，在回传字段中，包含 set-cookie 字段：</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; set-cookie: username=uuidtest123;Domail=.example.com;sessionId=xxx;sessionFresh=<span class=\"number\">30</span>min;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二次访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">client =&gt; 访问 www.example.com ，并自动携带 session</span><br><span class=\"line\"></span><br><span class=\"line\">server =&gt; 收到来访，刷新 session 的新鲜值，并通过 set-cookie 回传给客户端。</span><br><span class=\"line\"></span><br><span class=\"line\">如果在限定的时间内（此处是<span class=\"number\">30</span>分钟）， session 新鲜值没有被刷新，就会被销毁。</span><br></pre></td></tr></table></figure>\n<p>其中 cookie 的作用就是为了解决HTTP协议无状态的现状所作出的努力。至于 session 机制则是又一种在客户端与服务器之间保持状态的解决方案。 </p>\n<p>简而言之， cookie 是辨别来访者，session 是看该来访者是否保持连接</p>\n<p>​​​​​<br>token 和 session 很像，也是为了保持状态，一般是登陆以后，后端会返回 sessinId ,其实就是 token=&gt; 用户唯一标识，通过 Cookie 来传给后台。</p>\n<p>token 在前端传给后端时，直接写入请求体，当做普通参数缀在后面即可。</p>\n<p>参考： <a href=\"https://zhuanlan.zhihu.com/p/27736893\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/27736893</a></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"css3原理，结合jquery复习","date":"2018-01-17T03:18:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79019724)\n\n## 0.怪异盒模型 ##\n非IE及IE9及以上， 盒模型的构成为:content\n老IE，IE8及以下， 盒模型为 content+border+padding \n如果有这样一个DIV：\n\n```\ndiv{width:100px;height:100px;border:1px solid black;padding:10px;}\n```\n在非IE下，盒模型为：\n![这里写图片描述](http://img.blog.csdn.net/20180110092905668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n在老IE下，盒模型为：\n![这里写图片描述](http://img.blog.csdn.net/20180110092944223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n由此可见，老IE在计算盒模型时，加入了两个padding和border的值。\n\n## 1.background-size ##\n规定背景的位置。\neg:\n\n```\n#div{background-size:cover;}//覆盖整个div\n#div{background:url(img/123.png) no-repeat;background-size:10% 10%;}//背景图片宽高为原始图片宽高的10%，且不重复\n\n```\n## 2.background-orgin: ##\n//可以选择的值为：content-box、margin-box、padding-box\n\n***content-box、margin-box、padding-box的区别***\n\n①content-box，即采用W3C标准渲染方法，不计算padding和border及margin，得出的盒子\n②padding-box，渲染盒子的时候，把padding当做盒子宽高的组成部分，即在标准盒子模型的基础上，宽高都增加padding px。\n③margin-box，同理，宽高都增加margin-box\n3.border-radius  圆角边框，假如DIV 的  宽 = 高，即正方形，此时，如果border-radius = div 的宽/高，那么此时的div是一个圆形。如果border-radius远远大于div的宽/高，那么还是一个圆形，不会变化。\n因此，background-origin的值，就取决于背景图从哪个盒子模型开始渲染。\n## 4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色 ##\n\n```\n{\ntext-shadow: 225px 0px 0px #FF0000; /*水平偏移225，垂直不偏移 z-index为0 颜色为红色*/\n\n}\n```\n最终效果：\n![这里写图片描述](http://img.blog.csdn.net/20180110095154859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 5.font-face 自定义字体 ##\n兼容度：IE及IE8以下不支持，主流浏览器都支持。\n关于自定义字体，请参见我之前的一篇博客：\n[自定义图标与百度Share API](http://blog.csdn.net/qq_20264891/article/details/78438174)\n## 6.Css3 之 2D转换 (transform)##\n释义：transform 改变;变换\n兼容度：IE9及以上，主流浏览器都兼容。\n下面列举的方法，都位于transform属性之下，例如：transform:rotate()、transform:translate()\n主要的2D转换属性：\n**6.1  位移：  translate()   方法 **\n\n```\ndiv{transform：translate(100px,100px)} /*在原来位置的基础上，x轴移动10px，y轴移动10px*/\n```\n如图所示：\n![这里写图片描述](http://img.blog.csdn.net/20180110101251395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n原本处于空白位置的DIV，现在x,y轴都平移了正的100px\n**6.2 旋转   rotate() 方法**\n\n```\n```\nimg{transform：rotate(30deg)}\n /*图片顺时针旋转30度，当然，也可以和css伪类配合完成一些效果 ，例如 ：*/\n img:hover{transform:rotate(30deg)} /*鼠标悬停，方可旋转*/\n```\n![这里写图片描述](http://img.blog.csdn.net/20180110102120286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n由此可见，这个效果在一些圆形的图片上最为适用\n\n**6.3 比例/缩放 scale(x轴比例，y轴比例) 方法**\n跟刚才的旋转同理，我们也可以给一个图片设定一:hover伪类，然后来观察效果\n\n```\n/*文档结构：父div包含着一个图片，父div标准盒子模型100x100，原始图片100x100 */\n\ndiv{width:101px;height:101px;overflow:hidden;border:1px solid black;}\n\nimg:hover{transform: scale(1.5,1.5);}\n```\n![这里写图片描述](http://img.blog.csdn.net/20180110102627735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这个效果也很常见。鼠标放进去放大，鼠标离开变成原始比例。\n关于这一点，可以参照之前的博客：\n[关于CSS3呼吸效果的探究](http://blog.csdn.net/qq_20264891/article/details/78949964)\n**6.4 偏斜/歪斜  skew(x轴偏斜,y轴偏斜)**\n以前见过很多用CSS3做的留言墙，skew属性用的比较多。\n\n```\nimg:hover{transform:skew(30deg,30deg)}\n```\n鉴于这个方法比较扭曲，就不上图了，值得注意的一点是，这个偏移量貌似根据tan来计算的，当我给这个方法传入90deg时，图片会不存在。\n**6.5 矩阵/汇总方法 matrix**\nmartrix()接受6个参数，其实就是对于 平移、旋转、缩放、偏斜的汇总简写。\n具体请参见张鑫旭大神的博客：\n[理解CSS3 transform中的Matrix(矩阵)](http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/)\n## 7. Css3之3D转换 ##（Oprea不支持3D转换）\n**7.1    3D旋转 rotateY()**\n\n```\ndiv:hover{transform: rotateY(180deg)}\n```\n![这里写图片描述](http://img.blog.csdn.net/20180110123324497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n框中的文字，其本身围绕Y轴旋转180°\n\n## 8.Transition 过渡效果 ##\n兼容度：IE9及以下不支持该属性，需要优雅降级\n\n```\ndiv{width:100px;height:100px;background:yellow;transition:width:width 2s;}\ndiv:hover{width:300px;}\n```\n效果如图（鼠标移入，DIV变宽，鼠标移出，自动复原）：\n![鼠标移入，DIV变宽](http://img.blog.csdn.net/20180111092602675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n此时，我们在div:hover中重写了属性width，那么，在原始的div{transition}中，我们要说明，那个属性需要过渡效果，并注明过渡时间，此时肯定是transition:width 2s，如果有多个属性需要过渡效果，那么，就应该给出如下说明：\n\n```\ntransition:all 2s   //所有属性都需要过渡效果，并且所有效果同步过渡的总时长为2s.\n```\n如此一来，就可以实现类似于jquery的效果：\n\n```\n$('div').animate({width:'101px';height:'101px';background:'green';})\n```\n![这里写图片描述](http://img.blog.csdn.net/20180111115416020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n甚至可以规定过渡的delay延时：\n\n```\ntransition-delay:0.5s;  //0.5秒延时以后开始动画效果。\n```\n效果与上图大同小异，不过有0.5s的移入和移出延时。\n其实，在transition里有4个属性，分别是：\n1.过渡的属性名称\n2.过渡的总时长\n3.过渡的方式:线性，缓慢等等\n4.过渡的延时，即多少s以后才开始过渡\n例如：\n\n```\ndiv{\n\ttransition-property: width;\n\ttransition-duration: 1s;\n\ttransition-timing-function: linear;\n\ttransition-delay: 2s;\n}\n```\n可以简写为：\n\n```\ndiv{transition:width 2s linear 2s}\n```\n## 9.CSS3 动画 ##\n之前一篇帖子对于动画部分做了一些探究：\n[关于CSS3呼吸效果的探究 ](http://blog.csdn.net/qq_20264891/article/details/78949964)\n如果对于动画的需求比较复杂，需要持续重复的完成，可以考虑动画效果，如果只是简单的一些效果，完全可以采用transform来自己实现。\n## 10.CSS 3 多列 ##\n\n```\ndiv{\n-moz-column-count:3; /* Firefox */\n-webkit-column-count:3; /* Safari and Chrome */\ncolumn-count:3;\n}\n/*将一个DIV分为三列*/\n```\n![这里写图片描述](http://img.blog.csdn.net/20180111133322968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n以及最后的最后，有一个允许用户自定义元素大小(可拖拽拉伸)的属性\n\n```\ndiv\n{\nborder:2px solid;\npadding:10px 40px; \nwidth:300px;\nresize:both;\noverflow:auto;\n}\n```\n![这里写图片描述](http://img.blog.csdn.net/20180111135633726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/css3原理，结合jquery复习.md","raw":"---\ntitle: css3原理，结合jquery复习\ndate: 2018-01-17 11:18:00\ntags: css3\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79019724)\n\n## 0.怪异盒模型 ##\n非IE及IE9及以上， 盒模型的构成为:content\n老IE，IE8及以下， 盒模型为 content+border+padding \n如果有这样一个DIV：\n\n```\ndiv{width:100px;height:100px;border:1px solid black;padding:10px;}\n```\n在非IE下，盒模型为：\n![这里写图片描述](http://img.blog.csdn.net/20180110092905668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n在老IE下，盒模型为：\n![这里写图片描述](http://img.blog.csdn.net/20180110092944223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n由此可见，老IE在计算盒模型时，加入了两个padding和border的值。\n\n## 1.background-size ##\n规定背景的位置。\neg:\n\n```\n#div{background-size:cover;}//覆盖整个div\n#div{background:url(img/123.png) no-repeat;background-size:10% 10%;}//背景图片宽高为原始图片宽高的10%，且不重复\n\n```\n## 2.background-orgin: ##\n//可以选择的值为：content-box、margin-box、padding-box\n\n***content-box、margin-box、padding-box的区别***\n\n①content-box，即采用W3C标准渲染方法，不计算padding和border及margin，得出的盒子\n②padding-box，渲染盒子的时候，把padding当做盒子宽高的组成部分，即在标准盒子模型的基础上，宽高都增加padding px。\n③margin-box，同理，宽高都增加margin-box\n3.border-radius  圆角边框，假如DIV 的  宽 = 高，即正方形，此时，如果border-radius = div 的宽/高，那么此时的div是一个圆形。如果border-radius远远大于div的宽/高，那么还是一个圆形，不会变化。\n因此，background-origin的值，就取决于背景图从哪个盒子模型开始渲染。\n## 4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色 ##\n\n```\n{\ntext-shadow: 225px 0px 0px #FF0000; /*水平偏移225，垂直不偏移 z-index为0 颜色为红色*/\n\n}\n```\n最终效果：\n![这里写图片描述](http://img.blog.csdn.net/20180110095154859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 5.font-face 自定义字体 ##\n兼容度：IE及IE8以下不支持，主流浏览器都支持。\n关于自定义字体，请参见我之前的一篇博客：\n[自定义图标与百度Share API](http://blog.csdn.net/qq_20264891/article/details/78438174)\n## 6.Css3 之 2D转换 (transform)##\n释义：transform 改变;变换\n兼容度：IE9及以上，主流浏览器都兼容。\n下面列举的方法，都位于transform属性之下，例如：transform:rotate()、transform:translate()\n主要的2D转换属性：\n**6.1  位移：  translate()   方法 **\n\n```\ndiv{transform：translate(100px,100px)} /*在原来位置的基础上，x轴移动10px，y轴移动10px*/\n```\n如图所示：\n![这里写图片描述](http://img.blog.csdn.net/20180110101251395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n原本处于空白位置的DIV，现在x,y轴都平移了正的100px\n**6.2 旋转   rotate() 方法**\n\n```\n```\nimg{transform：rotate(30deg)}\n /*图片顺时针旋转30度，当然，也可以和css伪类配合完成一些效果 ，例如 ：*/\n img:hover{transform:rotate(30deg)} /*鼠标悬停，方可旋转*/\n```\n![这里写图片描述](http://img.blog.csdn.net/20180110102120286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n由此可见，这个效果在一些圆形的图片上最为适用\n\n**6.3 比例/缩放 scale(x轴比例，y轴比例) 方法**\n跟刚才的旋转同理，我们也可以给一个图片设定一:hover伪类，然后来观察效果\n\n```\n/*文档结构：父div包含着一个图片，父div标准盒子模型100x100，原始图片100x100 */\n\ndiv{width:101px;height:101px;overflow:hidden;border:1px solid black;}\n\nimg:hover{transform: scale(1.5,1.5);}\n```\n![这里写图片描述](http://img.blog.csdn.net/20180110102627735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这个效果也很常见。鼠标放进去放大，鼠标离开变成原始比例。\n关于这一点，可以参照之前的博客：\n[关于CSS3呼吸效果的探究](http://blog.csdn.net/qq_20264891/article/details/78949964)\n**6.4 偏斜/歪斜  skew(x轴偏斜,y轴偏斜)**\n以前见过很多用CSS3做的留言墙，skew属性用的比较多。\n\n```\nimg:hover{transform:skew(30deg,30deg)}\n```\n鉴于这个方法比较扭曲，就不上图了，值得注意的一点是，这个偏移量貌似根据tan来计算的，当我给这个方法传入90deg时，图片会不存在。\n**6.5 矩阵/汇总方法 matrix**\nmartrix()接受6个参数，其实就是对于 平移、旋转、缩放、偏斜的汇总简写。\n具体请参见张鑫旭大神的博客：\n[理解CSS3 transform中的Matrix(矩阵)](http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/)\n## 7. Css3之3D转换 ##（Oprea不支持3D转换）\n**7.1    3D旋转 rotateY()**\n\n```\ndiv:hover{transform: rotateY(180deg)}\n```\n![这里写图片描述](http://img.blog.csdn.net/20180110123324497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n框中的文字，其本身围绕Y轴旋转180°\n\n## 8.Transition 过渡效果 ##\n兼容度：IE9及以下不支持该属性，需要优雅降级\n\n```\ndiv{width:100px;height:100px;background:yellow;transition:width:width 2s;}\ndiv:hover{width:300px;}\n```\n效果如图（鼠标移入，DIV变宽，鼠标移出，自动复原）：\n![鼠标移入，DIV变宽](http://img.blog.csdn.net/20180111092602675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n此时，我们在div:hover中重写了属性width，那么，在原始的div{transition}中，我们要说明，那个属性需要过渡效果，并注明过渡时间，此时肯定是transition:width 2s，如果有多个属性需要过渡效果，那么，就应该给出如下说明：\n\n```\ntransition:all 2s   //所有属性都需要过渡效果，并且所有效果同步过渡的总时长为2s.\n```\n如此一来，就可以实现类似于jquery的效果：\n\n```\n$('div').animate({width:'101px';height:'101px';background:'green';})\n```\n![这里写图片描述](http://img.blog.csdn.net/20180111115416020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n甚至可以规定过渡的delay延时：\n\n```\ntransition-delay:0.5s;  //0.5秒延时以后开始动画效果。\n```\n效果与上图大同小异，不过有0.5s的移入和移出延时。\n其实，在transition里有4个属性，分别是：\n1.过渡的属性名称\n2.过渡的总时长\n3.过渡的方式:线性，缓慢等等\n4.过渡的延时，即多少s以后才开始过渡\n例如：\n\n```\ndiv{\n\ttransition-property: width;\n\ttransition-duration: 1s;\n\ttransition-timing-function: linear;\n\ttransition-delay: 2s;\n}\n```\n可以简写为：\n\n```\ndiv{transition:width 2s linear 2s}\n```\n## 9.CSS3 动画 ##\n之前一篇帖子对于动画部分做了一些探究：\n[关于CSS3呼吸效果的探究 ](http://blog.csdn.net/qq_20264891/article/details/78949964)\n如果对于动画的需求比较复杂，需要持续重复的完成，可以考虑动画效果，如果只是简单的一些效果，完全可以采用transform来自己实现。\n## 10.CSS 3 多列 ##\n\n```\ndiv{\n-moz-column-count:3; /* Firefox */\n-webkit-column-count:3; /* Safari and Chrome */\ncolumn-count:3;\n}\n/*将一个DIV分为三列*/\n```\n![这里写图片描述](http://img.blog.csdn.net/20180111133322968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n以及最后的最后，有一个允许用户自定义元素大小(可拖拽拉伸)的属性\n\n```\ndiv\n{\nborder:2px solid;\npadding:10px 40px; \nwidth:300px;\nresize:both;\noverflow:auto;\n}\n```\n![这里写图片描述](http://img.blog.csdn.net/20180111135633726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"css3原理，结合jquery复习","published":1,"updated":"2018-08-29T05:59:20.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfv0011jgv4u3raqk7b","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79019724\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"0-怪异盒模型\"><a href=\"#0-怪异盒模型\" class=\"headerlink\" title=\"0.怪异盒模型\"></a>0.怪异盒模型</h2><p>非IE及IE9及以上， 盒模型的构成为:content<br>老IE，IE8及以下， 盒模型为 content+border+padding<br>如果有这样一个DIV：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;width:100px;height:100px;border:1px solid black;padding:10px;&#125;</span><br></pre></td></tr></table></figure>\n<p>在非IE下，盒模型为：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110092905668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>在老IE下，盒模型为：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110092944223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>由此可见，老IE在计算盒模型时，加入了两个padding和border的值。</p>\n<h2 id=\"1-background-size\"><a href=\"#1-background-size\" class=\"headerlink\" title=\"1.background-size\"></a>1.background-size</h2><p>规定背景的位置。<br>eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div&#123;background-size:cover;&#125;//覆盖整个div</span><br><span class=\"line\">#div&#123;background:url(img/123.png) no-repeat;background-size:10% 10%;&#125;//背景图片宽高为原始图片宽高的10%，且不重复</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-background-orgin\"><a href=\"#2-background-orgin\" class=\"headerlink\" title=\"2.background-orgin:\"></a>2.background-orgin:</h2><p>//可以选择的值为：content-box、margin-box、padding-box</p>\n<p><strong><em>content-box、margin-box、padding-box的区别</em></strong></p>\n<p>①content-box，即采用W3C标准渲染方法，不计算padding和border及margin，得出的盒子<br>②padding-box，渲染盒子的时候，把padding当做盒子宽高的组成部分，即在标准盒子模型的基础上，宽高都增加padding px。<br>③margin-box，同理，宽高都增加margin-box<br>3.border-radius  圆角边框，假如DIV 的  宽 = 高，即正方形，此时，如果border-radius = div 的宽/高，那么此时的div是一个圆形。如果border-radius远远大于div的宽/高，那么还是一个圆形，不会变化。<br>因此，background-origin的值，就取决于背景图从哪个盒子模型开始渲染。</p>\n<h2 id=\"4-text-shadow-水平偏移-垂直偏移-阴影距离文字的z-index距离-颜色\"><a href=\"#4-text-shadow-水平偏移-垂直偏移-阴影距离文字的z-index距离-颜色\" class=\"headerlink\" title=\"4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色\"></a>4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">text-shadow: 225px 0px 0px #FF0000; /*水平偏移225，垂直不偏移 z-index为0 颜色为红色*/</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110095154859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<h2 id=\"5-font-face-自定义字体\"><a href=\"#5-font-face-自定义字体\" class=\"headerlink\" title=\"5.font-face 自定义字体\"></a>5.font-face 自定义字体</h2><p>兼容度：IE及IE8以下不支持，主流浏览器都支持。<br>关于自定义字体，请参见我之前的一篇博客：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78438174\" target=\"_blank\" rel=\"noopener\">自定义图标与百度Share API</a></p>\n<h2 id=\"6-Css3-之-2D转换-transform\"><a href=\"#6-Css3-之-2D转换-transform\" class=\"headerlink\" title=\"6.Css3 之 2D转换 (transform)\"></a>6.Css3 之 2D转换 (transform)</h2><p>释义：transform 改变;变换<br>兼容度：IE9及以上，主流浏览器都兼容。<br>下面列举的方法，都位于transform属性之下，例如：transform:rotate()、transform:translate()<br>主要的2D转换属性：<br><strong>6.1  位移：  translate()   方法 </strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;transform：translate(100px,100px)&#125; /*在原来位置的基础上，x轴移动10px，y轴移动10px*/</span><br></pre></td></tr></table></figure>\n<p>如图所示：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110101251395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>原本处于空白位置的DIV，现在x,y轴都平移了正的100px<br><strong>6.2 旋转   rotate() 方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">img&#123;transform：rotate(30deg)&#125;</span><br><span class=\"line\"> /*图片顺时针旋转30度，当然，也可以和css伪类配合完成一些效果 ，例如 ：*/</span><br><span class=\"line\"> img:hover&#123;transform:rotate(30deg)&#125; /*鼠标悬停，方可旋转*/</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110102120286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>由此可见，这个效果在一些圆形的图片上最为适用</p>\n<p><strong>6.3 比例/缩放 scale(x轴比例，y轴比例) 方法</strong><br>跟刚才的旋转同理，我们也可以给一个图片设定一:hover伪类，然后来观察效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*文档结构：父div包含着一个图片，父div标准盒子模型100x100，原始图片100x100 */</span><br><span class=\"line\"></span><br><span class=\"line\">div&#123;width:101px;height:101px;overflow:hidden;border:1px solid black;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">img:hover&#123;transform: scale(1.5,1.5);&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110102627735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>这个效果也很常见。鼠标放进去放大，鼠标离开变成原始比例。<br>关于这一点，可以参照之前的博客：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78949964\" target=\"_blank\" rel=\"noopener\">关于CSS3呼吸效果的探究</a><br><strong>6.4 偏斜/歪斜  skew(x轴偏斜,y轴偏斜)</strong><br>以前见过很多用CSS3做的留言墙，skew属性用的比较多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img:hover&#123;transform:skew(30deg,30deg)&#125;</span><br></pre></td></tr></table></figure>\n<p>鉴于这个方法比较扭曲，就不上图了，值得注意的一点是，这个偏移量貌似根据tan来计算的，当我给这个方法传入90deg时，图片会不存在。<br><strong>6.5 矩阵/汇总方法 matrix</strong><br>martrix()接受6个参数，其实就是对于 平移、旋转、缩放、偏斜的汇总简写。<br>具体请参见张鑫旭大神的博客：<br><a href=\"http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/\" target=\"_blank\" rel=\"noopener\">理解CSS3 transform中的Matrix(矩阵)</a></p>\n<h2 id=\"7-Css3之3D转换-（Oprea不支持3D转换）\"><a href=\"#7-Css3之3D转换-（Oprea不支持3D转换）\" class=\"headerlink\" title=\"7. Css3之3D转换 ##（Oprea不支持3D转换）\"></a>7. Css3之3D转换 ##（Oprea不支持3D转换）</h2><p><strong>7.1    3D旋转 rotateY()</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:hover&#123;transform: rotateY(180deg)&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110123324497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>框中的文字，其本身围绕Y轴旋转180°</p>\n<h2 id=\"8-Transition-过渡效果\"><a href=\"#8-Transition-过渡效果\" class=\"headerlink\" title=\"8.Transition 过渡效果\"></a>8.Transition 过渡效果</h2><p>兼容度：IE9及以下不支持该属性，需要优雅降级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;width:100px;height:100px;background:yellow;transition:width:width 2s;&#125;</span><br><span class=\"line\">div:hover&#123;width:300px;&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如图（鼠标移入，DIV变宽，鼠标移出，自动复原）：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111092602675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"鼠标移入，DIV变宽\" title=\"\" class=\"\">\n                <p>鼠标移入，DIV变宽</p>\n            </figure></p>\n<p>此时，我们在div:hover中重写了属性width，那么，在原始的div{transition}中，我们要说明，那个属性需要过渡效果，并注明过渡时间，此时肯定是transition:width 2s，如果有多个属性需要过渡效果，那么，就应该给出如下说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition:all 2s   //所有属性都需要过渡效果，并且所有效果同步过渡的总时长为2s.</span><br></pre></td></tr></table></figure>\n<p>如此一来，就可以实现类似于jquery的效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;div&apos;).animate(&#123;width:&apos;101px&apos;;height:&apos;101px&apos;;background:&apos;green&apos;;&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111115416020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>甚至可以规定过渡的delay延时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition-delay:0.5s;  //0.5秒延时以后开始动画效果。</span><br></pre></td></tr></table></figure>\n<p>效果与上图大同小异，不过有0.5s的移入和移出延时。<br>其实，在transition里有4个属性，分别是：<br>1.过渡的属性名称<br>2.过渡的总时长<br>3.过渡的方式:线性，缓慢等等<br>4.过渡的延时，即多少s以后才开始过渡<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">\ttransition-property: width;</span><br><span class=\"line\">\ttransition-duration: 1s;</span><br><span class=\"line\">\ttransition-timing-function: linear;</span><br><span class=\"line\">\ttransition-delay: 2s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;transition:width 2s linear 2s&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-CSS3-动画\"><a href=\"#9-CSS3-动画\" class=\"headerlink\" title=\"9.CSS3 动画\"></a>9.CSS3 动画</h2><p>之前一篇帖子对于动画部分做了一些探究：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78949964\" target=\"_blank\" rel=\"noopener\">关于CSS3呼吸效果的探究 </a><br>如果对于动画的需求比较复杂，需要持续重复的完成，可以考虑动画效果，如果只是简单的一些效果，完全可以采用transform来自己实现。</p>\n<h2 id=\"10-CSS-3-多列\"><a href=\"#10-CSS-3-多列\" class=\"headerlink\" title=\"10.CSS 3 多列\"></a>10.CSS 3 多列</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">-moz-column-count:3; /* Firefox */</span><br><span class=\"line\">-webkit-column-count:3; /* Safari and Chrome */</span><br><span class=\"line\">column-count:3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*将一个DIV分为三列*/</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111133322968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>以及最后的最后，有一个允许用户自定义元素大小(可拖拽拉伸)的属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">border:2px solid;</span><br><span class=\"line\">padding:10px 40px; </span><br><span class=\"line\">width:300px;</span><br><span class=\"line\">resize:both;</span><br><span class=\"line\">overflow:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111135633726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79019724\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"0-怪异盒模型\"><a href=\"#0-怪异盒模型\" class=\"headerlink\" title=\"0.怪异盒模型\"></a>0.怪异盒模型</h2><p>非IE及IE9及以上， 盒模型的构成为:content<br>老IE，IE8及以下， 盒模型为 content+border+padding<br>如果有这样一个DIV：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;width:100px;height:100px;border:1px solid black;padding:10px;&#125;</span><br></pre></td></tr></table></figure>\n<p>在非IE下，盒模型为：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110092905668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>在老IE下，盒模型为：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110092944223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>由此可见，老IE在计算盒模型时，加入了两个padding和border的值。</p>\n<h2 id=\"1-background-size\"><a href=\"#1-background-size\" class=\"headerlink\" title=\"1.background-size\"></a>1.background-size</h2><p>规定背景的位置。<br>eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#div&#123;background-size:cover;&#125;//覆盖整个div</span><br><span class=\"line\">#div&#123;background:url(img/123.png) no-repeat;background-size:10% 10%;&#125;//背景图片宽高为原始图片宽高的10%，且不重复</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-background-orgin\"><a href=\"#2-background-orgin\" class=\"headerlink\" title=\"2.background-orgin:\"></a>2.background-orgin:</h2><p>//可以选择的值为：content-box、margin-box、padding-box</p>\n<p><strong><em>content-box、margin-box、padding-box的区别</em></strong></p>\n<p>①content-box，即采用W3C标准渲染方法，不计算padding和border及margin，得出的盒子<br>②padding-box，渲染盒子的时候，把padding当做盒子宽高的组成部分，即在标准盒子模型的基础上，宽高都增加padding px。<br>③margin-box，同理，宽高都增加margin-box<br>3.border-radius  圆角边框，假如DIV 的  宽 = 高，即正方形，此时，如果border-radius = div 的宽/高，那么此时的div是一个圆形。如果border-radius远远大于div的宽/高，那么还是一个圆形，不会变化。<br>因此，background-origin的值，就取决于背景图从哪个盒子模型开始渲染。</p>\n<h2 id=\"4-text-shadow-水平偏移-垂直偏移-阴影距离文字的z-index距离-颜色\"><a href=\"#4-text-shadow-水平偏移-垂直偏移-阴影距离文字的z-index距离-颜色\" class=\"headerlink\" title=\"4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色\"></a>4.text-shadow : 水平偏移 垂直偏移 阴影距离文字的z-index距离 颜色</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">text-shadow: 225px 0px 0px #FF0000; /*水平偏移225，垂直不偏移 z-index为0 颜色为红色*/</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110095154859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<h2 id=\"5-font-face-自定义字体\"><a href=\"#5-font-face-自定义字体\" class=\"headerlink\" title=\"5.font-face 自定义字体\"></a>5.font-face 自定义字体</h2><p>兼容度：IE及IE8以下不支持，主流浏览器都支持。<br>关于自定义字体，请参见我之前的一篇博客：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78438174\" target=\"_blank\" rel=\"noopener\">自定义图标与百度Share API</a></p>\n<h2 id=\"6-Css3-之-2D转换-transform\"><a href=\"#6-Css3-之-2D转换-transform\" class=\"headerlink\" title=\"6.Css3 之 2D转换 (transform)\"></a>6.Css3 之 2D转换 (transform)</h2><p>释义：transform 改变;变换<br>兼容度：IE9及以上，主流浏览器都兼容。<br>下面列举的方法，都位于transform属性之下，例如：transform:rotate()、transform:translate()<br>主要的2D转换属性：<br><strong>6.1  位移：  translate()   方法 </strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;transform：translate(100px,100px)&#125; /*在原来位置的基础上，x轴移动10px，y轴移动10px*/</span><br></pre></td></tr></table></figure>\n<p>如图所示：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110101251395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure></p>\n<p>原本处于空白位置的DIV，现在x,y轴都平移了正的100px<br><strong>6.2 旋转   rotate() 方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">img&#123;transform：rotate(30deg)&#125;</span><br><span class=\"line\"> /*图片顺时针旋转30度，当然，也可以和css伪类配合完成一些效果 ，例如 ：*/</span><br><span class=\"line\"> img:hover&#123;transform:rotate(30deg)&#125; /*鼠标悬停，方可旋转*/</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110102120286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>由此可见，这个效果在一些圆形的图片上最为适用</p>\n<p><strong>6.3 比例/缩放 scale(x轴比例，y轴比例) 方法</strong><br>跟刚才的旋转同理，我们也可以给一个图片设定一:hover伪类，然后来观察效果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*文档结构：父div包含着一个图片，父div标准盒子模型100x100，原始图片100x100 */</span><br><span class=\"line\"></span><br><span class=\"line\">div&#123;width:101px;height:101px;overflow:hidden;border:1px solid black;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">img:hover&#123;transform: scale(1.5,1.5);&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110102627735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>这个效果也很常见。鼠标放进去放大，鼠标离开变成原始比例。<br>关于这一点，可以参照之前的博客：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78949964\" target=\"_blank\" rel=\"noopener\">关于CSS3呼吸效果的探究</a><br><strong>6.4 偏斜/歪斜  skew(x轴偏斜,y轴偏斜)</strong><br>以前见过很多用CSS3做的留言墙，skew属性用的比较多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img:hover&#123;transform:skew(30deg,30deg)&#125;</span><br></pre></td></tr></table></figure>\n<p>鉴于这个方法比较扭曲，就不上图了，值得注意的一点是，这个偏移量貌似根据tan来计算的，当我给这个方法传入90deg时，图片会不存在。<br><strong>6.5 矩阵/汇总方法 matrix</strong><br>martrix()接受6个参数，其实就是对于 平移、旋转、缩放、偏斜的汇总简写。<br>具体请参见张鑫旭大神的博客：<br><a href=\"http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/\" target=\"_blank\" rel=\"noopener\">理解CSS3 transform中的Matrix(矩阵)</a></p>\n<h2 id=\"7-Css3之3D转换-（Oprea不支持3D转换）\"><a href=\"#7-Css3之3D转换-（Oprea不支持3D转换）\" class=\"headerlink\" title=\"7. Css3之3D转换 ##（Oprea不支持3D转换）\"></a>7. Css3之3D转换 ##（Oprea不支持3D转换）</h2><p><strong>7.1    3D旋转 rotateY()</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:hover&#123;transform: rotateY(180deg)&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180110123324497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>框中的文字，其本身围绕Y轴旋转180°</p>\n<h2 id=\"8-Transition-过渡效果\"><a href=\"#8-Transition-过渡效果\" class=\"headerlink\" title=\"8.Transition 过渡效果\"></a>8.Transition 过渡效果</h2><p>兼容度：IE9及以下不支持该属性，需要优雅降级</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;width:100px;height:100px;background:yellow;transition:width:width 2s;&#125;</span><br><span class=\"line\">div:hover&#123;width:300px;&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如图（鼠标移入，DIV变宽，鼠标移出，自动复原）：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111092602675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"鼠标移入，DIV变宽\" title=\"\" class=\"\">\n                <p>鼠标移入，DIV变宽</p>\n            </figure></p>\n<p>此时，我们在div:hover中重写了属性width，那么，在原始的div{transition}中，我们要说明，那个属性需要过渡效果，并注明过渡时间，此时肯定是transition:width 2s，如果有多个属性需要过渡效果，那么，就应该给出如下说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition:all 2s   //所有属性都需要过渡效果，并且所有效果同步过渡的总时长为2s.</span><br></pre></td></tr></table></figure>\n<p>如此一来，就可以实现类似于jquery的效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;div&apos;).animate(&#123;width:&apos;101px&apos;;height:&apos;101px&apos;;background:&apos;green&apos;;&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111115416020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>甚至可以规定过渡的delay延时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition-delay:0.5s;  //0.5秒延时以后开始动画效果。</span><br></pre></td></tr></table></figure>\n<p>效果与上图大同小异，不过有0.5s的移入和移出延时。<br>其实，在transition里有4个属性，分别是：<br>1.过渡的属性名称<br>2.过渡的总时长<br>3.过渡的方式:线性，缓慢等等<br>4.过渡的延时，即多少s以后才开始过渡<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">\ttransition-property: width;</span><br><span class=\"line\">\ttransition-duration: 1s;</span><br><span class=\"line\">\ttransition-timing-function: linear;</span><br><span class=\"line\">\ttransition-delay: 2s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;transition:width 2s linear 2s&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-CSS3-动画\"><a href=\"#9-CSS3-动画\" class=\"headerlink\" title=\"9.CSS3 动画\"></a>9.CSS3 动画</h2><p>之前一篇帖子对于动画部分做了一些探究：<br><a href=\"http://blog.csdn.net/qq_20264891/article/details/78949964\" target=\"_blank\" rel=\"noopener\">关于CSS3呼吸效果的探究 </a><br>如果对于动画的需求比较复杂，需要持续重复的完成，可以考虑动画效果，如果只是简单的一些效果，完全可以采用transform来自己实现。</p>\n<h2 id=\"10-CSS-3-多列\"><a href=\"#10-CSS-3-多列\" class=\"headerlink\" title=\"10.CSS 3 多列\"></a>10.CSS 3 多列</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">-moz-column-count:3; /* Firefox */</span><br><span class=\"line\">-webkit-column-count:3; /* Safari and Chrome */</span><br><span class=\"line\">column-count:3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*将一个DIV分为三列*/</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111133322968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>以及最后的最后，有一个允许用户自定义元素大小(可拖拽拉伸)的属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">border:2px solid;</span><br><span class=\"line\">padding:10px 40px; </span><br><span class=\"line\">width:300px;</span><br><span class=\"line\">resize:both;</span><br><span class=\"line\">overflow:auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180111135633726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"javascript Dom拖动 插件 putThere.js","date":"2018-03-05T16:00:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79171972)\n\n\n\n## 开源地址： ##\n跪求各位看官给我点star吧 T.T，谢谢！\n[https://github.com/ZQ-jhon/putThere.js](https://github.com/ZQ-jhon/putThere.js)\n\n## 原理及构想 ##\n关于拖动，如果不用html5的原生事件，怎样实现呢？\n不妨先设想一下整个拖动的流程：\n\n 1. 点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute\n 2. 当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值)\n 3. 当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。\n\n## 代码 ##\n想好其中的原理，代码也就不那么难写了。\n```javascript\n//window监听\n               window.onmousedown=function(obj){\n               \n\t/*鼠标按下，dom元素脱离位置，变成绝对定位*/\n\tobj.style.position='absolute';\n\t\n}\n\nwindow.onmouseup=function(event){\n      var event = window.event||event;\n\t\t//获取鼠标距离浏览器边界的距离\n\t\tvar x = event.clientX;\n\t\t\n\t\tvar y = event.clientY;\n\t\t\n\t\t\n\t\tconsole.log('鼠标距离浏览器边界(0,0)的距离('+x+','+y+')')\n\t\t\n\t\t/*获取dom元素距离浏览器边界的x,y值*/\n\t\tvar left = obj.style.left;\n\t\t\n\t\tvar top = obj.style.top;\n\t\t\n\t\tconsole.log('Dom元素距离浏览器边界(0,0)的距离('+left+','+top+')')\n\t\t\n\t\t\n\t\t/*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/\n\t\tif(left>x||top>y){\n\t\t\n\t\t\tx=-x;\n\t\t\t\n\t\t\ty=-y;\n\t\t\t\n\t\t}\n\t\t\n\t\tobj.style.left = x+'px'; \n\t\t\n\t\tobj.style.top = y+'px';\n\t\t\n\t}\n};\n\n\n}\n```\n我将它封装成一个函数，调用的时候，形式如下：\n\n```javascript\nvar div = document.getElementById('div');\n\nputThere(div);\n\n此时，div元素可以在document中任意的拖动，改变位置。\n```\n## 效果预览： ##\n\n鼠标拖动div效果如下：\n![Demo效果预览](http://img.blog.csdn.net/20180126140231318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。\n## 兼容程度 ##\n实测 兼容 IE9及以上\n\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/javascript Dom拖动 插件 putThere.js.md","raw":"---\ntitle:  javascript Dom拖动 插件 putThere.js\ndate: 2018-03-06 00:00:00\ntags: [javascript , plug-in]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79171972)\n\n\n\n## 开源地址： ##\n跪求各位看官给我点star吧 T.T，谢谢！\n[https://github.com/ZQ-jhon/putThere.js](https://github.com/ZQ-jhon/putThere.js)\n\n## 原理及构想 ##\n关于拖动，如果不用html5的原生事件，怎样实现呢？\n不妨先设想一下整个拖动的流程：\n\n 1. 点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute\n 2. 当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值)\n 3. 当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。\n\n## 代码 ##\n想好其中的原理，代码也就不那么难写了。\n```javascript\n//window监听\n               window.onmousedown=function(obj){\n               \n\t/*鼠标按下，dom元素脱离位置，变成绝对定位*/\n\tobj.style.position='absolute';\n\t\n}\n\nwindow.onmouseup=function(event){\n      var event = window.event||event;\n\t\t//获取鼠标距离浏览器边界的距离\n\t\tvar x = event.clientX;\n\t\t\n\t\tvar y = event.clientY;\n\t\t\n\t\t\n\t\tconsole.log('鼠标距离浏览器边界(0,0)的距离('+x+','+y+')')\n\t\t\n\t\t/*获取dom元素距离浏览器边界的x,y值*/\n\t\tvar left = obj.style.left;\n\t\t\n\t\tvar top = obj.style.top;\n\t\t\n\t\tconsole.log('Dom元素距离浏览器边界(0,0)的距离('+left+','+top+')')\n\t\t\n\t\t\n\t\t/*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/\n\t\tif(left>x||top>y){\n\t\t\n\t\t\tx=-x;\n\t\t\t\n\t\t\ty=-y;\n\t\t\t\n\t\t}\n\t\t\n\t\tobj.style.left = x+'px'; \n\t\t\n\t\tobj.style.top = y+'px';\n\t\t\n\t}\n};\n\n\n}\n```\n我将它封装成一个函数，调用的时候，形式如下：\n\n```javascript\nvar div = document.getElementById('div');\n\nputThere(div);\n\n此时，div元素可以在document中任意的拖动，改变位置。\n```\n## 效果预览： ##\n\n鼠标拖动div效果如下：\n![Demo效果预览](http://img.blog.csdn.net/20180126140231318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。\n## 兼容程度 ##\n实测 兼容 IE9及以上\n\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"javascript Dom拖动 插件 putThere.js","published":1,"updated":"2018-08-29T06:01:02.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfx0014jgv4avx9cqd4","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79171972\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"开源地址：\"><a href=\"#开源地址：\" class=\"headerlink\" title=\"开源地址：\"></a>开源地址：</h2><p>跪求各位看官给我点star吧 T.T，谢谢！<br><a href=\"https://github.com/ZQ-jhon/putThere.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/putThere.js</a></p>\n<h2 id=\"原理及构想\"><a href=\"#原理及构想\" class=\"headerlink\" title=\"原理及构想\"></a>原理及构想</h2><p>关于拖动，如果不用html5的原生事件，怎样实现呢？<br>不妨先设想一下整个拖动的流程：</p>\n<ol>\n<li>点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute</li>\n<li>当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值)</li>\n<li>当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>想好其中的原理，代码也就不那么难写了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//window监听</span></span><br><span class=\"line\">               <span class=\"built_in\">window</span>.onmousedown=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">               </span><br><span class=\"line\">\t<span class=\"comment\">/*鼠标按下，dom元素脱离位置，变成绝对定位*/</span></span><br><span class=\"line\">\tobj.style.position=<span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onmouseup=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> event = <span class=\"built_in\">window</span>.event||event;</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取鼠标距离浏览器边界的距离</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> x = event.clientX;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> y = event.clientY;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'鼠标距离浏览器边界(0,0)的距离('</span>+x+<span class=\"string\">','</span>+y+<span class=\"string\">')'</span>)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*获取dom元素距离浏览器边界的x,y值*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> left = obj.style.left;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> top = obj.style.top;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Dom元素距离浏览器边界(0,0)的距离('</span>+left+<span class=\"string\">','</span>+top+<span class=\"string\">')'</span>)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(left&gt;x||top&gt;y)&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t\tx=-x;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\ty=-y;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tobj.style.left = x+<span class=\"string\">'px'</span>; </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tobj.style.top = y+<span class=\"string\">'px'</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我将它封装成一个函数，调用的时候，形式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">putThere(div);</span><br><span class=\"line\"></span><br><span class=\"line\">此时，div元素可以在<span class=\"built_in\">document</span>中任意的拖动，改变位置。</span><br></pre></td></tr></table></figure>\n<h2 id=\"效果预览：\"><a href=\"#效果预览：\" class=\"headerlink\" title=\"效果预览：\"></a>效果预览：</h2><p>鼠标拖动div效果如下：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180126140231318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Demo效果预览\" title=\"\" class=\"\">\n                <p>Demo效果预览</p>\n            </figure><br>可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。</p>\n<h2 id=\"兼容程度\"><a href=\"#兼容程度\" class=\"headerlink\" title=\"兼容程度\"></a>兼容程度</h2><p>实测 兼容 IE9及以上</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79171972\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"开源地址：\"><a href=\"#开源地址：\" class=\"headerlink\" title=\"开源地址：\"></a>开源地址：</h2><p>跪求各位看官给我点star吧 T.T，谢谢！<br><a href=\"https://github.com/ZQ-jhon/putThere.js\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/putThere.js</a></p>\n<h2 id=\"原理及构想\"><a href=\"#原理及构想\" class=\"headerlink\" title=\"原理及构想\"></a>原理及构想</h2><p>关于拖动，如果不用html5的原生事件，怎样实现呢？<br>不妨先设想一下整个拖动的流程：</p>\n<ol>\n<li>点击一个元素，鼠标按下，这个元素其实已经脱离了正常的定位，变成了绝对定位absolute</li>\n<li>当鼠标移动到目标位置的时候，我们来捕获鼠标当前的坐标值clientX,clientY(相对于浏览器视口位置的相对值)</li>\n<li>当松开鼠标，将鼠标的坐标值赋值给元素的left及top属性，如果此时，鼠标坐标值大于元素的left，或者top，说明元素在向右下角移动，反之同理。</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>想好其中的原理，代码也就不那么难写了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//window监听</span></span><br><span class=\"line\">               <span class=\"built_in\">window</span>.onmousedown=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">               </span><br><span class=\"line\">\t<span class=\"comment\">/*鼠标按下，dom元素脱离位置，变成绝对定位*/</span></span><br><span class=\"line\">\tobj.style.position=<span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onmouseup=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> event = <span class=\"built_in\">window</span>.event||event;</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取鼠标距离浏览器边界的距离</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> x = event.clientX;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> y = event.clientY;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'鼠标距离浏览器边界(0,0)的距离('</span>+x+<span class=\"string\">','</span>+y+<span class=\"string\">')'</span>)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*获取dom元素距离浏览器边界的x,y值*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> left = obj.style.left;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> top = obj.style.top;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Dom元素距离浏览器边界(0,0)的距离('</span>+left+<span class=\"string\">','</span>+top+<span class=\"string\">')'</span>)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*判断鼠标拖动的方向。x小于left，说明在向左拖动;y小于top，说明向上拖动。反之同理*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(left&gt;x||top&gt;y)&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t\tx=-x;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\ty=-y;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tobj.style.left = x+<span class=\"string\">'px'</span>; </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tobj.style.top = y+<span class=\"string\">'px'</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我将它封装成一个函数，调用的时候，形式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">putThere(div);</span><br><span class=\"line\"></span><br><span class=\"line\">此时，div元素可以在<span class=\"built_in\">document</span>中任意的拖动，改变位置。</span><br></pre></td></tr></table></figure>\n<h2 id=\"效果预览：\"><a href=\"#效果预览：\" class=\"headerlink\" title=\"效果预览：\"></a>效果预览：</h2><p>鼠标拖动div效果如下：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180126140231318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Demo效果预览\" title=\"\" class=\"\">\n                <p>Demo效果预览</p>\n            </figure><br>可以看到，基本上实现了【指哪打哪】的功能，鼠标的松开的坐标，就是div元素左上角定点的落点，其实刚开始封装插件的时候还想再加一个参数，用于选择元素的落点为左上角顶点或者中心位置，但是想了一下，似乎没有什么实际意义，遂放弃。</p>\n<h2 id=\"兼容程度\"><a href=\"#兼容程度\" class=\"headerlink\" title=\"兼容程度\"></a>兼容程度</h2><p>实测 兼容 IE9及以上</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单/双向绑定、组件通讯","date":"2018-03-24T16:00:00.000Z","reward":true,"comment":true,"_content":"\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/80698441)\n## 为什么要学angualr(4.0+)？##\n1. 无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。\n2. 微软收购了github，还不赶紧学ts？\n\n本文参考博客/资料：\n----------\n\n1.https://blog.csdn.net/u012967849/article/details/78767294/ （ng父子组件如何传值）\n2.https://www.angular.cn/ （ng中文官网）\n3.https://www.jianshu.com/p/a2b625a99c8d （ng的class和interface区别）\n\n本篇笔记所用环境及NG版本一览：\n----------------\n\n![NG版本](https://img-blog.csdn.net/20180614211344486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n## 文件目录 ##\n**1.组件的文件形式/结构：**\n形如：![components](https://img-blog.csdn.net/20180614211811858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。\n**2.打包入口：**\n app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。\n![moudle](https://img-blog.csdn.net/20180614211620198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n如图：\n在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。\n在@NgMoudle中，import则声明了使用的第三方库。\n在 declarations 中注册了子组件。\n**app目录不仅作为整个项目的打包入口，其本身也是一个根组件**。\n**3.模块划分：**\n 1. 根组件/模块 appMoudle\n 2. 英雄列表 => heroes 组件\n 3. 当前选择的英雄=> hero-detail组件\n\n ## 新的ng语法 ##\nng新语法:\n```\n\t*代表ng指令  不用ng-if,ng-for，类似于驼峰 ngFor ngIf \n\t()代表绑定事件   原生事件绑定直接写在括号里 (click) (keydown)\n\t[]单向绑定  代表绑定属性   [name] = 'jobs' \n\t[()] 双向绑定<input [(value=\"someValue\")] type=\"text\"/> \n\t\n```\n*官方称双向绑定写法叫盒子里的香蕉？？？？？？？*\n## 父子组件状态传递  ##\n\nStep1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。\nStep2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。\nStep2如图所示：\n![Step2](https://img-blog.csdn.net/20180614212726956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\nStep3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。\nStep3如图所示：\n![Step3](https://img-blog.csdn.net/20180614213345167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n在Vue中，通常是这样做的：\n子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。\nangular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。\n## 组件 运作/执行流程 的文字描述 ##\n\n - 列表组件渲染出Mock的数组 (列表组件 heroes 负责)\n - 为每一个渲染出的项，绑定事件，并传参 (同上)\n - 在列表组件heroes 的模版加入`<app-hero-detail [hero]=\"selectedHero\"></app-hero-detail>`，这样父组件的值已经通过单向绑定至子组件，**但接收与使用，决定权在于子组件**。（同上）\n - hero-detail组件接收父组件传递过来的数值，并在内部`import {Input} from '@angular/core'`（hero-detail组件负责）\n - 接着在export语句中，使用装饰器来声明+初始化 得到的属性` @Input() hero: Hero;`然后就可以用啦！  （hero-detail组件负责）\n\n## 整体逻辑代码 步骤 ##\n**Step 1**\n创建列表组件，使用`*ngFor`来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。\n\n```\n<li \n    *ngFor=\"let thisHero of heroes\" \n    (click)=\"onSelect(thisHero)\"\n>\n</li>\n```\n在对应的.ts文件中，这个方法为：\n\n```\n//方法\n\n /*定义参数类型为Hero类型，即从hero.ts导出的类：\n   export class Hero {\n    id: number;\n    name: string;\n  }\n  并且，设定该方法没有返回值。\n  */\nonSelect(hero: Hero): void {\n\n  //动态赋值\n  this.selectedHero = hero; \n  \n //业务逻辑相关\n  this.bool = !this.bool;\n  this.isSelected =  {\n\t\t   'badge':!this.bool,\n\t\t\t'selected':this.bool\n   }\n}\n```\n这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。\n**Step 2**\n在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：\n```\n<app-hero-detail [hero]=\"selectedHero\"></app-hero-detail>\n```\n把值绑定到子组件模版，这样，父组件的使命就结束了。\n**Step 3**\n子组件如何接收并使用父组件传来的值呢？\n首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）\n`import {Input} from '@angular/core'`\n接着，装饰器来申请接收传进来值，声明+初始化二连：\n```\n  @Input() hero: Hero;\n```\n哦，完事了。\n\n此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单双向绑定、组件通讯.md","raw":"---\ntitle:  ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单/双向绑定、组件通讯\ndate: 2018-03-25 00:00:00\ntags: [angular] \nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/80698441)\n## 为什么要学angualr(4.0+)？##\n1. 无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。\n2. 微软收购了github，还不赶紧学ts？\n\n本文参考博客/资料：\n----------\n\n1.https://blog.csdn.net/u012967849/article/details/78767294/ （ng父子组件如何传值）\n2.https://www.angular.cn/ （ng中文官网）\n3.https://www.jianshu.com/p/a2b625a99c8d （ng的class和interface区别）\n\n本篇笔记所用环境及NG版本一览：\n----------------\n\n![NG版本](https://img-blog.csdn.net/20180614211344486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n## 文件目录 ##\n**1.组件的文件形式/结构：**\n形如：![components](https://img-blog.csdn.net/20180614211811858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。\n**2.打包入口：**\n app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。\n![moudle](https://img-blog.csdn.net/20180614211620198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n如图：\n在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。\n在@NgMoudle中，import则声明了使用的第三方库。\n在 declarations 中注册了子组件。\n**app目录不仅作为整个项目的打包入口，其本身也是一个根组件**。\n**3.模块划分：**\n 1. 根组件/模块 appMoudle\n 2. 英雄列表 => heroes 组件\n 3. 当前选择的英雄=> hero-detail组件\n\n ## 新的ng语法 ##\nng新语法:\n```\n\t*代表ng指令  不用ng-if,ng-for，类似于驼峰 ngFor ngIf \n\t()代表绑定事件   原生事件绑定直接写在括号里 (click) (keydown)\n\t[]单向绑定  代表绑定属性   [name] = 'jobs' \n\t[()] 双向绑定<input [(value=\"someValue\")] type=\"text\"/> \n\t\n```\n*官方称双向绑定写法叫盒子里的香蕉？？？？？？？*\n## 父子组件状态传递  ##\n\nStep1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。\nStep2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。\nStep2如图所示：\n![Step2](https://img-blog.csdn.net/20180614212726956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\nStep3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。\nStep3如图所示：\n![Step3](https://img-blog.csdn.net/20180614213345167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n在Vue中，通常是这样做的：\n子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。\nangular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。\n## 组件 运作/执行流程 的文字描述 ##\n\n - 列表组件渲染出Mock的数组 (列表组件 heroes 负责)\n - 为每一个渲染出的项，绑定事件，并传参 (同上)\n - 在列表组件heroes 的模版加入`<app-hero-detail [hero]=\"selectedHero\"></app-hero-detail>`，这样父组件的值已经通过单向绑定至子组件，**但接收与使用，决定权在于子组件**。（同上）\n - hero-detail组件接收父组件传递过来的数值，并在内部`import {Input} from '@angular/core'`（hero-detail组件负责）\n - 接着在export语句中，使用装饰器来声明+初始化 得到的属性` @Input() hero: Hero;`然后就可以用啦！  （hero-detail组件负责）\n\n## 整体逻辑代码 步骤 ##\n**Step 1**\n创建列表组件，使用`*ngFor`来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。\n\n```\n<li \n    *ngFor=\"let thisHero of heroes\" \n    (click)=\"onSelect(thisHero)\"\n>\n</li>\n```\n在对应的.ts文件中，这个方法为：\n\n```\n//方法\n\n /*定义参数类型为Hero类型，即从hero.ts导出的类：\n   export class Hero {\n    id: number;\n    name: string;\n  }\n  并且，设定该方法没有返回值。\n  */\nonSelect(hero: Hero): void {\n\n  //动态赋值\n  this.selectedHero = hero; \n  \n //业务逻辑相关\n  this.bool = !this.bool;\n  this.isSelected =  {\n\t\t   'badge':!this.bool,\n\t\t\t'selected':this.bool\n   }\n}\n```\n这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。\n**Step 2**\n在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：\n```\n<app-hero-detail [hero]=\"selectedHero\"></app-hero-detail>\n```\n把值绑定到子组件模版，这样，父组件的使命就结束了。\n**Step 3**\n子组件如何接收并使用父组件传来的值呢？\n首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）\n`import {Input} from '@angular/core'`\n接着，装饰器来申请接收传进来值，声明+初始化二连：\n```\n  @Input() hero: Hero;\n```\n哦，完事了。\n\n此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"ng英雄列表学习笔记(一) 概念、文件结构、指令、事件、单双向绑定、组件通讯","published":1,"updated":"2018-08-29T06:01:20.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdfy0015jgv467b4eb01","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/80698441\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"为什么要学angualr-4-0-？\"><a href=\"#为什么要学angualr-4-0-？\" class=\"headerlink\" title=\"为什么要学angualr(4.0+)？\"></a>为什么要学angualr(4.0+)？</h2><ol>\n<li>无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。</li>\n<li>微软收购了github，还不赶紧学ts？</li>\n</ol>\n<h2 id=\"本文参考博客-资料：\"><a href=\"#本文参考博客-资料：\" class=\"headerlink\" title=\"本文参考博客/资料：\"></a>本文参考博客/资料：</h2><p>1.<a href=\"https://blog.csdn.net/u012967849/article/details/78767294/\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012967849/article/details/78767294/</a> （ng父子组件如何传值）<br>2.<a href=\"https://www.angular.cn/\" target=\"_blank\" rel=\"noopener\">https://www.angular.cn/</a> （ng中文官网）<br>3.<a href=\"https://www.jianshu.com/p/a2b625a99c8d\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/a2b625a99c8d</a> （ng的class和interface区别）</p>\n<h2 id=\"本篇笔记所用环境及NG版本一览：\"><a href=\"#本篇笔记所用环境及NG版本一览：\" class=\"headerlink\" title=\"本篇笔记所用环境及NG版本一览：\"></a>本篇笔记所用环境及NG版本一览：</h2><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614211344486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"NG版本\" title=\"\" class=\"\">\n                <p>NG版本</p>\n            </figure>\n<h2 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h2><p><strong>1.组件的文件形式/结构：</strong><br>形如：<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614211811858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"components\" title=\"\" class=\"\">\n                <p>components</p>\n            </figure><br>跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。<br><strong>2.打包入口：</strong><br> app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614211620198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"moudle\" title=\"\" class=\"\">\n                <p>moudle</p>\n            </figure><br>如图：<br>在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。<br>在@NgMoudle中，import则声明了使用的第三方库。<br>在 declarations 中注册了子组件。<br><strong>app目录不仅作为整个项目的打包入口，其本身也是一个根组件</strong>。<br><strong>3.模块划分：</strong></p>\n<ol>\n<li>根组件/模块 appMoudle</li>\n<li>英雄列表 =&gt; heroes 组件</li>\n<li><p>当前选择的英雄=&gt; hero-detail组件</p>\n<h2 id=\"新的ng语法\"><a href=\"#新的ng语法\" class=\"headerlink\" title=\"新的ng语法\"></a>新的ng语法</h2><p>ng新语法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*代表ng指令  不用ng-if,ng-for，类似于驼峰 ngFor ngIf </span><br><span class=\"line\">()代表绑定事件   原生事件绑定直接写在括号里 (click) (keydown)</span><br><span class=\"line\">[]单向绑定  代表绑定属性   [name] = &apos;jobs&apos; </span><br><span class=\"line\">[()] 双向绑定&lt;input [(value=&quot;someValue&quot;)] type=&quot;text&quot;/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><em>官方称双向绑定写法叫盒子里的香蕉？？？？？？？</em></p>\n<h2 id=\"父子组件状态传递\"><a href=\"#父子组件状态传递\" class=\"headerlink\" title=\"父子组件状态传递\"></a>父子组件状态传递</h2><p>Step1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。<br>Step2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。<br>Step2如图所示：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614212726956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"Step2\" title=\"\" class=\"\">\n                <p>Step2</p>\n            </figure><br>Step3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。<br>Step3如图所示：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614213345167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"Step3\" title=\"\" class=\"\">\n                <p>Step3</p>\n            </figure></p>\n<p>在Vue中，通常是这样做的：<br>子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。<br>angular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。</p>\n<h2 id=\"组件-运作-执行流程-的文字描述\"><a href=\"#组件-运作-执行流程-的文字描述\" class=\"headerlink\" title=\"组件 运作/执行流程 的文字描述\"></a>组件 运作/执行流程 的文字描述</h2><ul>\n<li>列表组件渲染出Mock的数组 (列表组件 heroes 负责)</li>\n<li>为每一个渲染出的项，绑定事件，并传参 (同上)</li>\n<li>在列表组件heroes 的模版加入<code>&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</code>，这样父组件的值已经通过单向绑定至子组件，<strong>但接收与使用，决定权在于子组件</strong>。（同上）</li>\n<li>hero-detail组件接收父组件传递过来的数值，并在内部<code>import {Input} from &#39;@angular/core&#39;</code>（hero-detail组件负责）</li>\n<li>接着在export语句中，使用装饰器来声明+初始化 得到的属性<code>@Input() hero: Hero;</code>然后就可以用啦！  （hero-detail组件负责）</li>\n</ul>\n<h2 id=\"整体逻辑代码-步骤\"><a href=\"#整体逻辑代码-步骤\" class=\"headerlink\" title=\"整体逻辑代码 步骤\"></a>整体逻辑代码 步骤</h2><p><strong>Step 1</strong><br>创建列表组件，使用<code>*ngFor</code>来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li </span><br><span class=\"line\">    *ngFor=&quot;let thisHero of heroes&quot; </span><br><span class=\"line\">    (click)=&quot;onSelect(thisHero)&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&lt;/li&gt;</span><br></pre></td></tr></table></figure>\n<p>在对应的.ts文件中，这个方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方法</span><br><span class=\"line\"></span><br><span class=\"line\"> /*定义参数类型为Hero类型，即从hero.ts导出的类：</span><br><span class=\"line\">   export class Hero &#123;</span><br><span class=\"line\">    id: number;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  并且，设定该方法没有返回值。</span><br><span class=\"line\">  */</span><br><span class=\"line\">onSelect(hero: Hero): void &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  //动态赋值</span><br><span class=\"line\">  this.selectedHero = hero; </span><br><span class=\"line\">  </span><br><span class=\"line\"> //业务逻辑相关</span><br><span class=\"line\">  this.bool = !this.bool;</span><br><span class=\"line\">  this.isSelected =  &#123;</span><br><span class=\"line\">\t\t   &apos;badge&apos;:!this.bool,</span><br><span class=\"line\">\t\t\t&apos;selected&apos;:this.bool</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。<br><strong>Step 2</strong><br>在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</span><br></pre></td></tr></table></figure></p>\n<p>把值绑定到子组件模版，这样，父组件的使命就结束了。<br><strong>Step 3</strong><br>子组件如何接收并使用父组件传来的值呢？<br>首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）<br><code>import {Input} from &#39;@angular/core&#39;</code><br>接着，装饰器来申请接收传进来值，声明+初始化二连：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Input() hero: Hero;</span><br></pre></td></tr></table></figure></p>\n<p>哦，完事了。</p>\n<p>此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/80698441\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"为什么要学angualr-4-0-？\"><a href=\"#为什么要学angualr-4-0-？\" class=\"headerlink\" title=\"为什么要学angualr(4.0+)？\"></a>为什么要学angualr(4.0+)？</h2><ol>\n<li>无论是轮子也好、库也好、框架也好，很大一部分初衷就是为了改善开发体验，提升开发效率，并且让代码更加优美，易于维护。从而节省出时间，将开发人员从繁忙的业务中解放。</li>\n<li>微软收购了github，还不赶紧学ts？</li>\n</ol>\n<h2 id=\"本文参考博客-资料：\"><a href=\"#本文参考博客-资料：\" class=\"headerlink\" title=\"本文参考博客/资料：\"></a>本文参考博客/资料：</h2><p>1.<a href=\"https://blog.csdn.net/u012967849/article/details/78767294/\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u012967849/article/details/78767294/</a> （ng父子组件如何传值）<br>2.<a href=\"https://www.angular.cn/\" target=\"_blank\" rel=\"noopener\">https://www.angular.cn/</a> （ng中文官网）<br>3.<a href=\"https://www.jianshu.com/p/a2b625a99c8d\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/a2b625a99c8d</a> （ng的class和interface区别）</p>\n<h2 id=\"本篇笔记所用环境及NG版本一览：\"><a href=\"#本篇笔记所用环境及NG版本一览：\" class=\"headerlink\" title=\"本篇笔记所用环境及NG版本一览：\"></a>本篇笔记所用环境及NG版本一览：</h2><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614211344486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"NG版本\" title=\"\" class=\"\">\n                <p>NG版本</p>\n            </figure>\n<h2 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h2><p><strong>1.组件的文件形式/结构：</strong><br>形如：<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614211811858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"components\" title=\"\" class=\"\">\n                <p>components</p>\n            </figure><br>跟单文件的.vue不一样，文件目录比较多，但是也易于查询和解耦。<br><strong>2.打包入口：</strong><br> app.moudle.ts为主要入口，负责装载所有的组件，以及声明一些第三方依赖的库。<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614211620198?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"moudle\" title=\"\" class=\"\">\n                <p>moudle</p>\n            </figure><br>如图：<br>在头部 import 声明了所有组件及依赖的原生组件(from @angular/core)。<br>在@NgMoudle中，import则声明了使用的第三方库。<br>在 declarations 中注册了子组件。<br><strong>app目录不仅作为整个项目的打包入口，其本身也是一个根组件</strong>。<br><strong>3.模块划分：</strong></p>\n<ol>\n<li>根组件/模块 appMoudle</li>\n<li>英雄列表 =&gt; heroes 组件</li>\n<li><p>当前选择的英雄=&gt; hero-detail组件</p>\n<h2 id=\"新的ng语法\"><a href=\"#新的ng语法\" class=\"headerlink\" title=\"新的ng语法\"></a>新的ng语法</h2><p>ng新语法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*代表ng指令  不用ng-if,ng-for，类似于驼峰 ngFor ngIf </span><br><span class=\"line\">()代表绑定事件   原生事件绑定直接写在括号里 (click) (keydown)</span><br><span class=\"line\">[]单向绑定  代表绑定属性   [name] = &apos;jobs&apos; </span><br><span class=\"line\">[()] 双向绑定&lt;input [(value=&quot;someValue&quot;)] type=&quot;text&quot;/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><em>官方称双向绑定写法叫盒子里的香蕉？？？？？？？</em></p>\n<h2 id=\"父子组件状态传递\"><a href=\"#父子组件状态传递\" class=\"headerlink\" title=\"父子组件状态传递\"></a>父子组件状态传递</h2><p>Step1: 父组件想要引用子组件时，不需要在ts逻辑中引用，因为本身没有像Vue那样，有 components:[ ] 这样的选项。<br>Step2: 父组件中引用子组件的模版，并且单向绑定一个hero属性，这个属性来源于父组件的一个变量值。<br>Step2如图所示：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614212726956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"Step2\" title=\"\" class=\"\">\n                <p>Step2</p>\n            </figure><br>Step3: 在子组件中，通过@Input来申请接收从 父组件中传递过来的属性。直接通过@Input() varitible 来声明/初始化即可。<br>Step3如图所示：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180614213345167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"Step3\" title=\"\" class=\"\">\n                <p>Step3</p>\n            </figure></p>\n<p>在Vue中，通常是这样做的：<br>子组件声明一个props数组，来表明接收了哪几个值，然后为己所用。<br>angular其实也是同理，子组件通过标签来单向绑定一个属性，并且在逻辑文件中申请接收/初始化这个属性。</p>\n<h2 id=\"组件-运作-执行流程-的文字描述\"><a href=\"#组件-运作-执行流程-的文字描述\" class=\"headerlink\" title=\"组件 运作/执行流程 的文字描述\"></a>组件 运作/执行流程 的文字描述</h2><ul>\n<li>列表组件渲染出Mock的数组 (列表组件 heroes 负责)</li>\n<li>为每一个渲染出的项，绑定事件，并传参 (同上)</li>\n<li>在列表组件heroes 的模版加入<code>&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</code>，这样父组件的值已经通过单向绑定至子组件，<strong>但接收与使用，决定权在于子组件</strong>。（同上）</li>\n<li>hero-detail组件接收父组件传递过来的数值，并在内部<code>import {Input} from &#39;@angular/core&#39;</code>（hero-detail组件负责）</li>\n<li>接着在export语句中，使用装饰器来声明+初始化 得到的属性<code>@Input() hero: Hero;</code>然后就可以用啦！  （hero-detail组件负责）</li>\n</ul>\n<h2 id=\"整体逻辑代码-步骤\"><a href=\"#整体逻辑代码-步骤\" class=\"headerlink\" title=\"整体逻辑代码 步骤\"></a>整体逻辑代码 步骤</h2><p><strong>Step 1</strong><br>创建列表组件，使用<code>*ngFor</code>来渲染出组件，并且每个组件绑定一个点击事件，传递的值为当前循环的每一个currentValue。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li </span><br><span class=\"line\">    *ngFor=&quot;let thisHero of heroes&quot; </span><br><span class=\"line\">    (click)=&quot;onSelect(thisHero)&quot;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&lt;/li&gt;</span><br></pre></td></tr></table></figure>\n<p>在对应的.ts文件中，这个方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方法</span><br><span class=\"line\"></span><br><span class=\"line\"> /*定义参数类型为Hero类型，即从hero.ts导出的类：</span><br><span class=\"line\">   export class Hero &#123;</span><br><span class=\"line\">    id: number;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  并且，设定该方法没有返回值。</span><br><span class=\"line\">  */</span><br><span class=\"line\">onSelect(hero: Hero): void &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  //动态赋值</span><br><span class=\"line\">  this.selectedHero = hero; </span><br><span class=\"line\">  </span><br><span class=\"line\"> //业务逻辑相关</span><br><span class=\"line\">  this.bool = !this.bool;</span><br><span class=\"line\">  this.isSelected =  &#123;</span><br><span class=\"line\">\t\t   &apos;badge&apos;:!this.bool,</span><br><span class=\"line\">\t\t\t&apos;selected&apos;:this.bool</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，每个循环出的item，在点击的时候，会把自己的值传递给该方法，从而进行后续业务逻辑处理。<br><strong>Step 2</strong><br>在列表渲染组件（父组件）中，引入子组件模版，并且通过单向绑定传值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;</span><br></pre></td></tr></table></figure></p>\n<p>把值绑定到子组件模版，这样，父组件的使命就结束了。<br><strong>Step 3</strong><br>子组件如何接收并使用父组件传来的值呢？<br>首先，引入内置的接收装饰器模型（不知道这种叫法是否严谨）<br><code>import {Input} from &#39;@angular/core&#39;</code><br>接着，装饰器来申请接收传进来值，声明+初始化二连：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Input() hero: Hero;</span><br></pre></td></tr></table></figure></p>\n<p>哦，完事了。</p>\n<p>此时，这个hero相当于一个变量，存在于子组件中，并且，通过单向绑定，动态的与父组件同步。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"TypeScript学习笔记","date":"2018-03-11T10:28:38.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79324863)\n\n##  前言 ##\nTypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8...提前为将来的ES标准打下基础。\n    学习tsc，不亏!\n## 环境搭建  ##\n```\n$ cnpm install -g typescript\n```\n完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下：\n\n```\n$ cd your File_path\n$ tsc File_name.ts\n```\nOK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。\n\n![tsc](http://img.blog.csdn.net/20180214112403989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 类型检测##\n1.基本类型检测\n\n在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如：\n\n\n```\nlet a:number = 1;  //OK\n\nlet a:string = 1;  //error\n\n类型检测的语法，就是在变量屁股后面缀上 :类型\n\n```\n\n\n\n2.数组的类型检测：\n\n```\nlet arr:number[]=[1,2,3];   //ok   类型+[]\n \nlet brr:Array<number>=[4,5,6]; //OK  数组泛型+尖括号< 类型 >\n```\n3.元组类型 Tupe \n\n```\nlet X:[number,string];\nx=[1,'hello']; //OK\nx=[1,2];  //type error\n元组类型适用于已知个数和元素类型的数组。\n```\n\n\n## 字符串拼接及字符串模板 ##\n\n\n拼接：跟ES6一样，通过`（``）`来实现，【`】为Tab上面的按键。\n\nfor eg  :\n\n```\nlet hi= (`\nhello,\nwrold!\n`);\n\n//输出 hello,world!\n```\n字符串模板：提供一种更优雅的书写方式：`${ 变量名}`\n\nfor eg:\n\n```\nlet names:string = 'xiaoming';\n\nlet age:number = 23;\n\nlet sentence:string = (`\n\nhello,my name is ${names},my age is ${age}\n\n`);\n\n```\n编译后的js文件为:\n\n```\nvar names = 'xiaoming';\n\nvar age = 23;\n\nvar sentence = (\"\\nhello,my name is \" + names + \",my age is \" + age + \"\\n\");\n\ndocument.body.innerHTML = sentence;\n\n```\n\n## 枚举类型 ##\n\n\n```typescript\nenum flower {a,b,c,d,e,f,g};  //enum关键字，后跟枚举类型的命名\n\nlet rouse:flower = flower.a;  //定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性\n\nalert(rouse);  // 0 表明rouse映射的对象，在flower中的index为0\n\n```\n## Any类型 ##\n有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。\n\n\n![any类型](http://img.blog.csdn.net/20180214120224290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nlet不能重复定义，我就用var来演示。\n\n\nAny类型也可以像数组的第一种定义方法一样，形如：\n\n```\nArray:\n\nlet arr:number[]=[1,2,3];  // OK\n\n数字的组合，可不就是数组吗？\n\n\n字符串组、布尔值组...\n\nlet brr:string[] = ['a','b','c'];\n\nlet crr:boolean[] = [true,false];\n\n\nAny:\n\nlet drr:any[]=[1,'2',true];  //  OK\n\n\n只知道是个类似于数组的数据类型，但是对元素的类型不做限制。\n\n```\n\n## Void类型##\n\n\nvoid类型表示空。常用在函数返回值，形如：\n\n```\n//注意函数返回值类型检测的写法\nfunction foo():void{\n\nalert('123');\n\n};\n\n```\n其实，void包含两种数据类型，就是null和undefind。\n\n触类旁通，其实还有两个类型是null和undefind，如图所示：\n\n![null&undefind](http://img.blog.csdn.net/20180214121723225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。\n## 类型断言 ##\n\n作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。\n写法一：\n\n\n\n```\nlet a:number =1; \n\nlet b:any = <number>a ;  //赋值\n```\n第二种写法:\n\n![类型断言](http://img.blog.csdn.net/20180214131500183?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n## Let ##\n\n来看这样一段代码：\n![for循环实例](http://img.blog.csdn.net/20180220191341275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？\n\n![运行结果](http://img.blog.csdn.net/20180220191448648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。\n\n**究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果**\n\n将上述代码的`var i`改为`let i`这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。\n因此，代码结果如下图所示：\n\n![let执行结果](http://img.blog.csdn.net/20180220191954426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n再来看一个对比：\n\n![使用var声明](http://img.blog.csdn.net/20180220193631816?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n将var 改为let \n\n\n![使用let声明](http://img.blog.csdn.net/20180220193713998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n可见，两种声明，是一摸一样的输出，为什么呢？\nvar的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次`for(let i=0;i<5;i++)`的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。\n**因为这里没有异步函数**，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。\n\n总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。\n\n## Const ##\n定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。\neg:\n\n```\nconst a = 1 ;\n\nconst a = 2 ; //error\n```\n\n## 结构赋值 ##\n\n普通结构赋值：\n\n![普通结构赋值](http://img.blog.csdn.net/20180220195746635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n函数参数结构赋值：\n\n![函数结构赋值](http://img.blog.csdn.net/20180220200215178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。\n\n\n\n## 数组中的【...】解构语法 ##\n\n![数组解构](http://img.blog.csdn.net/20180220200938878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n输出：\n\n![输出](http://img.blog.csdn.net/20180220201035491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。\n\n## 对象解构 ##\n\n\n![对象解构](http://img.blog.csdn.net/2018022020404810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n**直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。**\n\n**下图是错误示范**：\n\n\n![对象解构错误示范](http://img.blog.csdn.net/20180220204209671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n那么同理，如果在一个方法中返回对象，同样也可以被解构。\n![函数返回的对象也可以解构赋值](http://img.blog.csdn.net/2018022113342527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n如果对象存在嵌套现象，可以使用冒号表达式：\n\n![嵌套的对象，使用冒号表达式来嵌套化结构](http://img.blog.csdn.net/20180221133915180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n## 展开 ##\n\n还是使用...语法，进行数组或者对象的浅拷贝。\n\n\n数组展开，形如：\n![数组展开](http://img.blog.csdn.net/20180220205541321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n对象展开，形如：\n\n![对象展开](http://img.blog.csdn.net/20180220205712494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n**对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。**\n\n\n\n\n## 可选参数、默认参数 ##\n\n```\nfunction test(a:string,b?:string,c=\"wang\"){\nconsole.log(a)\nconsole.log(b)\nconsole.log(c)\n\n}\n\na为string类型，b为可选参数(string类型)，c是有默认值的参数\n\n```\n\n**确定的参数要现在第一个，不能把可选参数写在第一位。**\n\n## 函数断点Yield ##\n在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。\n\n```\nfunction* foo(){\n    console.log(1);\n    yield; //设置断点，下同\n\n    console.log(2);\n\n    yield;\n\n    console.log(3);\n\n    yield;\n};\n\n/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。\n *必须重新赋值，再调用。\n */\n\nlet zoo =  foo(); \n\n//这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。\nzoo.next();//1\nzoo.next();//2\nzoo.next();//3\n```\n\n## 箭头函数 ##\n作用一：主要用于声明匿名函数，简化代码。\n```\nvar sum = (a,b)=>a+b\n\n上式等价于：\nvar sum = function (a,b){\nretrun a+b;\n};\n```\n作用二：消除this指针带来的歧义,优化执行上下文。\n\n```\nfunction getName (name) { \n this.name = name ;\n  setInterval(function () { console.log('name is '+this.name)},1000)\n};\n\nvar john = new getName('jhon');\nconsole.log(john)       // 打印 name is (空)\n```\n\n这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。\n\n使用箭头函数改造：\n\n```\nfunction getName (name) { \n this.name = name ;\n    setInterval(() => console.log('name is '+this.name)),1000)\n};\n\nvar john = new getName('jhon');\nconsole.log(john)       // 打印 name is jhon\n```\n\n## For...of循环 ##\n**for...in 循环对象的下标**\n\n```\nvar arr = [1, 2, 3, 4];\narr.name = 'myArr';\n\nfor (var n in arr) { \n    console.log(n+'=='+arr[n])\n}\n//输出0=1,1=2,2=3,3=4,name=myArr\n```\n\n**for of 循环对象的key**\n\n```\nvar arr = [1, 2, 3, 4];\narr.name = 'myArr';\n\nfor (var n of arr) { \n    console.log(n+'=='+arr[n])\n}\n//输出0=1,1=2,2=3,3=4,undefind\n\n//还可以循环字符串\nvar arr ='hello,world!'\n\n\nfor (var n of arr) { \n    console.log(n)\n}\n//h,e,l,l,o,，w,o,r,l,d,!;\n\n```\n\n**forEach  循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性**\n\n```\nvar arr = [1, 2, 3, 4];\narr.name = 'myArr';\n\narr.forEach(function (n,v) { \n    console.log(n,v)\n})\n//输出1,2,3,4，但是没有输出我们定义的name\n```\n总结：for...in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for...of有点鸡肋，但是胜在使用场景广泛。\n\n\n## interface接口 ##\ninterface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。\n\n![interface](http://img.blog.csdn.net/2018022210063595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n当然，接口中预先定义的变量，也可以规定/限制函数中的参数：\n\n![限制函数中的参数](http://img.blog.csdn.net/20180222103808977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n## 基于Class的继承 ##\n\n在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script!\n\n![基于Class的继承](http://img.blog.csdn.net/20180220210913277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n访问权限关键字：\n**public** 公共成员。  子类、父类内部都可以访问到。\n\n**private** 私有成员。只允许在类中访问。\n\n**protected** 超类的私有成员。但是在子类中仍然可以访问。\n\n构造器Construcor：\n\n```\n//形如：\nconstructor(){\n name?string;\n};\n\n```\n在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。\n\n举例说明：\n\n\n![构造器内部的变量无法被全局访问](http://img.blog.csdn.net/20180222105023915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n这时候，只要在构造器的name上增加关键字`public`，即可在class中全局访问：\n\n\n\n![加上public，没有报错](http://img.blog.csdn.net/20180222105147415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n**类的继承**\n真的比基于原型链的继承更加优雅和简便。\n![通过extends关键字实现继承](http://img.blog.csdn.net/20180222105737601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/typescript学习笔记.md","raw":"---\ntitle:  TypeScript学习笔记\ndate:   2018-03-11 18:28:38\ntags: [typescript,编译,javascript,工具]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79324863)\n\n##  前言 ##\nTypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8...提前为将来的ES标准打下基础。\n    学习tsc，不亏!\n## 环境搭建  ##\n```\n$ cnpm install -g typescript\n```\n完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下：\n\n```\n$ cd your File_path\n$ tsc File_name.ts\n```\nOK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。\n\n![tsc](http://img.blog.csdn.net/20180214112403989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n## 类型检测##\n1.基本类型检测\n\n在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如：\n\n\n```\nlet a:number = 1;  //OK\n\nlet a:string = 1;  //error\n\n类型检测的语法，就是在变量屁股后面缀上 :类型\n\n```\n\n\n\n2.数组的类型检测：\n\n```\nlet arr:number[]=[1,2,3];   //ok   类型+[]\n \nlet brr:Array<number>=[4,5,6]; //OK  数组泛型+尖括号< 类型 >\n```\n3.元组类型 Tupe \n\n```\nlet X:[number,string];\nx=[1,'hello']; //OK\nx=[1,2];  //type error\n元组类型适用于已知个数和元素类型的数组。\n```\n\n\n## 字符串拼接及字符串模板 ##\n\n\n拼接：跟ES6一样，通过`（``）`来实现，【`】为Tab上面的按键。\n\nfor eg  :\n\n```\nlet hi= (`\nhello,\nwrold!\n`);\n\n//输出 hello,world!\n```\n字符串模板：提供一种更优雅的书写方式：`${ 变量名}`\n\nfor eg:\n\n```\nlet names:string = 'xiaoming';\n\nlet age:number = 23;\n\nlet sentence:string = (`\n\nhello,my name is ${names},my age is ${age}\n\n`);\n\n```\n编译后的js文件为:\n\n```\nvar names = 'xiaoming';\n\nvar age = 23;\n\nvar sentence = (\"\\nhello,my name is \" + names + \",my age is \" + age + \"\\n\");\n\ndocument.body.innerHTML = sentence;\n\n```\n\n## 枚举类型 ##\n\n\n```typescript\nenum flower {a,b,c,d,e,f,g};  //enum关键字，后跟枚举类型的命名\n\nlet rouse:flower = flower.a;  //定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性\n\nalert(rouse);  // 0 表明rouse映射的对象，在flower中的index为0\n\n```\n## Any类型 ##\n有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。\n\n\n![any类型](http://img.blog.csdn.net/20180214120224290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nlet不能重复定义，我就用var来演示。\n\n\nAny类型也可以像数组的第一种定义方法一样，形如：\n\n```\nArray:\n\nlet arr:number[]=[1,2,3];  // OK\n\n数字的组合，可不就是数组吗？\n\n\n字符串组、布尔值组...\n\nlet brr:string[] = ['a','b','c'];\n\nlet crr:boolean[] = [true,false];\n\n\nAny:\n\nlet drr:any[]=[1,'2',true];  //  OK\n\n\n只知道是个类似于数组的数据类型，但是对元素的类型不做限制。\n\n```\n\n## Void类型##\n\n\nvoid类型表示空。常用在函数返回值，形如：\n\n```\n//注意函数返回值类型检测的写法\nfunction foo():void{\n\nalert('123');\n\n};\n\n```\n其实，void包含两种数据类型，就是null和undefind。\n\n触类旁通，其实还有两个类型是null和undefind，如图所示：\n\n![null&undefind](http://img.blog.csdn.net/20180214121723225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。\n## 类型断言 ##\n\n作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。\n写法一：\n\n\n\n```\nlet a:number =1; \n\nlet b:any = <number>a ;  //赋值\n```\n第二种写法:\n\n![类型断言](http://img.blog.csdn.net/20180214131500183?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n## Let ##\n\n来看这样一段代码：\n![for循环实例](http://img.blog.csdn.net/20180220191341275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？\n\n![运行结果](http://img.blog.csdn.net/20180220191448648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。\n\n**究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果**\n\n将上述代码的`var i`改为`let i`这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。\n因此，代码结果如下图所示：\n\n![let执行结果](http://img.blog.csdn.net/20180220191954426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n再来看一个对比：\n\n![使用var声明](http://img.blog.csdn.net/20180220193631816?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n将var 改为let \n\n\n![使用let声明](http://img.blog.csdn.net/20180220193713998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n可见，两种声明，是一摸一样的输出，为什么呢？\nvar的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次`for(let i=0;i<5;i++)`的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。\n**因为这里没有异步函数**，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。\n\n总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。\n\n## Const ##\n定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。\neg:\n\n```\nconst a = 1 ;\n\nconst a = 2 ; //error\n```\n\n## 结构赋值 ##\n\n普通结构赋值：\n\n![普通结构赋值](http://img.blog.csdn.net/20180220195746635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n函数参数结构赋值：\n\n![函数结构赋值](http://img.blog.csdn.net/20180220200215178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。\n\n\n\n## 数组中的【...】解构语法 ##\n\n![数组解构](http://img.blog.csdn.net/20180220200938878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n输出：\n\n![输出](http://img.blog.csdn.net/20180220201035491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。\n\n## 对象解构 ##\n\n\n![对象解构](http://img.blog.csdn.net/2018022020404810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n**直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。**\n\n**下图是错误示范**：\n\n\n![对象解构错误示范](http://img.blog.csdn.net/20180220204209671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n那么同理，如果在一个方法中返回对象，同样也可以被解构。\n![函数返回的对象也可以解构赋值](http://img.blog.csdn.net/2018022113342527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n如果对象存在嵌套现象，可以使用冒号表达式：\n\n![嵌套的对象，使用冒号表达式来嵌套化结构](http://img.blog.csdn.net/20180221133915180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n## 展开 ##\n\n还是使用...语法，进行数组或者对象的浅拷贝。\n\n\n数组展开，形如：\n![数组展开](http://img.blog.csdn.net/20180220205541321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n对象展开，形如：\n\n![对象展开](http://img.blog.csdn.net/20180220205712494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n**对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。**\n\n\n\n\n## 可选参数、默认参数 ##\n\n```\nfunction test(a:string,b?:string,c=\"wang\"){\nconsole.log(a)\nconsole.log(b)\nconsole.log(c)\n\n}\n\na为string类型，b为可选参数(string类型)，c是有默认值的参数\n\n```\n\n**确定的参数要现在第一个，不能把可选参数写在第一位。**\n\n## 函数断点Yield ##\n在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。\n\n```\nfunction* foo(){\n    console.log(1);\n    yield; //设置断点，下同\n\n    console.log(2);\n\n    yield;\n\n    console.log(3);\n\n    yield;\n};\n\n/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。\n *必须重新赋值，再调用。\n */\n\nlet zoo =  foo(); \n\n//这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。\nzoo.next();//1\nzoo.next();//2\nzoo.next();//3\n```\n\n## 箭头函数 ##\n作用一：主要用于声明匿名函数，简化代码。\n```\nvar sum = (a,b)=>a+b\n\n上式等价于：\nvar sum = function (a,b){\nretrun a+b;\n};\n```\n作用二：消除this指针带来的歧义,优化执行上下文。\n\n```\nfunction getName (name) { \n this.name = name ;\n  setInterval(function () { console.log('name is '+this.name)},1000)\n};\n\nvar john = new getName('jhon');\nconsole.log(john)       // 打印 name is (空)\n```\n\n这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。\n\n使用箭头函数改造：\n\n```\nfunction getName (name) { \n this.name = name ;\n    setInterval(() => console.log('name is '+this.name)),1000)\n};\n\nvar john = new getName('jhon');\nconsole.log(john)       // 打印 name is jhon\n```\n\n## For...of循环 ##\n**for...in 循环对象的下标**\n\n```\nvar arr = [1, 2, 3, 4];\narr.name = 'myArr';\n\nfor (var n in arr) { \n    console.log(n+'=='+arr[n])\n}\n//输出0=1,1=2,2=3,3=4,name=myArr\n```\n\n**for of 循环对象的key**\n\n```\nvar arr = [1, 2, 3, 4];\narr.name = 'myArr';\n\nfor (var n of arr) { \n    console.log(n+'=='+arr[n])\n}\n//输出0=1,1=2,2=3,3=4,undefind\n\n//还可以循环字符串\nvar arr ='hello,world!'\n\n\nfor (var n of arr) { \n    console.log(n)\n}\n//h,e,l,l,o,，w,o,r,l,d,!;\n\n```\n\n**forEach  循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性**\n\n```\nvar arr = [1, 2, 3, 4];\narr.name = 'myArr';\n\narr.forEach(function (n,v) { \n    console.log(n,v)\n})\n//输出1,2,3,4，但是没有输出我们定义的name\n```\n总结：for...in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for...of有点鸡肋，但是胜在使用场景广泛。\n\n\n## interface接口 ##\ninterface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。\n\n![interface](http://img.blog.csdn.net/2018022210063595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n当然，接口中预先定义的变量，也可以规定/限制函数中的参数：\n\n![限制函数中的参数](http://img.blog.csdn.net/20180222103808977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n## 基于Class的继承 ##\n\n在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script!\n\n![基于Class的继承](http://img.blog.csdn.net/20180220210913277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n访问权限关键字：\n**public** 公共成员。  子类、父类内部都可以访问到。\n\n**private** 私有成员。只允许在类中访问。\n\n**protected** 超类的私有成员。但是在子类中仍然可以访问。\n\n构造器Construcor：\n\n```\n//形如：\nconstructor(){\n name?string;\n};\n\n```\n在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。\n\n举例说明：\n\n\n![构造器内部的变量无法被全局访问](http://img.blog.csdn.net/20180222105023915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n这时候，只要在构造器的name上增加关键字`public`，即可在class中全局访问：\n\n\n\n![加上public，没有报错](http://img.blog.csdn.net/20180222105147415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n**类的继承**\n真的比基于原型链的继承更加优雅和简便。\n![通过extends关键字实现继承](http://img.blog.csdn.net/20180222105737601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"typescript学习笔记","published":1,"updated":"2018-08-29T06:01:35.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdg00018jgv4j749r9bz","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79324863\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>TypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8…提前为将来的ES标准打下基础。<br>    学习tsc，不亏!</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd your File_path</span><br><span class=\"line\">$ tsc File_name.ts</span><br></pre></td></tr></table></figure>\n<p>OK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180214112403989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"tsc\" title=\"\" class=\"\">\n                <p>tsc</p>\n            </figure>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><p>1.基本类型检测</p>\n<p>在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a:number = 1;  //OK</span><br><span class=\"line\"></span><br><span class=\"line\">let a:string = 1;  //error</span><br><span class=\"line\"></span><br><span class=\"line\">类型检测的语法，就是在变量屁股后面缀上 :类型</span><br></pre></td></tr></table></figure>\n<p>2.数组的类型检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr:number[]=[1,2,3];   //ok   类型+[]</span><br><span class=\"line\"> </span><br><span class=\"line\">let brr:Array&lt;number&gt;=[4,5,6]; //OK  数组泛型+尖括号&lt; 类型 &gt;</span><br></pre></td></tr></table></figure>\n<p>3.元组类型 Tupe </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let X:[number,string];</span><br><span class=\"line\">x=[1,&apos;hello&apos;]; //OK</span><br><span class=\"line\">x=[1,2];  //type error</span><br><span class=\"line\">元组类型适用于已知个数和元素类型的数组。</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串拼接及字符串模板\"><a href=\"#字符串拼接及字符串模板\" class=\"headerlink\" title=\"字符串拼接及字符串模板\"></a>字符串拼接及字符串模板</h2><p>拼接：跟ES6一样，通过<code>（`</code>）<code>来实现，【</code>】为Tab上面的按键。</p>\n<p>for eg  :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let hi= (`</span><br><span class=\"line\">hello,</span><br><span class=\"line\">wrold!</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">//输出 hello,world!</span><br></pre></td></tr></table></figure>\n<p>字符串模板：提供一种更优雅的书写方式：<code>${ 变量名}</code></p>\n<p>for eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let names:string = &apos;xiaoming&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">let age:number = 23;</span><br><span class=\"line\"></span><br><span class=\"line\">let sentence:string = (`</span><br><span class=\"line\"></span><br><span class=\"line\">hello,my name is $&#123;names&#125;,my age is $&#123;age&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">`);</span><br></pre></td></tr></table></figure>\n<p>编译后的js文件为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var names = &apos;xiaoming&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var age = 23;</span><br><span class=\"line\"></span><br><span class=\"line\">var sentence = (&quot;\\nhello,my name is &quot; + names + &quot;,my age is &quot; + age + &quot;\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">document.body.innerHTML = sentence;</span><br></pre></td></tr></table></figure>\n<h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> flower &#123;a,b,c,d,e,f,g&#125;;  <span class=\"comment\">//enum关键字，后跟枚举类型的命名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> rouse:flower = flower.a;  <span class=\"comment\">//定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(rouse);  <span class=\"comment\">// 0 表明rouse映射的对象，在flower中的index为0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Any类型\"><a href=\"#Any类型\" class=\"headerlink\" title=\"Any类型\"></a>Any类型</h2><p>有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。</p>\n<p><img src=\"http://img.blog.csdn.net/20180214120224290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"any类型\"></p>\n<p>let不能重复定义，我就用var来演示。</p>\n<p>Any类型也可以像数组的第一种定义方法一样，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array:</span><br><span class=\"line\"></span><br><span class=\"line\">let arr:number[]=[1,2,3];  // OK</span><br><span class=\"line\"></span><br><span class=\"line\">数字的组合，可不就是数组吗？</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">字符串组、布尔值组...</span><br><span class=\"line\"></span><br><span class=\"line\">let brr:string[] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">let crr:boolean[] = [true,false];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Any:</span><br><span class=\"line\"></span><br><span class=\"line\">let drr:any[]=[1,&apos;2&apos;,true];  //  OK</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">只知道是个类似于数组的数据类型，但是对元素的类型不做限制。</span><br></pre></td></tr></table></figure>\n<h2 id=\"Void类型\"><a href=\"#Void类型\" class=\"headerlink\" title=\"Void类型\"></a>Void类型</h2><p>void类型表示空。常用在函数返回值，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意函数返回值类型检测的写法</span><br><span class=\"line\">function foo():void&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(&apos;123&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实，void包含两种数据类型，就是null和undefind。</p>\n<p>触类旁通，其实还有两个类型是null和undefind，如图所示：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180214121723225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"null&undefind\" title=\"\" class=\"\">\n                <p>null&undefind</p>\n            </figure>\n<p>如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。</p>\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。<br>写法一：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a:number =1; </span><br><span class=\"line\"></span><br><span class=\"line\">let b:any = &lt;number&gt;a ;  //赋值</span><br></pre></td></tr></table></figure>\n<p>第二种写法:</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180214131500183?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"类型断言\" title=\"\" class=\"\">\n                <p>类型断言</p>\n            </figure>\n<h2 id=\"Let\"><a href=\"#Let\" class=\"headerlink\" title=\"Let\"></a>Let</h2><p>来看这样一段代码：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220191341275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"for循环实例\" title=\"\" class=\"\">\n                <p>for循环实例</p>\n            </figure></p>\n<p>在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220191448648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"运行结果\" title=\"\" class=\"\">\n                <p>运行结果</p>\n            </figure>\n<p>可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。</p>\n<p><strong>究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果</strong></p>\n<p>将上述代码的<code>var i</code>改为<code>let i</code>这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。<br>因此，代码结果如下图所示：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220191954426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"let执行结果\" title=\"\" class=\"\">\n                <p>let执行结果</p>\n            </figure>\n<p>再来看一个对比：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220193631816?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"使用var声明\" title=\"\" class=\"\">\n                <p>使用var声明</p>\n            </figure>\n<p>将var 改为let </p>\n<p><img src=\"http://img.blog.csdn.net/20180220193713998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"使用let声明\"></p>\n<p>可见，两种声明，是一摸一样的输出，为什么呢？<br>var的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次<code>for(let i=0;i&lt;5;i++)</code>的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。<br><strong>因为这里没有异步函数</strong>，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。</p>\n<p>总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。</p>\n<h2 id=\"Const\"><a href=\"#Const\" class=\"headerlink\" title=\"Const\"></a>Const</h2><p>定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。<br>eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = 1 ;</span><br><span class=\"line\"></span><br><span class=\"line\">const a = 2 ; //error</span><br></pre></td></tr></table></figure>\n<h2 id=\"结构赋值\"><a href=\"#结构赋值\" class=\"headerlink\" title=\"结构赋值\"></a>结构赋值</h2><p>普通结构赋值：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220195746635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"普通结构赋值\" title=\"\" class=\"\">\n                <p>普通结构赋值</p>\n            </figure>\n<p>函数参数结构赋值：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220200215178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"函数结构赋值\" title=\"\" class=\"\">\n                <p>函数结构赋值</p>\n            </figure>\n<p>注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。</p>\n<h2 id=\"数组中的【…】解构语法\"><a href=\"#数组中的【…】解构语法\" class=\"headerlink\" title=\"数组中的【…】解构语法\"></a>数组中的【…】解构语法</h2><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220200938878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"数组解构\" title=\"\" class=\"\">\n                <p>数组解构</p>\n            </figure>\n<p>输出：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220201035491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"输出\" title=\"\" class=\"\">\n                <p>输出</p>\n            </figure>\n<p>可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。</p>\n<h2 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h2><p><img src=\"http://img.blog.csdn.net/2018022020404810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"对象解构\"></p>\n<p><strong>直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。</strong></p>\n<p><strong>下图是错误示范</strong>：</p>\n<p><img src=\"http://img.blog.csdn.net/20180220204209671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"对象解构错误示范\"></p>\n<p>那么同理，如果在一个方法中返回对象，同样也可以被解构。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/2018022113342527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"函数返回的对象也可以解构赋值\" title=\"\" class=\"\">\n                <p>函数返回的对象也可以解构赋值</p>\n            </figure></p>\n<p>如果对象存在嵌套现象，可以使用冒号表达式：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180221133915180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"嵌套的对象，使用冒号表达式来嵌套化结构\" title=\"\" class=\"\">\n                <p>嵌套的对象，使用冒号表达式来嵌套化结构</p>\n            </figure>\n<h2 id=\"展开\"><a href=\"#展开\" class=\"headerlink\" title=\"展开\"></a>展开</h2><p>还是使用…语法，进行数组或者对象的浅拷贝。</p>\n<p>数组展开，形如：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220205541321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"数组展开\" title=\"\" class=\"\">\n                <p>数组展开</p>\n            </figure></p>\n<p>对象展开，形如：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220205712494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"对象展开\" title=\"\" class=\"\">\n                <p>对象展开</p>\n            </figure>\n<p><strong>对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。</strong></p>\n<h2 id=\"可选参数、默认参数\"><a href=\"#可选参数、默认参数\" class=\"headerlink\" title=\"可选参数、默认参数\"></a>可选参数、默认参数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a:string,b?:string,c=&quot;wang&quot;)&#123;</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">console.log(b)</span><br><span class=\"line\">console.log(c)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a为string类型，b为可选参数(string类型)，c是有默认值的参数</span><br></pre></td></tr></table></figure>\n<p><strong>确定的参数要现在第一个，不能把可选参数写在第一位。</strong></p>\n<h2 id=\"函数断点Yield\"><a href=\"#函数断点Yield\" class=\"headerlink\" title=\"函数断点Yield\"></a>函数断点Yield</h2><p>在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo()&#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    yield; //设置断点，下同</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    yield;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(3);</span><br><span class=\"line\"></span><br><span class=\"line\">    yield;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。</span><br><span class=\"line\"> *必须重新赋值，再调用。</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">let zoo =  foo(); </span><br><span class=\"line\"></span><br><span class=\"line\">//这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。</span><br><span class=\"line\">zoo.next();//1</span><br><span class=\"line\">zoo.next();//2</span><br><span class=\"line\">zoo.next();//3</span><br></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>作用一：主要用于声明匿名函数，简化代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sum = (a,b)=&gt;a+b</span><br><span class=\"line\"></span><br><span class=\"line\">上式等价于：</span><br><span class=\"line\">var sum = function (a,b)&#123;</span><br><span class=\"line\">retrun a+b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>作用二：消除this指针带来的歧义,优化执行上下文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getName (name) &#123; </span><br><span class=\"line\"> this.name = name ;</span><br><span class=\"line\">  setInterval(function () &#123; console.log(&apos;name is &apos;+this.name)&#125;,1000)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var john = new getName(&apos;jhon&apos;);</span><br><span class=\"line\">console.log(john)       // 打印 name is (空)</span><br></pre></td></tr></table></figure>\n<p>这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。</p>\n<p>使用箭头函数改造：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getName (name) &#123; </span><br><span class=\"line\"> this.name = name ;</span><br><span class=\"line\">    setInterval(() =&gt; console.log(&apos;name is &apos;+this.name)),1000)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var john = new getName(&apos;jhon&apos;);</span><br><span class=\"line\">console.log(john)       // 打印 name is jhon</span><br></pre></td></tr></table></figure>\n<h2 id=\"For…of循环\"><a href=\"#For…of循环\" class=\"headerlink\" title=\"For…of循环\"></a>For…of循环</h2><p><strong>for…in 循环对象的下标</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">arr.name = &apos;myArr&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var n in arr) &#123; </span><br><span class=\"line\">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//输出0=1,1=2,2=3,3=4,name=myArr</span><br></pre></td></tr></table></figure>\n<p><strong>for of 循环对象的key</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">arr.name = &apos;myArr&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var n of arr) &#123; </span><br><span class=\"line\">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//输出0=1,1=2,2=3,3=4,undefind</span><br><span class=\"line\"></span><br><span class=\"line\">//还可以循环字符串</span><br><span class=\"line\">var arr =&apos;hello,world!&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">for (var n of arr) &#123; </span><br><span class=\"line\">    console.log(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//h,e,l,l,o,，w,o,r,l,d,!;</span><br></pre></td></tr></table></figure>\n<p><strong>forEach  循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">arr.name = &apos;myArr&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach(function (n,v) &#123; </span><br><span class=\"line\">    console.log(n,v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//输出1,2,3,4，但是没有输出我们定义的name</span><br></pre></td></tr></table></figure>\n<p>总结：for…in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for…of有点鸡肋，但是胜在使用场景广泛。</p>\n<h2 id=\"interface接口\"><a href=\"#interface接口\" class=\"headerlink\" title=\"interface接口\"></a>interface接口</h2><p>interface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/2018022210063595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"interface\" title=\"\" class=\"\">\n                <p>interface</p>\n            </figure>\n<p>当然，接口中预先定义的变量，也可以规定/限制函数中的参数：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180222103808977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"限制函数中的参数\" title=\"\" class=\"\">\n                <p>限制函数中的参数</p>\n            </figure>\n<h2 id=\"基于Class的继承\"><a href=\"#基于Class的继承\" class=\"headerlink\" title=\"基于Class的继承\"></a>基于Class的继承</h2><p>在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script!</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220210913277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"基于Class的继承\" title=\"\" class=\"\">\n                <p>基于Class的继承</p>\n            </figure>\n<p>访问权限关键字：<br><strong>public</strong> 公共成员。  子类、父类内部都可以访问到。</p>\n<p><strong>private</strong> 私有成员。只允许在类中访问。</p>\n<p><strong>protected</strong> 超类的私有成员。但是在子类中仍然可以访问。</p>\n<p>构造器Construcor：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//形如：</span><br><span class=\"line\">constructor()&#123;</span><br><span class=\"line\"> name?string;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。</p>\n<p>举例说明：</p>\n<p><img src=\"http://img.blog.csdn.net/20180222105023915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"构造器内部的变量无法被全局访问\"></p>\n<p>这时候，只要在构造器的name上增加关键字<code>public</code>，即可在class中全局访问：</p>\n<p><img src=\"http://img.blog.csdn.net/20180222105147415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"加上public，没有报错\"></p>\n<p><strong>类的继承</strong><br>真的比基于原型链的继承更加优雅和简便。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180222105737601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"通过extends关键字实现继承\" title=\"\" class=\"\">\n                <p>通过extends关键字实现继承</p>\n            </figure></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79324863\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>TypeScript是JavaScript的超集，它的作者是著名的C#之父（名字我忘了）。作为后者的超集，Typescript(以下简称为tsc)拓展了JS，真正的将js从玩具语言变成一种工程语言，一种强类型的语言。并且，tsc的标准是根据每年的ECMA提案来预先实现的，也就是说，tsc兼容未来的ES7，ES8…提前为将来的ES标准打下基础。<br>    学习tsc，不亏!</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cnpm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>完事，安装tsc的npm包，就是为了使用它自带的功能，将.ts文件编译成.js文件，从而兼容各种平台及浏览器，编译的命令行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd your File_path</span><br><span class=\"line\">$ tsc File_name.ts</span><br></pre></td></tr></table></figure>\n<p>OK,执行完，发现在.ts的同目录下，自动编译完成一个同名的.ts文件。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180214112403989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"tsc\" title=\"\" class=\"\">\n                <p>tsc</p>\n            </figure>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><p>1.基本类型检测</p>\n<p>在js中，命名一个变量通常不用指定类型，tsc弥补了这个劣势，加入类型监测，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a:number = 1;  //OK</span><br><span class=\"line\"></span><br><span class=\"line\">let a:string = 1;  //error</span><br><span class=\"line\"></span><br><span class=\"line\">类型检测的语法，就是在变量屁股后面缀上 :类型</span><br></pre></td></tr></table></figure>\n<p>2.数组的类型检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr:number[]=[1,2,3];   //ok   类型+[]</span><br><span class=\"line\"> </span><br><span class=\"line\">let brr:Array&lt;number&gt;=[4,5,6]; //OK  数组泛型+尖括号&lt; 类型 &gt;</span><br></pre></td></tr></table></figure>\n<p>3.元组类型 Tupe </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let X:[number,string];</span><br><span class=\"line\">x=[1,&apos;hello&apos;]; //OK</span><br><span class=\"line\">x=[1,2];  //type error</span><br><span class=\"line\">元组类型适用于已知个数和元素类型的数组。</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串拼接及字符串模板\"><a href=\"#字符串拼接及字符串模板\" class=\"headerlink\" title=\"字符串拼接及字符串模板\"></a>字符串拼接及字符串模板</h2><p>拼接：跟ES6一样，通过<code>（`</code>）<code>来实现，【</code>】为Tab上面的按键。</p>\n<p>for eg  :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let hi= (`</span><br><span class=\"line\">hello,</span><br><span class=\"line\">wrold!</span><br><span class=\"line\">`);</span><br><span class=\"line\"></span><br><span class=\"line\">//输出 hello,world!</span><br></pre></td></tr></table></figure>\n<p>字符串模板：提供一种更优雅的书写方式：<code>${ 变量名}</code></p>\n<p>for eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let names:string = &apos;xiaoming&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">let age:number = 23;</span><br><span class=\"line\"></span><br><span class=\"line\">let sentence:string = (`</span><br><span class=\"line\"></span><br><span class=\"line\">hello,my name is $&#123;names&#125;,my age is $&#123;age&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">`);</span><br></pre></td></tr></table></figure>\n<p>编译后的js文件为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var names = &apos;xiaoming&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var age = 23;</span><br><span class=\"line\"></span><br><span class=\"line\">var sentence = (&quot;\\nhello,my name is &quot; + names + &quot;,my age is &quot; + age + &quot;\\n&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">document.body.innerHTML = sentence;</span><br></pre></td></tr></table></figure>\n<h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> flower &#123;a,b,c,d,e,f,g&#125;;  <span class=\"comment\">//enum关键字，后跟枚举类型的命名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> rouse:flower = flower.a;  <span class=\"comment\">//定义一个rouse，类型是刚才定义的枚举类型flower其中的a属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(rouse);  <span class=\"comment\">// 0 表明rouse映射的对象，在flower中的index为0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Any类型\"><a href=\"#Any类型\" class=\"headerlink\" title=\"Any类型\"></a>Any类型</h2><p>有时候不希望tsc太严格，对于部分变量或者数据开个后门，就可以声明Any 任意类型。</p>\n<p><img src=\"http://img.blog.csdn.net/20180214120224290?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"any类型\"></p>\n<p>let不能重复定义，我就用var来演示。</p>\n<p>Any类型也可以像数组的第一种定义方法一样，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array:</span><br><span class=\"line\"></span><br><span class=\"line\">let arr:number[]=[1,2,3];  // OK</span><br><span class=\"line\"></span><br><span class=\"line\">数字的组合，可不就是数组吗？</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">字符串组、布尔值组...</span><br><span class=\"line\"></span><br><span class=\"line\">let brr:string[] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">let crr:boolean[] = [true,false];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Any:</span><br><span class=\"line\"></span><br><span class=\"line\">let drr:any[]=[1,&apos;2&apos;,true];  //  OK</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">只知道是个类似于数组的数据类型，但是对元素的类型不做限制。</span><br></pre></td></tr></table></figure>\n<h2 id=\"Void类型\"><a href=\"#Void类型\" class=\"headerlink\" title=\"Void类型\"></a>Void类型</h2><p>void类型表示空。常用在函数返回值，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意函数返回值类型检测的写法</span><br><span class=\"line\">function foo():void&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(&apos;123&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实，void包含两种数据类型，就是null和undefind。</p>\n<p>触类旁通，其实还有两个类型是null和undefind，如图所示：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180214121723225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"null&undefind\" title=\"\" class=\"\">\n                <p>null&undefind</p>\n            </figure>\n<p>如图所示，两个类型不仅自暴自弃，还拉对方下水，形成“你中有我，我中有你”的关系。</p>\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>作用就是清楚的告诉编译器，我知道a是number类型的，不要给我搞事。<br>写法一：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a:number =1; </span><br><span class=\"line\"></span><br><span class=\"line\">let b:any = &lt;number&gt;a ;  //赋值</span><br></pre></td></tr></table></figure>\n<p>第二种写法:</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180214131500183?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"类型断言\" title=\"\" class=\"\">\n                <p>类型断言</p>\n            </figure>\n<h2 id=\"Let\"><a href=\"#Let\" class=\"headerlink\" title=\"Let\"></a>Let</h2><p>来看这样一段代码：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220191341275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"for循环实例\" title=\"\" class=\"\">\n                <p>for循环实例</p>\n            </figure></p>\n<p>在这个for循环中，有一个setTimeout异步函数，循环5次，打印出的结果是什么呢？</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220191448648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"运行结果\" title=\"\" class=\"\">\n                <p>运行结果</p>\n            </figure>\n<p>可见，连续打印了5次5，为什么5次都是5 呢？因为setTimeout是一个异步函数，他会等待其他函数执行完，再执行，没有拿到i的最终结果，他不会执行。</p>\n<p><strong>究其本质，是因为for循环()中的作用域与{}中的作用域混淆了，如果将这两个作用域独立，那么setTimeout不会等待i的最终执行结果</strong></p>\n<p>将上述代码的<code>var i</code>改为<code>let i</code>这样，for 循环中的()部分就有了自己独立的块级作用域，所以每次setTimeout执行的时候就不会等待i的最终结果。<br>因此，代码结果如下图所示：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220191954426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"let执行结果\" title=\"\" class=\"\">\n                <p>let执行结果</p>\n            </figure>\n<p>再来看一个对比：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220193631816?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"使用var声明\" title=\"\" class=\"\">\n                <p>使用var声明</p>\n            </figure>\n<p>将var 改为let </p>\n<p><img src=\"http://img.blog.csdn.net/20180220193713998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"使用let声明\"></p>\n<p>可见，两种声明，是一摸一样的输出，为什么呢？<br>var的声名方式，是因为()和{}基本上可以视为同一作用域，而let的声名方式稍有不同，每次<code>for(let i=0;i&lt;5;i++)</code>的迭代，都会创建一个新的作用域{}，因此，每次的结果照样可以打印出来。<br><strong>因为这里没有异步函数</strong>，即便二者的作用域不同(前者是一个全局作用域，后者是两个块级作用域)，输出也是相同的。</p>\n<p>总结：使用var或者let，如果当输入环节没有异步函数，无论再怎么变换作用域，那么输出相同，否则，输出不同。</p>\n<h2 id=\"Const\"><a href=\"#Const\" class=\"headerlink\" title=\"Const\"></a>Const</h2><p>定义了一次，就不能再次定义或者修改赋值。这种定义的方法，用于只读数据，没有修改权限的时候用。<br>eg:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = 1 ;</span><br><span class=\"line\"></span><br><span class=\"line\">const a = 2 ; //error</span><br></pre></td></tr></table></figure>\n<h2 id=\"结构赋值\"><a href=\"#结构赋值\" class=\"headerlink\" title=\"结构赋值\"></a>结构赋值</h2><p>普通结构赋值：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220195746635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"普通结构赋值\" title=\"\" class=\"\">\n                <p>普通结构赋值</p>\n            </figure>\n<p>函数参数结构赋值：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220200215178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"函数结构赋值\" title=\"\" class=\"\">\n                <p>函数结构赋值</p>\n            </figure>\n<p>注意：函数的参数在类型监测的时候，用结构赋值，需要冒号【:】。</p>\n<h2 id=\"数组中的【…】解构语法\"><a href=\"#数组中的【…】解构语法\" class=\"headerlink\" title=\"数组中的【…】解构语法\"></a>数组中的【…】解构语法</h2><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220200938878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"数组解构\" title=\"\" class=\"\">\n                <p>数组解构</p>\n            </figure>\n<p>输出：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220201035491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"输出\" title=\"\" class=\"\">\n                <p>输出</p>\n            </figure>\n<p>可见，对于未知元素(数组中的成员)，默认是对象，当打印输出的时候，会将其当做数组对象来看待。</p>\n<h2 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h2><p><img src=\"http://img.blog.csdn.net/2018022020404810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"对象解构\"></p>\n<p><strong>直接结构，这里要注意，新定义的对象中，key键名，一定要与被解构对象的属性名字相同，且不能跳跃式解构。</strong></p>\n<p><strong>下图是错误示范</strong>：</p>\n<p><img src=\"http://img.blog.csdn.net/20180220204209671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"对象解构错误示范\"></p>\n<p>那么同理，如果在一个方法中返回对象，同样也可以被解构。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/2018022113342527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"函数返回的对象也可以解构赋值\" title=\"\" class=\"\">\n                <p>函数返回的对象也可以解构赋值</p>\n            </figure></p>\n<p>如果对象存在嵌套现象，可以使用冒号表达式：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180221133915180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"嵌套的对象，使用冒号表达式来嵌套化结构\" title=\"\" class=\"\">\n                <p>嵌套的对象，使用冒号表达式来嵌套化结构</p>\n            </figure>\n<h2 id=\"展开\"><a href=\"#展开\" class=\"headerlink\" title=\"展开\"></a>展开</h2><p>还是使用…语法，进行数组或者对象的浅拷贝。</p>\n<p>数组展开，形如：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220205541321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"数组展开\" title=\"\" class=\"\">\n                <p>数组展开</p>\n            </figure></p>\n<p>对象展开，形如：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220205712494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"对象展开\" title=\"\" class=\"\">\n                <p>对象展开</p>\n            </figure>\n<p><strong>对象展开时，所有传入的键值对，一旦有重复，按照覆盖原则，后面的value会覆盖前面的。执行顺序是从左到右。</strong></p>\n<h2 id=\"可选参数、默认参数\"><a href=\"#可选参数、默认参数\" class=\"headerlink\" title=\"可选参数、默认参数\"></a>可选参数、默认参数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a:string,b?:string,c=&quot;wang&quot;)&#123;</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">console.log(b)</span><br><span class=\"line\">console.log(c)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a为string类型，b为可选参数(string类型)，c是有默认值的参数</span><br></pre></td></tr></table></figure>\n<p><strong>确定的参数要现在第一个，不能把可选参数写在第一位。</strong></p>\n<h2 id=\"函数断点Yield\"><a href=\"#函数断点Yield\" class=\"headerlink\" title=\"函数断点Yield\"></a>函数断点Yield</h2><p>在往常的js代码中，不可以人为的暂停或者恢复代码的运行，但是现在有了yield关键字，就可以将函数的执行流程化，从而让我们有条不紊的控制步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo()&#123;</span><br><span class=\"line\">    console.log(1);</span><br><span class=\"line\">    yield; //设置断点，下同</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    yield;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(3);</span><br><span class=\"line\"></span><br><span class=\"line\">    yield;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/*设置断点以后，并不能直接foo.next()，因为其内部没有next方法。</span><br><span class=\"line\"> *必须重新赋值，再调用。</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">let zoo =  foo(); </span><br><span class=\"line\"></span><br><span class=\"line\">//这里有三个断点，简单的可以理解为，把函数的执行流程划分为三个阶段，每次的调用，只是执行其中的一个阶段。</span><br><span class=\"line\">zoo.next();//1</span><br><span class=\"line\">zoo.next();//2</span><br><span class=\"line\">zoo.next();//3</span><br></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>作用一：主要用于声明匿名函数，简化代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sum = (a,b)=&gt;a+b</span><br><span class=\"line\"></span><br><span class=\"line\">上式等价于：</span><br><span class=\"line\">var sum = function (a,b)&#123;</span><br><span class=\"line\">retrun a+b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>作用二：消除this指针带来的歧义,优化执行上下文。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getName (name) &#123; </span><br><span class=\"line\"> this.name = name ;</span><br><span class=\"line\">  setInterval(function () &#123; console.log(&apos;name is &apos;+this.name)&#125;,1000)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var john = new getName(&apos;jhon&apos;);</span><br><span class=\"line\">console.log(john)       // 打印 name is (空)</span><br></pre></td></tr></table></figure>\n<p>这里由于getName()是全局函数，就是window下的一个方法，但是console.log()时，由于window下并没有定义 window.name 属性，因此，打印出来的值是 undefind。</p>\n<p>使用箭头函数改造：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getName (name) &#123; </span><br><span class=\"line\"> this.name = name ;</span><br><span class=\"line\">    setInterval(() =&gt; console.log(&apos;name is &apos;+this.name)),1000)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var john = new getName(&apos;jhon&apos;);</span><br><span class=\"line\">console.log(john)       // 打印 name is jhon</span><br></pre></td></tr></table></figure>\n<h2 id=\"For…of循环\"><a href=\"#For…of循环\" class=\"headerlink\" title=\"For…of循环\"></a>For…of循环</h2><p><strong>for…in 循环对象的下标</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">arr.name = &apos;myArr&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var n in arr) &#123; </span><br><span class=\"line\">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//输出0=1,1=2,2=3,3=4,name=myArr</span><br></pre></td></tr></table></figure>\n<p><strong>for of 循环对象的key</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">arr.name = &apos;myArr&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var n of arr) &#123; </span><br><span class=\"line\">    console.log(n+&apos;==&apos;+arr[n])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//输出0=1,1=2,2=3,3=4,undefind</span><br><span class=\"line\"></span><br><span class=\"line\">//还可以循环字符串</span><br><span class=\"line\">var arr =&apos;hello,world!&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">for (var n of arr) &#123; </span><br><span class=\"line\">    console.log(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//h,e,l,l,o,，w,o,r,l,d,!;</span><br></pre></td></tr></table></figure>\n<p><strong>forEach  循环循环对象的key值，并且可以循环对象的key值对应的value，但是不能循环数组之外新添加的属性</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4];</span><br><span class=\"line\">arr.name = &apos;myArr&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach(function (n,v) &#123; </span><br><span class=\"line\">    console.log(n,v)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//输出1,2,3,4，但是没有输出我们定义的name</span><br></pre></td></tr></table></figure>\n<p>总结：for…in循环数组下标。forEach很体面，但是有局限性(不能访问数组外部定义的属性)，for…of有点鸡肋，但是胜在使用场景广泛。</p>\n<h2 id=\"interface接口\"><a href=\"#interface接口\" class=\"headerlink\" title=\"interface接口\"></a>interface接口</h2><p>interface是一种类型，预先定义好一系列的属性的类型，然后供新的对象来使用它。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/2018022210063595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"interface\" title=\"\" class=\"\">\n                <p>interface</p>\n            </figure>\n<p>当然，接口中预先定义的变量，也可以规定/限制函数中的参数：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180222103808977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"限制函数中的参数\" title=\"\" class=\"\">\n                <p>限制函数中的参数</p>\n            </figure>\n<h2 id=\"基于Class的继承\"><a href=\"#基于Class的继承\" class=\"headerlink\" title=\"基于Class的继承\"></a>基于Class的继承</h2><p>在es3中，javascript的继承只能通过原型链来继承，现在可以通过Class类来继承 。真不愧是“JAVA”script!</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180220210913277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"基于Class的继承\" title=\"\" class=\"\">\n                <p>基于Class的继承</p>\n            </figure>\n<p>访问权限关键字：<br><strong>public</strong> 公共成员。  子类、父类内部都可以访问到。</p>\n<p><strong>private</strong> 私有成员。只允许在类中访问。</p>\n<p><strong>protected</strong> 超类的私有成员。但是在子类中仍然可以访问。</p>\n<p>构造器Construcor：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//形如：</span><br><span class=\"line\">constructor()&#123;</span><br><span class=\"line\"> name?string;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在构造器中，相当于新建了一个局部的作用域，在构造器中声明的变量、属性都是局部的，哪怕是在Class内部、构造器之外，也无法访问。</p>\n<p>举例说明：</p>\n<p><img src=\"http://img.blog.csdn.net/20180222105023915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"构造器内部的变量无法被全局访问\"></p>\n<p>这时候，只要在构造器的name上增加关键字<code>public</code>，即可在class中全局访问：</p>\n<p><img src=\"http://img.blog.csdn.net/20180222105147415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"加上public，没有报错\"></p>\n<p><strong>类的继承</strong><br>真的比基于原型链的继承更加优雅和简便。<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180222105737601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"通过extends关键字实现继承\" title=\"\" class=\"\">\n                <p>通过extends关键字实现继承</p>\n            </figure></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"使用 Travis-CI 持续集成部署 HEXO 博客项目","date":"2018-08-29T07:21:08.000Z","reward":true,"comment":true,"_content":"\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/82183614)\n\n## 持续集成的概念 ##\n现在前端项目都是模块化开发，需要大量的 npm install ,编译等环节，除去在开发环节中使用诸如 webpack 这样的自动化工具，在部署的时候，也可以使用 Travis 来提升部署效率。\n持续集成，相当于将环境搭建在云端，每次只需提交代码到对应的分支，就会触发 CI 自动构建，其中构建过程中的指令都可以指定。\n\n## 准备工作 ##\n\n - **已经有 HEXO 搭建的博客，并且源码存放在 HEXO 项目的分支上(分支名字随便起，不是 master 就行)。**\n 如图：\n   ![部署](https://img-blog.csdn.net/20180829150457739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n   \n - **熟悉 HEXO 的用法及基本指令，例如**\n\n```\n$ hexo g // 构建\n$ hexo clean // 清除已构建的资源\n$ hexo s // 起服务\n```\n## 持续集成部署 ##\n\n - 登录[https://travis-ci.org/](https://travis-ci.org/)，使用github账号登录。\n   \n - 找到自己的 HEXO 项目：\n   ![HEXO项目](https://img-blog.csdn.net/20180829150920443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n - 设置选项\n\n在github添加Access Token，在右上角账号的settings->Personal access tokens.点击generate new token来生成新token\n选择仓库权限就可以。\n![get token](https://img-blog.csdn.net/20180829151058290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n除了 “删库”。其他权限都给上：\n![权限分配](https://img-blog.csdn.net/20180829151158858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n*(生成之后一定要保存好，因为只会出现一次，丢失了就只能再重新生成了。)*\n\n - 回到Travis官网，在设置中填入刚复制的token，取一个名字，这个名字需要写到下面的配置文件中\n![添加 token](https://img-blog.csdn.net/20180829151351186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n - 在你的hexo项目的 **分支中** 添加配置文件.travis.yml，并且**放在 HEXO 源码分支的根目录下**如下：\n \n![.travis.yml](https://img-blog.csdn.net/20180829153110581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n```\nlanguage: node_js\nnode_js: stable\n\ninstall:\n  - npm install -g gulp\n  - npm install\n\n # - npm install -g gulp\n\nscript:\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"ZQ-jhon\"\n  - git config user.email \"350037310@qq.com\"\n  - git add .\n  - git commit -m \"Update docs with TRAVIS-CI.\"\n  - `git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master`\n  \nbranches:\n  only:\n    - hexo\nenv:\n global:\n   - GH_REF: github.com/ZQ-jhon/ZQ-jhon.github.io.git\n             ```\n\n你需要修改的是 user.name，user.email，以及在 GH_REF 中填写你自己的仓库中该项目的地址( 浏览器 url 自己找规律 )。\n要使用https协议的仓库地址，使用ssh仓库地址会失败。\n注意这一行`git push --force --quiet \"https://${githubblog}@${GH_REF}\"` 中的githubblog就是你刚在token那里取的 Token 字段，key 要对应上。\n\n配置完成后推送到仓库中，我们就能看到网站中在部署了。\n\n - 展示：\n   我push了一个新文件，触发了自动构建，这里可以看到构建过程，其实跟我们本地跑 npm install ... 那些流程是一样的：\n   ![构建过程](https://img-blog.csdn.net/20180829152604244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n ![部署成功](https://img-blog.csdn.net/20180829151945335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n \n - 参考：\n [https://www.jianshu.com/p/5691815b81b6](https://www.jianshu.com/p/5691815b81b6)\n [https://blog.csdn.net/woblog/article/details/51319364](https://blog.csdn.net/woblog/article/details\n <b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n","source":"_posts/使用 Travis-CI 持续集成部署 HEXO 博客项目.md","raw":"\n---\ntitle: 使用 Travis-CI 持续集成部署 HEXO 博客项目\ndate: 2018-08-29 15:21:08\ntags: [Travis-CI, Hexo]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/82183614)\n\n## 持续集成的概念 ##\n现在前端项目都是模块化开发，需要大量的 npm install ,编译等环节，除去在开发环节中使用诸如 webpack 这样的自动化工具，在部署的时候，也可以使用 Travis 来提升部署效率。\n持续集成，相当于将环境搭建在云端，每次只需提交代码到对应的分支，就会触发 CI 自动构建，其中构建过程中的指令都可以指定。\n\n## 准备工作 ##\n\n - **已经有 HEXO 搭建的博客，并且源码存放在 HEXO 项目的分支上(分支名字随便起，不是 master 就行)。**\n 如图：\n   ![部署](https://img-blog.csdn.net/20180829150457739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n   \n - **熟悉 HEXO 的用法及基本指令，例如**\n\n```\n$ hexo g // 构建\n$ hexo clean // 清除已构建的资源\n$ hexo s // 起服务\n```\n## 持续集成部署 ##\n\n - 登录[https://travis-ci.org/](https://travis-ci.org/)，使用github账号登录。\n   \n - 找到自己的 HEXO 项目：\n   ![HEXO项目](https://img-blog.csdn.net/20180829150920443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n - 设置选项\n\n在github添加Access Token，在右上角账号的settings->Personal access tokens.点击generate new token来生成新token\n选择仓库权限就可以。\n![get token](https://img-blog.csdn.net/20180829151058290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n除了 “删库”。其他权限都给上：\n![权限分配](https://img-blog.csdn.net/20180829151158858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n*(生成之后一定要保存好，因为只会出现一次，丢失了就只能再重新生成了。)*\n\n - 回到Travis官网，在设置中填入刚复制的token，取一个名字，这个名字需要写到下面的配置文件中\n![添加 token](https://img-blog.csdn.net/20180829151351186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n - 在你的hexo项目的 **分支中** 添加配置文件.travis.yml，并且**放在 HEXO 源码分支的根目录下**如下：\n \n![.travis.yml](https://img-blog.csdn.net/20180829153110581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n```\nlanguage: node_js\nnode_js: stable\n\ninstall:\n  - npm install -g gulp\n  - npm install\n\n # - npm install -g gulp\n\nscript:\n  - hexo g\n\nafter_script:\n  - cd ./public\n  - git init\n  - git config user.name \"ZQ-jhon\"\n  - git config user.email \"350037310@qq.com\"\n  - git add .\n  - git commit -m \"Update docs with TRAVIS-CI.\"\n  - `git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master`\n  \nbranches:\n  only:\n    - hexo\nenv:\n global:\n   - GH_REF: github.com/ZQ-jhon/ZQ-jhon.github.io.git\n             ```\n\n你需要修改的是 user.name，user.email，以及在 GH_REF 中填写你自己的仓库中该项目的地址( 浏览器 url 自己找规律 )。\n要使用https协议的仓库地址，使用ssh仓库地址会失败。\n注意这一行`git push --force --quiet \"https://${githubblog}@${GH_REF}\"` 中的githubblog就是你刚在token那里取的 Token 字段，key 要对应上。\n\n配置完成后推送到仓库中，我们就能看到网站中在部署了。\n\n - 展示：\n   我push了一个新文件，触发了自动构建，这里可以看到构建过程，其实跟我们本地跑 npm install ... 那些流程是一样的：\n   ![构建过程](https://img-blog.csdn.net/20180829152604244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n ![部署成功](https://img-blog.csdn.net/20180829151945335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n \n - 参考：\n [https://www.jianshu.com/p/5691815b81b6](https://www.jianshu.com/p/5691815b81b6)\n [https://blog.csdn.net/woblog/article/details/51319364](https://blog.csdn.net/woblog/article/details\n <b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n","slug":"使用 Travis-CI 持续集成部署 HEXO 博客项目","published":1,"updated":"2018-08-29T07:34:24.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdg20019jgv4f3j66e7w","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/82183614\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"持续集成的概念\"><a href=\"#持续集成的概念\" class=\"headerlink\" title=\"持续集成的概念\"></a>持续集成的概念</h2><p>现在前端项目都是模块化开发，需要大量的 npm install ,编译等环节，除去在开发环节中使用诸如 webpack 这样的自动化工具，在部署的时候，也可以使用 Travis 来提升部署效率。<br>持续集成，相当于将环境搭建在云端，每次只需提交代码到对应的分支，就会触发 CI 自动构建，其中构建过程中的指令都可以指定。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li><p><strong>已经有 HEXO 搭建的博客，并且源码存放在 HEXO 项目的分支上(分支名字随便起，不是 master 就行)。</strong><br>如图：<br><img src=\"https://img-blog.csdn.net/20180829150457739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"部署\"></p>\n</li>\n<li><p><strong>熟悉 HEXO 的用法及基本指令，例如</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g // 构建</span><br><span class=\"line\">$ hexo clean // 清除已构建的资源</span><br><span class=\"line\">$ hexo s // 起服务</span><br></pre></td></tr></table></figure>\n<h2 id=\"持续集成部署\"><a href=\"#持续集成部署\" class=\"headerlink\" title=\"持续集成部署\"></a>持续集成部署</h2><ul>\n<li><p>登录<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">https://travis-ci.org/</a>，使用github账号登录。</p>\n</li>\n<li><p>找到自己的 HEXO 项目：<br><img src=\"https://img-blog.csdn.net/20180829150920443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"HEXO项目\"></p>\n</li>\n<li>设置选项</li>\n</ul>\n<p>在github添加Access Token，在右上角账号的settings-&gt;Personal access tokens.点击generate new token来生成新token<br>选择仓库权限就可以。<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151058290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"get token\" title=\"\" class=\"\">\n                <p>get token</p>\n            </figure></p>\n<p>除了 “删库”。其他权限都给上：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151158858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"权限分配\" title=\"\" class=\"\">\n                <p>权限分配</p>\n            </figure></p>\n<p><em>(生成之后一定要保存好，因为只会出现一次，丢失了就只能再重新生成了。)</em></p>\n<ul>\n<li>回到Travis官网，在设置中填入刚复制的token，取一个名字，这个名字需要写到下面的配置文件中<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151351186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"添加 token\" title=\"\" class=\"\">\n                <p>添加 token</p>\n            </figure></li>\n<li>在你的hexo项目的 <strong>分支中</strong> 添加配置文件.travis.yml，并且<strong>放在 HEXO 源码分支的根目录下</strong>如下：</li>\n</ul>\n<p><img src=\"https://img-blog.csdn.net/20180829153110581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\".travis.yml\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: node_js</span><br><span class=\"line\">node_js: stable</span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install -g gulp</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\"></span><br><span class=\"line\"> # - npm install -g gulp</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">after_script:</span><br><span class=\"line\">  - cd ./public</span><br><span class=\"line\">  - git init</span><br><span class=\"line\">  - git config user.name &quot;ZQ-jhon&quot;</span><br><span class=\"line\">  - git config user.email &quot;350037310@qq.com&quot;</span><br><span class=\"line\">  - git add .</span><br><span class=\"line\">  - git commit -m &quot;Update docs with TRAVIS-CI.&quot;</span><br><span class=\"line\">  - `git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master`</span><br><span class=\"line\">  </span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">env:</span><br><span class=\"line\"> global:</span><br><span class=\"line\">   - GH_REF: github.com/ZQ-jhon/ZQ-jhon.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>你需要修改的是 user.name，user.email，以及在 GH_REF 中填写你自己的仓库中该项目的地址( 浏览器 url 自己找规律 )。<br>要使用https协议的仓库地址，使用ssh仓库地址会失败。<br>注意这一行<code>git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot;</code> 中的githubblog就是你刚在token那里取的 Token 字段，key 要对应上。</p>\n<p>配置完成后推送到仓库中，我们就能看到网站中在部署了。</p>\n<ul>\n<li><p>展示：<br>我push了一个新文件，触发了自动构建，这里可以看到构建过程，其实跟我们本地跑 npm install … 那些流程是一样的：<br><img src=\"https://img-blog.csdn.net/20180829152604244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"构建过程\"></p>\n<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151945335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"部署成功\" title=\"\" class=\"\">\n                <p>部署成功</p>\n            </figure>\n</li>\n<li><p>参考：<br><a href=\"https://www.jianshu.com/p/5691815b81b6\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5691815b81b6</a><br>[<a href=\"https://blog.csdn.net/woblog/article/details/51319364]\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woblog/article/details/51319364]</a>(<a href=\"https://blog.csdn.net/woblog/article/details\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woblog/article/details</a><br><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/82183614\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"持续集成的概念\"><a href=\"#持续集成的概念\" class=\"headerlink\" title=\"持续集成的概念\"></a>持续集成的概念</h2><p>现在前端项目都是模块化开发，需要大量的 npm install ,编译等环节，除去在开发环节中使用诸如 webpack 这样的自动化工具，在部署的时候，也可以使用 Travis 来提升部署效率。<br>持续集成，相当于将环境搭建在云端，每次只需提交代码到对应的分支，就会触发 CI 自动构建，其中构建过程中的指令都可以指定。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li><p><strong>已经有 HEXO 搭建的博客，并且源码存放在 HEXO 项目的分支上(分支名字随便起，不是 master 就行)。</strong><br>如图：<br><img src=\"https://img-blog.csdn.net/20180829150457739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"部署\"></p>\n</li>\n<li><p><strong>熟悉 HEXO 的用法及基本指令，例如</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g // 构建</span><br><span class=\"line\">$ hexo clean // 清除已构建的资源</span><br><span class=\"line\">$ hexo s // 起服务</span><br></pre></td></tr></table></figure>\n<h2 id=\"持续集成部署\"><a href=\"#持续集成部署\" class=\"headerlink\" title=\"持续集成部署\"></a>持续集成部署</h2><ul>\n<li><p>登录<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">https://travis-ci.org/</a>，使用github账号登录。</p>\n</li>\n<li><p>找到自己的 HEXO 项目：<br><img src=\"https://img-blog.csdn.net/20180829150920443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"HEXO项目\"></p>\n</li>\n<li>设置选项</li>\n</ul>\n<p>在github添加Access Token，在右上角账号的settings-&gt;Personal access tokens.点击generate new token来生成新token<br>选择仓库权限就可以。<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151058290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"get token\" title=\"\" class=\"\">\n                <p>get token</p>\n            </figure></p>\n<p>除了 “删库”。其他权限都给上：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151158858?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"权限分配\" title=\"\" class=\"\">\n                <p>权限分配</p>\n            </figure></p>\n<p><em>(生成之后一定要保存好，因为只会出现一次，丢失了就只能再重新生成了。)</em></p>\n<ul>\n<li>回到Travis官网，在设置中填入刚复制的token，取一个名字，这个名字需要写到下面的配置文件中<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151351186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"添加 token\" title=\"\" class=\"\">\n                <p>添加 token</p>\n            </figure></li>\n<li>在你的hexo项目的 <strong>分支中</strong> 添加配置文件.travis.yml，并且<strong>放在 HEXO 源码分支的根目录下</strong>如下：</li>\n</ul>\n<p><img src=\"https://img-blog.csdn.net/20180829153110581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\".travis.yml\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: node_js</span><br><span class=\"line\">node_js: stable</span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install -g gulp</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\"></span><br><span class=\"line\"> # - npm install -g gulp</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">after_script:</span><br><span class=\"line\">  - cd ./public</span><br><span class=\"line\">  - git init</span><br><span class=\"line\">  - git config user.name &quot;ZQ-jhon&quot;</span><br><span class=\"line\">  - git config user.email &quot;350037310@qq.com&quot;</span><br><span class=\"line\">  - git add .</span><br><span class=\"line\">  - git commit -m &quot;Update docs with TRAVIS-CI.&quot;</span><br><span class=\"line\">  - `git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master`</span><br><span class=\"line\">  </span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">env:</span><br><span class=\"line\"> global:</span><br><span class=\"line\">   - GH_REF: github.com/ZQ-jhon/ZQ-jhon.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>你需要修改的是 user.name，user.email，以及在 GH_REF 中填写你自己的仓库中该项目的地址( 浏览器 url 自己找规律 )。<br>要使用https协议的仓库地址，使用ssh仓库地址会失败。<br>注意这一行<code>git push --force --quiet &quot;https://${githubblog}@${GH_REF}&quot;</code> 中的githubblog就是你刚在token那里取的 Token 字段，key 要对应上。</p>\n<p>配置完成后推送到仓库中，我们就能看到网站中在部署了。</p>\n<ul>\n<li><p>展示：<br>我push了一个新文件，触发了自动构建，这里可以看到构建过程，其实跟我们本地跑 npm install … 那些流程是一样的：<br><img src=\"https://img-blog.csdn.net/20180829152604244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"构建过程\"></p>\n<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180829151945335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"部署成功\" title=\"\" class=\"\">\n                <p>部署成功</p>\n            </figure>\n</li>\n<li><p>参考：<br><a href=\"https://www.jianshu.com/p/5691815b81b6\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5691815b81b6</a><br>[<a href=\"https://blog.csdn.net/woblog/article/details/51319364]\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woblog/article/details/51319364]</a>(<a href=\"https://blog.csdn.net/woblog/article/details\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/woblog/article/details</a><br><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n</li>\n</ul>\n"},{"title":"关于CSS3呼吸效果的探究","date":"2018-01-17T03:18:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78949964)\n\n## 一、效果预览 ##\n![这里写图片描述](http://img.blog.csdn.net/20180102103428658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。\n\n## 二、方案选择 ##\n刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。\n\n这个效果的实现，如果采用jquery的方案，直接写个动画即可。\n\n```\n//先设定好position:relative;\n$('img:hover').animate({'left':'10px','bottom':'10px'});\n```\n假如追根溯源，还是使用的CSS3的动画。\n首先自定义一个动画：\n\n```\n@keyframes testAnimate{\n\nfrom{position: relative;bottom: 0;left: 0;}\n\nto{position: relative;bottom: 20px;left: 30px;border: 5px solid #999;}\n\n}\n```\n这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。\n\n接着，我们在测试的图片用例上来引入动画：\n\n```\nimg:hover{\nanimation:testAnimate 1s;\n-webkit-animation:testAnimate  1s;\n-moz-animation:testAnimate  1s;\n-o-animation:testAnimate  1s;\n-ms-animation:testAnimate 1s;\n}\n//整个动画1s完成，并设置了浏览器兼容\n```\n效果如下：\n![这里写图片描述](http://img.blog.csdn.net/20180102110628693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案：\n\n```\nimg:hover{\nanimation-fill-mode: forwards;\n-ms-animation-fill-mode:forwards;//兼容IE  xxxxxx  \n-webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx\n-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx\n-o-animation-fill-mode:forwards;//兼容opear xxxxxx\n}\n```\n这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。\n## 三、分析归纳 ##\n众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行\n\n预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/关于CSS3呼吸效果的探究.md","raw":"---\ntitle: 关于CSS3呼吸效果的探究 \ndate: 2018-01-17 11:18:00\ntags: css3\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78949964)\n\n## 一、效果预览 ##\n![这里写图片描述](http://img.blog.csdn.net/20180102103428658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。\n\n## 二、方案选择 ##\n刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。\n\n这个效果的实现，如果采用jquery的方案，直接写个动画即可。\n\n```\n//先设定好position:relative;\n$('img:hover').animate({'left':'10px','bottom':'10px'});\n```\n假如追根溯源，还是使用的CSS3的动画。\n首先自定义一个动画：\n\n```\n@keyframes testAnimate{\n\nfrom{position: relative;bottom: 0;left: 0;}\n\nto{position: relative;bottom: 20px;left: 30px;border: 5px solid #999;}\n\n}\n```\n这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。\n\n接着，我们在测试的图片用例上来引入动画：\n\n```\nimg:hover{\nanimation:testAnimate 1s;\n-webkit-animation:testAnimate  1s;\n-moz-animation:testAnimate  1s;\n-o-animation:testAnimate  1s;\n-ms-animation:testAnimate 1s;\n}\n//整个动画1s完成，并设置了浏览器兼容\n```\n效果如下：\n![这里写图片描述](http://img.blog.csdn.net/20180102110628693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案：\n\n```\nimg:hover{\nanimation-fill-mode: forwards;\n-ms-animation-fill-mode:forwards;//兼容IE  xxxxxx  \n-webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx\n-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx\n-o-animation-fill-mode:forwards;//兼容opear xxxxxx\n}\n```\n这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。\n## 三、分析归纳 ##\n众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行\n\n预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"关于CSS3呼吸效果的探究","published":1,"updated":"2018-08-29T05:59:20.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdg4001bjgv44ghdnayd","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78949964\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"一、效果预览\"><a href=\"#一、效果预览\" class=\"headerlink\" title=\"一、效果预览\"></a>一、效果预览</h2><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180102103428658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。</p>\n<h2 id=\"二、方案选择\"><a href=\"#二、方案选择\" class=\"headerlink\" title=\"二、方案选择\"></a>二、方案选择</h2><p>刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。</p>\n<p>这个效果的实现，如果采用jquery的方案，直接写个动画即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//先设定好position:relative;</span><br><span class=\"line\">$(&apos;img:hover&apos;).animate(&#123;&apos;left&apos;:&apos;10px&apos;,&apos;bottom&apos;:&apos;10px&apos;&#125;);</span><br></pre></td></tr></table></figure>\n<p>假如追根溯源，还是使用的CSS3的动画。<br>首先自定义一个动画：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@keyframes testAnimate&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">from&#123;position: relative;bottom: 0;left: 0;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">to&#123;position: relative;bottom: 20px;left: 30px;border: 5px solid #999;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。</p>\n<p>接着，我们在测试的图片用例上来引入动画：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img:hover&#123;</span><br><span class=\"line\">animation:testAnimate 1s;</span><br><span class=\"line\">-webkit-animation:testAnimate  1s;</span><br><span class=\"line\">-moz-animation:testAnimate  1s;</span><br><span class=\"line\">-o-animation:testAnimate  1s;</span><br><span class=\"line\">-ms-animation:testAnimate 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//整个动画1s完成，并设置了浏览器兼容</span><br></pre></td></tr></table></figure>\n<p>效果如下：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180102110628693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img:hover&#123;</span><br><span class=\"line\">animation-fill-mode: forwards;</span><br><span class=\"line\">-ms-animation-fill-mode:forwards;//兼容IE  xxxxxx  </span><br><span class=\"line\">-webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx</span><br><span class=\"line\">-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx</span><br><span class=\"line\">-o-animation-fill-mode:forwards;//兼容opear xxxxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。</p>\n<h2 id=\"三、分析归纳\"><a href=\"#三、分析归纳\" class=\"headerlink\" title=\"三、分析归纳\"></a>三、分析归纳</h2><p>众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行</p>\n<p>预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78949964\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"一、效果预览\"><a href=\"#一、效果预览\" class=\"headerlink\" title=\"一、效果预览\"></a>一、效果预览</h2><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180102103428658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>如图所示，鼠标移动上去，图片会向右上角抖动，鼠标离开，图片恢复原状。</p>\n<h2 id=\"二、方案选择\"><a href=\"#二、方案选择\" class=\"headerlink\" title=\"二、方案选择\"></a>二、方案选择</h2><p>刚刚接触到这个效果的时候，我还以为是采用放大效果来实现的，即scale:1.2诸如此类的代码，结果不然。</p>\n<p>这个效果的实现，如果采用jquery的方案，直接写个动画即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//先设定好position:relative;</span><br><span class=\"line\">$(&apos;img:hover&apos;).animate(&#123;&apos;left&apos;:&apos;10px&apos;,&apos;bottom&apos;:&apos;10px&apos;&#125;);</span><br></pre></td></tr></table></figure>\n<p>假如追根溯源，还是使用的CSS3的动画。<br>首先自定义一个动画：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@keyframes testAnimate&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">from&#123;position: relative;bottom: 0;left: 0;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">to&#123;position: relative;bottom: 20px;left: 30px;border: 5px solid #999;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个动画定义了一个名为：testAnimate的位置过渡动画，从相对位置(0,0)，变到相对位置 (30px,20px)，且终态时，增加了一个5px的边框。</p>\n<p>接着，我们在测试的图片用例上来引入动画：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img:hover&#123;</span><br><span class=\"line\">animation:testAnimate 1s;</span><br><span class=\"line\">-webkit-animation:testAnimate  1s;</span><br><span class=\"line\">-moz-animation:testAnimate  1s;</span><br><span class=\"line\">-o-animation:testAnimate  1s;</span><br><span class=\"line\">-ms-animation:testAnimate 1s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//整个动画1s完成，并设置了浏览器兼容</span><br></pre></td></tr></table></figure>\n<p>效果如下：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180102110628693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>可能在网页上显示的不尽人意，这里面存在一个问题，当鼠标移入图片，并且悬停不动时，图片会自动回复到动画之前的状态，这就感觉像拖动一个东西，拖到一半，东西自己滑走了，好在CSS3里面有了现成的解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img:hover&#123;</span><br><span class=\"line\">animation-fill-mode: forwards;</span><br><span class=\"line\">-ms-animation-fill-mode:forwards;//兼容IE  xxxxxx  </span><br><span class=\"line\">-webkit-animation-fill-mode:forwards;//兼容Chrome xxxxxx</span><br><span class=\"line\">-moz-animation-fill-mode:forwards;//兼容FireFox xxxxx</span><br><span class=\"line\">-o-animation-fill-mode:forwards;//兼容opear xxxxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，当鼠标移入，只要不松开，图片就会停留在动画的100%状态，而不会回滚到动画为0%的状态；当鼠标移出图片，动画结束，方回到初始状态。</p>\n<h2 id=\"三、分析归纳\"><a href=\"#三、分析归纳\" class=\"headerlink\" title=\"三、分析归纳\"></a>三、分析归纳</h2><p>众所周知，jquery封装的js库，其中的动画部分来源于CSS3，作为原生的CSS，其功能不可小觑，而且相当于jquery的实现方法，这种方法定义起来更加的个性化，而且不用引入额外的js库，很省带宽。但缺点就是兼容性差，比起第三方封装的Animation.js库，兼容性不行</p>\n<p>预览效果参见：news.lanzhou.cn/system/2017/12/29/011485365.shtml 其中的【微说图解】栏目。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"关于jQuery中scrollTop中的一些兼容问题。","date":"2017-12-13T05:25:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78790869)\n\n最近在做一个响应式的页面，需要有按钮来实现点击回到页头及点击回到页尾的功能。\n在使用\n\n```\n$('#btn').click(function(){\n   $(body).animate({\n\t scrollTop:0\n   },speed);\n});\n\n//发现，该功能只在IE与FireFox下有用，Chrome内核无效。\n\n```\n![这里写图片描述](http://files.jb51.net/file_images/article/201512/2015123120741782.png?201511312749)\n即：\n\n选择器为body时：FireFox无效，Chrome有效 \n选择器为html时：Chrome有效，FireFox无效\n\n因此，在编写代码的时候，只要进行双重选择即可兼容：\n\n```\n$('#btn').on('click', function() {\n\t\t\t\tvar speed = 400; //滑动的速度\n\t\t\t\t$('html,body').animate({\n\t\t\t\t\tscrollTop: 0\n\t\t\t\t}, speed);\n\t\t\t\treturn false;\n\t\t\t});\n```\n经测试，在IE(9及以上),FireFox及Chome浏览器下，均能正常使用该功能。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/关于jQuery中scrollTop中的一些兼容问题.md","raw":"---\ntitle: 关于jQuery中scrollTop中的一些兼容问题。\ndate: 2017-12-13 13:25:00\ntags: jquery\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78790869)\n\n最近在做一个响应式的页面，需要有按钮来实现点击回到页头及点击回到页尾的功能。\n在使用\n\n```\n$('#btn').click(function(){\n   $(body).animate({\n\t scrollTop:0\n   },speed);\n});\n\n//发现，该功能只在IE与FireFox下有用，Chrome内核无效。\n\n```\n![这里写图片描述](http://files.jb51.net/file_images/article/201512/2015123120741782.png?201511312749)\n即：\n\n选择器为body时：FireFox无效，Chrome有效 \n选择器为html时：Chrome有效，FireFox无效\n\n因此，在编写代码的时候，只要进行双重选择即可兼容：\n\n```\n$('#btn').on('click', function() {\n\t\t\t\tvar speed = 400; //滑动的速度\n\t\t\t\t$('html,body').animate({\n\t\t\t\t\tscrollTop: 0\n\t\t\t\t}, speed);\n\t\t\t\treturn false;\n\t\t\t});\n```\n经测试，在IE(9及以上),FireFox及Chome浏览器下，均能正常使用该功能。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"关于jQuery中scrollTop中的一些兼容问题","published":1,"updated":"2018-08-29T05:59:20.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdg5001djgv4hjp6b5r2","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78790869\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>最近在做一个响应式的页面，需要有按钮来实现点击回到页头及点击回到页尾的功能。<br>在使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).click(function()&#123;</span><br><span class=\"line\">   $(body).animate(&#123;</span><br><span class=\"line\">\t scrollTop:0</span><br><span class=\"line\">   &#125;,speed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//发现，该功能只在IE与FireFox下有用，Chrome内核无效。</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://files.jb51.net/file_images/article/201512/2015123120741782.png?201511312749\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>即：</p>\n<p>选择器为body时：FireFox无效，Chrome有效<br>选择器为html时：Chrome有效，FireFox无效</p>\n<p>因此，在编写代码的时候，只要进行双重选择即可兼容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class=\"line\">\t\t\t\tvar speed = 400; //滑动的速度</span><br><span class=\"line\">\t\t\t\t$(&apos;html,body&apos;).animate(&#123;</span><br><span class=\"line\">\t\t\t\t\tscrollTop: 0</span><br><span class=\"line\">\t\t\t\t&#125;, speed);</span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t&#125;);</span><br></pre></td></tr></table></figure>\n<p>经测试，在IE(9及以上),FireFox及Chome浏览器下，均能正常使用该功能。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78790869\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>最近在做一个响应式的页面，需要有按钮来实现点击回到页头及点击回到页尾的功能。<br>在使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).click(function()&#123;</span><br><span class=\"line\">   $(body).animate(&#123;</span><br><span class=\"line\">\t scrollTop:0</span><br><span class=\"line\">   &#125;,speed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//发现，该功能只在IE与FireFox下有用，Chrome内核无效。</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://files.jb51.net/file_images/article/201512/2015123120741782.png?201511312749\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>即：</p>\n<p>选择器为body时：FireFox无效，Chrome有效<br>选择器为html时：Chrome有效，FireFox无效</p>\n<p>因此，在编写代码的时候，只要进行双重选择即可兼容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;#btn&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class=\"line\">\t\t\t\tvar speed = 400; //滑动的速度</span><br><span class=\"line\">\t\t\t\t$(&apos;html,body&apos;).animate(&#123;</span><br><span class=\"line\">\t\t\t\t\tscrollTop: 0</span><br><span class=\"line\">\t\t\t\t&#125;, speed);</span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t&#125;);</span><br></pre></td></tr></table></figure>\n<p>经测试，在IE(9及以上),FireFox及Chome浏览器下，均能正常使用该功能。</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"关于百度集成API bd_share的一些窥探","date":"2017-11-03T10:10:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78438174)\n\n\n  最近在做一个项目因为要用bootstrap，需要对第三方分享的图标设计两个款式，最终需求的效果如下：\n\n一、需求分析\n\n1.在PC端，要求用font字符来实现第三方分享的图标,并且鼠标经过时，设定hover效果：\n![这里写图片描述](http://img.blog.csdn.net/20171103173452202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.在小屏幕设备上，需要设定另外一种款式：\n![这里写图片描述](http://img.blog.csdn.net/20171103173511144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n二、思路分析\n\n理清需求以后，下面来看是如何实现的：\n\n 首先，需要点击这些第三方应用的图片或者字符，来实现相应的跳转，例如点击QQ，进入QQ的分享界面。\n\n  如果要完成这一步，需要去每个平台的官网获取分享组件，其实就是人家官方定义好的js API接口。整个页面如果只需要1个2个分享图标还好，要是十几个，20个图标，估计页面会乱七八糟自己看着都糟心。\n  于是这里安利百度share，集成了大多数的第三方share API,非常的方便，省事，复制，粘贴，一气呵成，但是效果可能就不尽人意了。\n  ![这里写图片描述](http://img.blog.csdn.net/20171103173650394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n  看到这里，我以为我打开了二零零年的一张网页，真的，这图标，这32*32的icon清晰度，真的让我很难受。\n 首先推荐一几个icon库，这些icon非常精美，并且实时更新：\n1.阿里妈妈icon库：\n[http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&manage_type=myicons&icontype=histories&keyword=](http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&manage_type=myicons&icontype=histories&keyword=)\n2.Easyicon\n[http://www.easyicon.net/](http://www.easyicon.net/)\n在这里可以下载相应的icon，推荐下载SVG，这个格式的图片制作字体很方便。\n \n\n看一下百度官方的代码\n  \n\n```\n<div class=\"bdsharebuttonbox\">\n\t<a href=\"#\" class=\"bds_more\" data-cmd=\"more\"></a>\n\t<a href=\"#\" class=\"bds_qzone\" data-cmd=\"qzone\"></a>\n\t<a href=\"#\" class=\"bds_tsina\" data-cmd=\"tsina\"></a>\n\t<a href=\"#\" class=\"bds_tqq\" data-cmd=\"tqq\"></a>\n\t<a href=\"#\" class=\"bds_renren\" data-cmd=\"renren\"></a>\n\t<a href=\"#\" class=\"bds_weixin\" data-cmd=\"weixin\"></a>\n</div>\n<script>\n\twindow._bd_share_config = {\n\t\t\"common\": {\n\t\t\t\"bdSnsKey\": {},\n\t\t\t\"bdText\": \"\",\n\t\t\t\"bdMini\": \"2\",\n\t\t\t\"bdPic\": \"\",\n\t\t\t\"bdStyle\": \"0\",\n\t\t\t\"bdSize\": \"16\"\n\t\t},\n\t\t\"share\": {},\n\t\t\"image\": {\n\t\t\t\"viewList\": [\"qzone\", \"tsina\", \"tqq\", \"renren\", \"weixin\"],\n\t\t\t\"viewText\": \"分享到：\",\n\t\t\t\"viewSize\": \"16\"\n\t\t},\n\t\t\"selectShare\": {\n\t\t\t\"bdContainerClass\": null,\n\t\t\t\"bdSelectMiniList\": [\"qzone\", \"tsina\", \"tqq\", \"renren\", \"weixin\"]\n\t\t}\n\t};\n\twith(document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];\n</script>\n```\n不难发现，其实a标签的父div：bdsharebuttonbox已经提前为a标签设置好了样式和背景图了。\n\n这里我们下载好图标，能否直接插入到`<a>` 标签中，然后 实现对应图片的替换呢？显然不行，因为百度通过class类设定好的背景图片，不会被框架内的图片所覆盖，给大家演示一下错误的示范：\n![这是错误的示范](http://img.blog.csdn.net/20171103174622391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n不仅没有变美，反而更丑了。\n\n三、功能实现\n\n3.1 将原始图标替换为图片图标\n\n\n\n怎么办呢？其实我们应该直接设定对应class类的背景图，并且加权!important，就可以完美实现背景图的替换了。\n\n```\n.bd_qzone{background:url(./img/qq.png) !important}\n.bd_tsina{background:url(./img/sina.png) !important}\n```\n这里要说明一下，百度的Share api第三方的图标，全部都是32*32的，因此如果你的图片过于清晰（分辨率太高），应该增加backgrond-size:cover !important ，来填充。\n```\n.bd_qzone{background:url(./img/qq.png) !important;backgrond-size:cover !important }\n.bd_tsina{background:url(./img/sina.png) !important;backgrond-size:cover !important }\n```\n这样，可以实现一个比较好看的图标分享小模块了：\n![这里写图片描述](http://img.blog.csdn.net/20171103175129123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这里我用的图标是128*128的，即便将网页放大10倍，也没有锯齿感。\n\n3.2字符图标完成Share 功能的实现\n   字符图标相比于图片图标，更加节省资源，而且兼容性更棒！(IE4+都支持字符图标)。\n   我们首先去阿里妈妈或者easyicon下载好对应的透明的svg文件，接着到：\n   \n  [https://icomoon.io/app/#/select](https://icomoon.io/app/#/select)\n  这个网站很牛逼，可以将图片转为各种浏览器看得懂的字符文件\n (1)我们打开网站，最上方点击import Icons，上传自己的图标图片文件\n![这里写图片描述](http://img.blog.csdn.net/20171103175717350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n(2)上传好以后， 可以按铅笔图标对文件进行编辑，比如命名，方向结构等等\n![这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](http://img.blog.csdn.net/20171103175907853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n（3）上传好以后，点击下面的Generate Font,下载已经转换好的字体文件\n\n\n![这里写图片描述](http://img.blog.csdn.net/20171103175937926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n（4）下载好以后解压，用记事本打开style.css的文件，复制到你的html页面中的```<style>```标签中\n![这里写图片描述](http://img.blog.csdn.net/20171103180119963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n```\n复制好如下：\n<style type=\"text/css\">\n\t@font-face {\n  font-family: 'icomoon';\n  src:  url('fonts/icomoon.eot?eqsiuf');\n  src:  url('fonts/icomoon.eot?eqsiuf#iefix') format('embedded-opentype'),\n    url('fonts/icomoon.ttf?eqsiuf') format('truetype'),\n    url('fonts/icomoon.woff?eqsiuf') format('woff'),\n    url('fonts/icomoon.svg?eqsiuf#icomoon') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n\n[class^=\"icon-\"], [class*=\" icon-\"] {\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: 'icomoon' !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.icon-baidu:before {\n  content: \"\\e900\";\n}\n.icon-mail:before {\n  content: \"\\e901\";\n}\n.icon-qq:before {\n  content: \"\\e902\";\n}\n.icon-qzone:before {\n  content: \"\\e903\";\n}\n.icon-renren:before {\n  content: \"\\e904\";\n}\n.icon-sina:before {\n  content: \"\\e905\";\n}\n.icon-wechat:before {\n  content: \"\\e906\";\n}\n.icon-copy:before {\n  content: \"\\e907\";\n}\n\n</style>\n```\n\n> 这段CSS代码最好不用通过`<link>`标签引入，否则会出现字符无法正常显示的问题，这个问题目前我还在找原因。\n\n现在可以看到，通过@font-face已经引入了字体文件，并且已经为你预设好了每张图片(现在他们已经变成了字符或者说字体)的类名。\n和bootstrap的glyphicon的调用方法很像，都是通过给目标对象添加类名来调用。并且通过css3的高级选择器 ，在被选择元素之前添加了content，然后是对应字符的编号，非常贴心，这个时候只需要在你想要调用的地方添加class类名即可。\n```\n<p class=\"icon-qq\"></p>\n<p class=\"icon-sina\"></p>\n最终的效果如下：\n![这里写图片描述](http://img.blog.csdn.net/20171103180831126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n我通过js/jq又添加了hover效果，这个界面看上去就舒服多了。\n今天研究了一天这个问题，从最初的不明白第三方分享的原理，到现在可以改变默认样式，我觉得今天收获还是挺多的，对CSS、JS都有了更进一步的理解。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/关于百度集成API-bd-share的一些窥探.md","raw":"---\ntitle:  关于百度集成API bd_share的一些窥探 \ndate: 2017-11-03 18:10:00\ntags: 百度share\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/78438174)\n\n\n  最近在做一个项目因为要用bootstrap，需要对第三方分享的图标设计两个款式，最终需求的效果如下：\n\n一、需求分析\n\n1.在PC端，要求用font字符来实现第三方分享的图标,并且鼠标经过时，设定hover效果：\n![这里写图片描述](http://img.blog.csdn.net/20171103173452202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.在小屏幕设备上，需要设定另外一种款式：\n![这里写图片描述](http://img.blog.csdn.net/20171103173511144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n二、思路分析\n\n理清需求以后，下面来看是如何实现的：\n\n 首先，需要点击这些第三方应用的图片或者字符，来实现相应的跳转，例如点击QQ，进入QQ的分享界面。\n\n  如果要完成这一步，需要去每个平台的官网获取分享组件，其实就是人家官方定义好的js API接口。整个页面如果只需要1个2个分享图标还好，要是十几个，20个图标，估计页面会乱七八糟自己看着都糟心。\n  于是这里安利百度share，集成了大多数的第三方share API,非常的方便，省事，复制，粘贴，一气呵成，但是效果可能就不尽人意了。\n  ![这里写图片描述](http://img.blog.csdn.net/20171103173650394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n  看到这里，我以为我打开了二零零年的一张网页，真的，这图标，这32*32的icon清晰度，真的让我很难受。\n 首先推荐一几个icon库，这些icon非常精美，并且实时更新：\n1.阿里妈妈icon库：\n[http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&manage_type=myicons&icontype=histories&keyword=](http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&manage_type=myicons&icontype=histories&keyword=)\n2.Easyicon\n[http://www.easyicon.net/](http://www.easyicon.net/)\n在这里可以下载相应的icon，推荐下载SVG，这个格式的图片制作字体很方便。\n \n\n看一下百度官方的代码\n  \n\n```\n<div class=\"bdsharebuttonbox\">\n\t<a href=\"#\" class=\"bds_more\" data-cmd=\"more\"></a>\n\t<a href=\"#\" class=\"bds_qzone\" data-cmd=\"qzone\"></a>\n\t<a href=\"#\" class=\"bds_tsina\" data-cmd=\"tsina\"></a>\n\t<a href=\"#\" class=\"bds_tqq\" data-cmd=\"tqq\"></a>\n\t<a href=\"#\" class=\"bds_renren\" data-cmd=\"renren\"></a>\n\t<a href=\"#\" class=\"bds_weixin\" data-cmd=\"weixin\"></a>\n</div>\n<script>\n\twindow._bd_share_config = {\n\t\t\"common\": {\n\t\t\t\"bdSnsKey\": {},\n\t\t\t\"bdText\": \"\",\n\t\t\t\"bdMini\": \"2\",\n\t\t\t\"bdPic\": \"\",\n\t\t\t\"bdStyle\": \"0\",\n\t\t\t\"bdSize\": \"16\"\n\t\t},\n\t\t\"share\": {},\n\t\t\"image\": {\n\t\t\t\"viewList\": [\"qzone\", \"tsina\", \"tqq\", \"renren\", \"weixin\"],\n\t\t\t\"viewText\": \"分享到：\",\n\t\t\t\"viewSize\": \"16\"\n\t\t},\n\t\t\"selectShare\": {\n\t\t\t\"bdContainerClass\": null,\n\t\t\t\"bdSelectMiniList\": [\"qzone\", \"tsina\", \"tqq\", \"renren\", \"weixin\"]\n\t\t}\n\t};\n\twith(document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];\n</script>\n```\n不难发现，其实a标签的父div：bdsharebuttonbox已经提前为a标签设置好了样式和背景图了。\n\n这里我们下载好图标，能否直接插入到`<a>` 标签中，然后 实现对应图片的替换呢？显然不行，因为百度通过class类设定好的背景图片，不会被框架内的图片所覆盖，给大家演示一下错误的示范：\n![这是错误的示范](http://img.blog.csdn.net/20171103174622391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n不仅没有变美，反而更丑了。\n\n三、功能实现\n\n3.1 将原始图标替换为图片图标\n\n\n\n怎么办呢？其实我们应该直接设定对应class类的背景图，并且加权!important，就可以完美实现背景图的替换了。\n\n```\n.bd_qzone{background:url(./img/qq.png) !important}\n.bd_tsina{background:url(./img/sina.png) !important}\n```\n这里要说明一下，百度的Share api第三方的图标，全部都是32*32的，因此如果你的图片过于清晰（分辨率太高），应该增加backgrond-size:cover !important ，来填充。\n```\n.bd_qzone{background:url(./img/qq.png) !important;backgrond-size:cover !important }\n.bd_tsina{background:url(./img/sina.png) !important;backgrond-size:cover !important }\n```\n这样，可以实现一个比较好看的图标分享小模块了：\n![这里写图片描述](http://img.blog.csdn.net/20171103175129123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n这里我用的图标是128*128的，即便将网页放大10倍，也没有锯齿感。\n\n3.2字符图标完成Share 功能的实现\n   字符图标相比于图片图标，更加节省资源，而且兼容性更棒！(IE4+都支持字符图标)。\n   我们首先去阿里妈妈或者easyicon下载好对应的透明的svg文件，接着到：\n   \n  [https://icomoon.io/app/#/select](https://icomoon.io/app/#/select)\n  这个网站很牛逼，可以将图片转为各种浏览器看得懂的字符文件\n (1)我们打开网站，最上方点击import Icons，上传自己的图标图片文件\n![这里写图片描述](http://img.blog.csdn.net/20171103175717350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n(2)上传好以后， 可以按铅笔图标对文件进行编辑，比如命名，方向结构等等\n![这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述](http://img.blog.csdn.net/20171103175907853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n（3）上传好以后，点击下面的Generate Font,下载已经转换好的字体文件\n\n\n![这里写图片描述](http://img.blog.csdn.net/20171103175937926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n（4）下载好以后解压，用记事本打开style.css的文件，复制到你的html页面中的```<style>```标签中\n![这里写图片描述](http://img.blog.csdn.net/20171103180119963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n```\n复制好如下：\n<style type=\"text/css\">\n\t@font-face {\n  font-family: 'icomoon';\n  src:  url('fonts/icomoon.eot?eqsiuf');\n  src:  url('fonts/icomoon.eot?eqsiuf#iefix') format('embedded-opentype'),\n    url('fonts/icomoon.ttf?eqsiuf') format('truetype'),\n    url('fonts/icomoon.woff?eqsiuf') format('woff'),\n    url('fonts/icomoon.svg?eqsiuf#icomoon') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n\n[class^=\"icon-\"], [class*=\" icon-\"] {\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: 'icomoon' !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.icon-baidu:before {\n  content: \"\\e900\";\n}\n.icon-mail:before {\n  content: \"\\e901\";\n}\n.icon-qq:before {\n  content: \"\\e902\";\n}\n.icon-qzone:before {\n  content: \"\\e903\";\n}\n.icon-renren:before {\n  content: \"\\e904\";\n}\n.icon-sina:before {\n  content: \"\\e905\";\n}\n.icon-wechat:before {\n  content: \"\\e906\";\n}\n.icon-copy:before {\n  content: \"\\e907\";\n}\n\n</style>\n```\n\n> 这段CSS代码最好不用通过`<link>`标签引入，否则会出现字符无法正常显示的问题，这个问题目前我还在找原因。\n\n现在可以看到，通过@font-face已经引入了字体文件，并且已经为你预设好了每张图片(现在他们已经变成了字符或者说字体)的类名。\n和bootstrap的glyphicon的调用方法很像，都是通过给目标对象添加类名来调用。并且通过css3的高级选择器 ，在被选择元素之前添加了content，然后是对应字符的编号，非常贴心，这个时候只需要在你想要调用的地方添加class类名即可。\n```\n<p class=\"icon-qq\"></p>\n<p class=\"icon-sina\"></p>\n最终的效果如下：\n![这里写图片描述](http://img.blog.csdn.net/20171103180831126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n我通过js/jq又添加了hover效果，这个界面看上去就舒服多了。\n今天研究了一天这个问题，从最初的不明白第三方分享的原理，到现在可以改变默认样式，我觉得今天收获还是挺多的，对CSS、JS都有了更进一步的理解。\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"关于百度集成API-bd-share的一些窥探","published":1,"updated":"2018-08-29T05:59:20.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdg7001fjgv452x1062y","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78438174\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>  最近在做一个项目因为要用bootstrap，需要对第三方分享的图标设计两个款式，最终需求的效果如下：</p>\n<p>一、需求分析</p>\n<p>1.在PC端，要求用font字符来实现第三方分享的图标,并且鼠标经过时，设定hover效果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103173452202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>2.在小屏幕设备上，需要设定另外一种款式：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103173511144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>二、思路分析</p>\n<p>理清需求以后，下面来看是如何实现的：</p>\n<p> 首先，需要点击这些第三方应用的图片或者字符，来实现相应的跳转，例如点击QQ，进入QQ的分享界面。</p>\n<p>  如果要完成这一步，需要去每个平台的官网获取分享组件，其实就是人家官方定义好的js API接口。整个页面如果只需要1个2个分享图标还好，要是十几个，20个图标，估计页面会乱七八糟自己看着都糟心。<br>  于是这里安利百度share，集成了大多数的第三方share API,非常的方便，省事，复制，粘贴，一气呵成，但是效果可能就不尽人意了。<br>  <img src=\"http://img.blog.csdn.net/20171103173650394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>  看到这里，我以为我打开了二零零年的一张网页，真的，这图标，这32*32的icon清晰度，真的让我很难受。<br> 首先推荐一几个icon库，这些icon非常精美，并且实时更新：<br>1.阿里妈妈icon库：<br><a href=\"http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&amp;manage_type=myicons&amp;icontype=histories&amp;keyword=\" target=\"_blank\" rel=\"noopener\">http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&amp;manage_type=myicons&amp;icontype=histories&amp;keyword=</a><br>2.Easyicon<br><a href=\"http://www.easyicon.net/\" target=\"_blank\" rel=\"noopener\">http://www.easyicon.net/</a><br>在这里可以下载相应的icon，推荐下载SVG，这个格式的图片制作字体很方便。</p>\n<p>看一下百度官方的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;bdsharebuttonbox&quot;&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_tqq&quot; data-cmd=&quot;tqq&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_renren&quot; data-cmd=&quot;renren&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\twindow._bd_share_config = &#123;</span><br><span class=\"line\">\t\t&quot;common&quot;: &#123;</span><br><span class=\"line\">\t\t\t&quot;bdSnsKey&quot;: &#123;&#125;,</span><br><span class=\"line\">\t\t\t&quot;bdText&quot;: &quot;&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdMini&quot;: &quot;2&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdPic&quot;: &quot;&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdStyle&quot;: &quot;0&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdSize&quot;: &quot;16&quot;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&quot;share&quot;: &#123;&#125;,</span><br><span class=\"line\">\t\t&quot;image&quot;: &#123;</span><br><span class=\"line\">\t\t\t&quot;viewList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;],</span><br><span class=\"line\">\t\t\t&quot;viewText&quot;: &quot;分享到：&quot;,</span><br><span class=\"line\">\t\t\t&quot;viewSize&quot;: &quot;16&quot;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&quot;selectShare&quot;: &#123;</span><br><span class=\"line\">\t\t\t&quot;bdContainerClass&quot;: null,</span><br><span class=\"line\">\t\t\t&quot;bdSelectMiniList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\twith(document) 0[(getElementsByTagName(&apos;head&apos;)[0] || body).appendChild(createElement(&apos;script&apos;)).src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5)];</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>不难发现，其实a标签的父div：bdsharebuttonbox已经提前为a标签设置好了样式和背景图了。</p>\n<p>这里我们下载好图标，能否直接插入到<code>&lt;a&gt;</code> 标签中，然后 实现对应图片的替换呢？显然不行，因为百度通过class类设定好的背景图片，不会被框架内的图片所覆盖，给大家演示一下错误的示范：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103174622391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这是错误的示范\" title=\"\" class=\"\">\n                <p>这是错误的示范</p>\n            </figure><br>不仅没有变美，反而更丑了。</p>\n<p>三、功能实现</p>\n<p>3.1 将原始图标替换为图片图标</p>\n<p>怎么办呢？其实我们应该直接设定对应class类的背景图，并且加权!important，就可以完美实现背景图的替换了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bd_qzone&#123;background:url(./img/qq.png) !important&#125;</span><br><span class=\"line\">.bd_tsina&#123;background:url(./img/sina.png) !important&#125;</span><br></pre></td></tr></table></figure>\n<p>这里要说明一下，百度的Share api第三方的图标，全部都是32*32的，因此如果你的图片过于清晰（分辨率太高），应该增加backgrond-size:cover !important ，来填充。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bd_qzone&#123;background:url(./img/qq.png) !important;backgrond-size:cover !important &#125;</span><br><span class=\"line\">.bd_tsina&#123;background:url(./img/sina.png) !important;backgrond-size:cover !important &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，可以实现一个比较好看的图标分享小模块了：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103175129123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>这里我用的图标是128*128的，即便将网页放大10倍，也没有锯齿感。</p>\n<p>3.2字符图标完成Share 功能的实现<br>   字符图标相比于图片图标，更加节省资源，而且兼容性更棒！(IE4+都支持字符图标)。<br>   我们首先去阿里妈妈或者easyicon下载好对应的透明的svg文件，接着到：</p>\n<p>  <a href=\"https://icomoon.io/app/#/select\" target=\"_blank\" rel=\"noopener\">https://icomoon.io/app/#/select</a><br>  这个网站很牛逼，可以将图片转为各种浏览器看得懂的字符文件<br> (1)我们打开网站，最上方点击import Icons，上传自己的图标图片文件<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103175717350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>(2)上传好以后， 可以按铅笔图标对文件进行编辑，比如命名，方向结构等等<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103175907853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述</p>\n            </figure><br>（3）上传好以后，点击下面的Generate Font,下载已经转换好的字体文件</p>\n<p><img src=\"http://img.blog.csdn.net/20171103175937926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>（4）下载好以后解压，用记事本打开style.css的文件，复制到你的html页面中的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![这里写图片描述](http://img.blog.csdn.net/20171103180119963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</span><br></pre></td></tr></table></figure></p>\n<p>复制好如下：</p>\n<p><style type=\"text/css\"><br>    @font-face {<br>  font-family: ‘icomoon’;<br>  src:  url(‘fonts/icomoon.eot?eqsiuf’);<br>  src:  url(‘fonts/icomoon.eot?eqsiuf#iefix’) format(‘embedded-opentype’),<br>    url(‘fonts/icomoon.ttf?eqsiuf’) format(‘truetype’),<br>    url(‘fonts/icomoon.woff?eqsiuf’) format(‘woff’),<br>    url(‘fonts/icomoon.svg?eqsiuf#icomoon’) format(‘svg’);<br>  font-weight: normal;<br>  font-style: normal;<br>}</p>\n<p>[class^=”icon-“], [class<em>=” icon-“] {<br>  /</em> use !important to prevent issues with browser extensions that change fonts */<br>  font-family: ‘icomoon’ !important;<br>  speak: none;<br>  font-style: normal;<br>  font-weight: normal;<br>  font-variant: normal;<br>  text-transform: none;<br>  line-height: 1;</p>\n<p>  /<em> Better Font Rendering =========== </em>/<br>  -webkit-font-smoothing: antialiased;<br>  -moz-osx-font-smoothing: grayscale;<br>}</p>\n<p>.icon-baidu:before {<br>  content: “\\e900”;<br>}<br>.icon-mail:before {<br>  content: “\\e901”;<br>}<br>.icon-qq:before {<br>  content: “\\e902”;<br>}<br>.icon-qzone:before {<br>  content: “\\e903”;<br>}<br>.icon-renren:before {<br>  content: “\\e904”;<br>}<br>.icon-sina:before {<br>  content: “\\e905”;<br>}<br>.icon-wechat:before {<br>  content: “\\e906”;<br>}<br>.icon-copy:before {<br>  content: “\\e907”;<br>}</p>\n<p></style><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; 这段CSS代码最好不用通过`&lt;link&gt;`标签引入，否则会出现字符无法正常显示的问题，这个问题目前我还在找原因。</span><br><span class=\"line\"></span><br><span class=\"line\">现在可以看到，通过@font-face已经引入了字体文件，并且已经为你预设好了每张图片(现在他们已经变成了字符或者说字体)的类名。</span><br><span class=\"line\">和bootstrap的glyphicon的调用方法很像，都是通过给目标对象添加类名来调用。并且通过css3的高级选择器 ，在被选择元素之前添加了content，然后是对应字符的编号，非常贴心，这个时候只需要在你想要调用的地方添加class类名即可。</span><br></pre></td></tr></table></figure></p>\n<p></p><p class=\"icon-qq\"></p><p></p>\n<p></p><p class=\"icon-sina\"></p><br>最终的效果如下：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103180831126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>我通过js/jq又添加了hover效果，这个界面看上去就舒服多了。<br>今天研究了一天这个问题，从最初的不明白第三方分享的原理，到现在可以改变默认样式，我觉得今天收获还是挺多的，对CSS、JS都有了更进一步的理解。<p></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78438174\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>  最近在做一个项目因为要用bootstrap，需要对第三方分享的图标设计两个款式，最终需求的效果如下：</p>\n<p>一、需求分析</p>\n<p>1.在PC端，要求用font字符来实现第三方分享的图标,并且鼠标经过时，设定hover效果：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103173452202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>2.在小屏幕设备上，需要设定另外一种款式：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103173511144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>二、思路分析</p>\n<p>理清需求以后，下面来看是如何实现的：</p>\n<p> 首先，需要点击这些第三方应用的图片或者字符，来实现相应的跳转，例如点击QQ，进入QQ的分享界面。</p>\n<p>  如果要完成这一步，需要去每个平台的官网获取分享组件，其实就是人家官方定义好的js API接口。整个页面如果只需要1个2个分享图标还好，要是十几个，20个图标，估计页面会乱七八糟自己看着都糟心。<br>  于是这里安利百度share，集成了大多数的第三方share API,非常的方便，省事，复制，粘贴，一气呵成，但是效果可能就不尽人意了。<br>  <img src=\"http://img.blog.csdn.net/20171103173650394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>  看到这里，我以为我打开了二零零年的一张网页，真的，这图标，这32*32的icon清晰度，真的让我很难受。<br> 首先推荐一几个icon库，这些icon非常精美，并且实时更新：<br>1.阿里妈妈icon库：<br><a href=\"http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&amp;manage_type=myicons&amp;icontype=histories&amp;keyword=\" target=\"_blank\" rel=\"noopener\">http://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.8&amp;manage_type=myicons&amp;icontype=histories&amp;keyword=</a><br>2.Easyicon<br><a href=\"http://www.easyicon.net/\" target=\"_blank\" rel=\"noopener\">http://www.easyicon.net/</a><br>在这里可以下载相应的icon，推荐下载SVG，这个格式的图片制作字体很方便。</p>\n<p>看一下百度官方的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;bdsharebuttonbox&quot;&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_tqq&quot; data-cmd=&quot;tqq&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_renren&quot; data-cmd=&quot;renren&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">\t&lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\twindow._bd_share_config = &#123;</span><br><span class=\"line\">\t\t&quot;common&quot;: &#123;</span><br><span class=\"line\">\t\t\t&quot;bdSnsKey&quot;: &#123;&#125;,</span><br><span class=\"line\">\t\t\t&quot;bdText&quot;: &quot;&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdMini&quot;: &quot;2&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdPic&quot;: &quot;&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdStyle&quot;: &quot;0&quot;,</span><br><span class=\"line\">\t\t\t&quot;bdSize&quot;: &quot;16&quot;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&quot;share&quot;: &#123;&#125;,</span><br><span class=\"line\">\t\t&quot;image&quot;: &#123;</span><br><span class=\"line\">\t\t\t&quot;viewList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;],</span><br><span class=\"line\">\t\t\t&quot;viewText&quot;: &quot;分享到：&quot;,</span><br><span class=\"line\">\t\t\t&quot;viewSize&quot;: &quot;16&quot;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&quot;selectShare&quot;: &#123;</span><br><span class=\"line\">\t\t\t&quot;bdContainerClass&quot;: null,</span><br><span class=\"line\">\t\t\t&quot;bdSelectMiniList&quot;: [&quot;qzone&quot;, &quot;tsina&quot;, &quot;tqq&quot;, &quot;renren&quot;, &quot;weixin&quot;]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\twith(document) 0[(getElementsByTagName(&apos;head&apos;)[0] || body).appendChild(createElement(&apos;script&apos;)).src = &apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos; + ~(-new Date() / 36e5)];</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>不难发现，其实a标签的父div：bdsharebuttonbox已经提前为a标签设置好了样式和背景图了。</p>\n<p>这里我们下载好图标，能否直接插入到<code>&lt;a&gt;</code> 标签中，然后 实现对应图片的替换呢？显然不行，因为百度通过class类设定好的背景图片，不会被框架内的图片所覆盖，给大家演示一下错误的示范：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103174622391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这是错误的示范\" title=\"\" class=\"\">\n                <p>这是错误的示范</p>\n            </figure><br>不仅没有变美，反而更丑了。</p>\n<p>三、功能实现</p>\n<p>3.1 将原始图标替换为图片图标</p>\n<p>怎么办呢？其实我们应该直接设定对应class类的背景图，并且加权!important，就可以完美实现背景图的替换了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bd_qzone&#123;background:url(./img/qq.png) !important&#125;</span><br><span class=\"line\">.bd_tsina&#123;background:url(./img/sina.png) !important&#125;</span><br></pre></td></tr></table></figure>\n<p>这里要说明一下，百度的Share api第三方的图标，全部都是32*32的，因此如果你的图片过于清晰（分辨率太高），应该增加backgrond-size:cover !important ，来填充。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.bd_qzone&#123;background:url(./img/qq.png) !important;backgrond-size:cover !important &#125;</span><br><span class=\"line\">.bd_tsina&#123;background:url(./img/sina.png) !important;backgrond-size:cover !important &#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，可以实现一个比较好看的图标分享小模块了：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103175129123?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>这里我用的图标是128*128的，即便将网页放大10倍，也没有锯齿感。</p>\n<p>3.2字符图标完成Share 功能的实现<br>   字符图标相比于图片图标，更加节省资源，而且兼容性更棒！(IE4+都支持字符图标)。<br>   我们首先去阿里妈妈或者easyicon下载好对应的透明的svg文件，接着到：</p>\n<p>  <a href=\"https://icomoon.io/app/#/select\" target=\"_blank\" rel=\"noopener\">https://icomoon.io/app/#/select</a><br>  这个网站很牛逼，可以将图片转为各种浏览器看得懂的字符文件<br> (1)我们打开网站，最上方点击import Icons，上传自己的图标图片文件<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103175717350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>(2)上传好以后， 可以按铅笔图标对文件进行编辑，比如命名，方向结构等等<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103175907853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述](http://img.blog.csdn.net/20171103175823318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)![这里写图片描述</p>\n            </figure><br>（3）上传好以后，点击下面的Generate Font,下载已经转换好的字体文件</p>\n<p><img src=\"http://img.blog.csdn.net/20171103175937926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>（4）下载好以后解压，用记事本打开style.css的文件，复制到你的html页面中的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![这里写图片描述](http://img.blog.csdn.net/20171103180119963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</span><br></pre></td></tr></table></figure></p>\n<p>复制好如下：</p>\n<p><style type=\"text/css\"><br>    @font-face {<br>  font-family: ‘icomoon’;<br>  src:  url(‘fonts/icomoon.eot?eqsiuf’);<br>  src:  url(‘fonts/icomoon.eot?eqsiuf#iefix’) format(‘embedded-opentype’),<br>    url(‘fonts/icomoon.ttf?eqsiuf’) format(‘truetype’),<br>    url(‘fonts/icomoon.woff?eqsiuf’) format(‘woff’),<br>    url(‘fonts/icomoon.svg?eqsiuf#icomoon’) format(‘svg’);<br>  font-weight: normal;<br>  font-style: normal;<br>}</p>\n<p>[class^=”icon-“], [class<em>=” icon-“] {<br>  /</em> use !important to prevent issues with browser extensions that change fonts */<br>  font-family: ‘icomoon’ !important;<br>  speak: none;<br>  font-style: normal;<br>  font-weight: normal;<br>  font-variant: normal;<br>  text-transform: none;<br>  line-height: 1;</p>\n<p>  /<em> Better Font Rendering =========== </em>/<br>  -webkit-font-smoothing: antialiased;<br>  -moz-osx-font-smoothing: grayscale;<br>}</p>\n<p>.icon-baidu:before {<br>  content: “\\e900”;<br>}<br>.icon-mail:before {<br>  content: “\\e901”;<br>}<br>.icon-qq:before {<br>  content: “\\e902”;<br>}<br>.icon-qzone:before {<br>  content: “\\e903”;<br>}<br>.icon-renren:before {<br>  content: “\\e904”;<br>}<br>.icon-sina:before {<br>  content: “\\e905”;<br>}<br>.icon-wechat:before {<br>  content: “\\e906”;<br>}<br>.icon-copy:before {<br>  content: “\\e907”;<br>}</p>\n<p></style><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; 这段CSS代码最好不用通过`&lt;link&gt;`标签引入，否则会出现字符无法正常显示的问题，这个问题目前我还在找原因。</span><br><span class=\"line\"></span><br><span class=\"line\">现在可以看到，通过@font-face已经引入了字体文件，并且已经为你预设好了每张图片(现在他们已经变成了字符或者说字体)的类名。</span><br><span class=\"line\">和bootstrap的glyphicon的调用方法很像，都是通过给目标对象添加类名来调用。并且通过css3的高级选择器 ，在被选择元素之前添加了content，然后是对应字符的编号，非常贴心，这个时候只需要在你想要调用的地方添加class类名即可。</span><br></pre></td></tr></table></figure></p>\n<p></p><p class=\"icon-qq\"></p><p></p>\n<p></p><p class=\"icon-sina\"></p><br>最终的效果如下：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20171103180831126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure><br>我通过js/jq又添加了hover效果，这个界面看上去就舒服多了。<br>今天研究了一天这个问题，从最初的不明白第三方分享的原理，到现在可以改变默认样式，我觉得今天收获还是挺多的，对CSS、JS都有了更进一步的理解。<p></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"函数式编程与响应式编程之己见","date":"2018-07-22T13:00:08.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/81157232)\n\n## 1. what is 函数式编程？ ##\n函数，在编程中，通常体现为： 输入 => 执行 => 结果。他不是命令式的，而是对一段操作进行逻辑封装，拿到输入，就能产出结果。通常来说，满足函数式编程的特性的“函数”应该有如下特点:\n\n函数必须有入参，并且函数的产出会根据入参的不同而变化。\n函数执行的整个流程中，不会对全局变量、外部属性等产生影响。\n函数式编程代码量小，干净。\n举个例子：\n\n```javascript\nvar arr = [1,2,3,4,5];\n\nfunction addOne (array) {\n\n    for(var i=0;i<array.length;i++){\n        array[i] += 1;\n    }\n\n    return array;\n}\n\naddOne(arr); // 2,3,4,5,6\n```\n写了一个方法，接受一个数组，产出数组每个成员+1，但这段代码的不足之处在于：\n\n难以复用，如果需求提出 addTwo,addThree方法，需要不断修改函数名和内部逻辑。\n内部的代码很啰嗦， for 循环很low。\n·函数式编程改进版：\n\n```javascript\nlet arr = [1,2,3,4,5];\narr.map(item=> item+1); // 3,4,5,6,7\n```\n\n \n这里，改进使用了原生的 Array.prototype.map 方法，代码量缩小了很多不说，而且复用性进一步提升。整个函数做的事情现在非常直观，入参 => 每项参数 + 1 => 返回新数组，由此，可以说，map()方法是一个纯函数(pure function)。\n\n## 2. 响应式编程 ##\n前端中也有一个概念叫响应式，bootstrap 。这里当然说的不是这个，对于响应式编程的概念，我想提及Vue或者 angular的双向绑定来阐述：\n```javascript\n// template: \n\ni'am {{ name }}\n\n// js:\n\nname = 'jhon';\n```\n\n在前端MVVM的框架中，都有一个数据双向绑定的概念，这里的模版中的变量，实时反映了数据中的 name 变量的 value，而且，如果此时我修改了 name 的值，那么模版中对应的值也会跟着修改。数据 <=> 视图 是同时发生，同时改变的，因为模版就是对数据的一个映射。\n\n再举个例子：\n\nc的值，是通过 a + b 来赋值的，如果ab不是固定的，而是变化的值，那么 c 的值也不会固定为3。 \n```javascript\nlet a = 1,b=2;\n\nlet c = a + b; // 3\n```\n\n不难看出，响应式编程特点：\n\n 同步发生，结果会随着修改参数而实时、动态地变化。\n存在固定的映射关系。","source":"_posts/函数式编程与响应式编程之己见.md","raw":"---\ntitle:  函数式编程与响应式编程之己见 \ndate: 2018-07-22 21:00:08\ntags: javascript\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/81157232)\n\n## 1. what is 函数式编程？ ##\n函数，在编程中，通常体现为： 输入 => 执行 => 结果。他不是命令式的，而是对一段操作进行逻辑封装，拿到输入，就能产出结果。通常来说，满足函数式编程的特性的“函数”应该有如下特点:\n\n函数必须有入参，并且函数的产出会根据入参的不同而变化。\n函数执行的整个流程中，不会对全局变量、外部属性等产生影响。\n函数式编程代码量小，干净。\n举个例子：\n\n```javascript\nvar arr = [1,2,3,4,5];\n\nfunction addOne (array) {\n\n    for(var i=0;i<array.length;i++){\n        array[i] += 1;\n    }\n\n    return array;\n}\n\naddOne(arr); // 2,3,4,5,6\n```\n写了一个方法，接受一个数组，产出数组每个成员+1，但这段代码的不足之处在于：\n\n难以复用，如果需求提出 addTwo,addThree方法，需要不断修改函数名和内部逻辑。\n内部的代码很啰嗦， for 循环很low。\n·函数式编程改进版：\n\n```javascript\nlet arr = [1,2,3,4,5];\narr.map(item=> item+1); // 3,4,5,6,7\n```\n\n \n这里，改进使用了原生的 Array.prototype.map 方法，代码量缩小了很多不说，而且复用性进一步提升。整个函数做的事情现在非常直观，入参 => 每项参数 + 1 => 返回新数组，由此，可以说，map()方法是一个纯函数(pure function)。\n\n## 2. 响应式编程 ##\n前端中也有一个概念叫响应式，bootstrap 。这里当然说的不是这个，对于响应式编程的概念，我想提及Vue或者 angular的双向绑定来阐述：\n```javascript\n// template: \n\ni'am {{ name }}\n\n// js:\n\nname = 'jhon';\n```\n\n在前端MVVM的框架中，都有一个数据双向绑定的概念，这里的模版中的变量，实时反映了数据中的 name 变量的 value，而且，如果此时我修改了 name 的值，那么模版中对应的值也会跟着修改。数据 <=> 视图 是同时发生，同时改变的，因为模版就是对数据的一个映射。\n\n再举个例子：\n\nc的值，是通过 a + b 来赋值的，如果ab不是固定的，而是变化的值，那么 c 的值也不会固定为3。 \n```javascript\nlet a = 1,b=2;\n\nlet c = a + b; // 3\n```\n\n不难看出，响应式编程特点：\n\n 同步发生，结果会随着修改参数而实时、动态地变化。\n存在固定的映射关系。","slug":"函数式编程与响应式编程之己见","published":1,"updated":"2018-08-29T06:01:53.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdg8001gjgv4x0fclvcp","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/81157232\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"1-what-is-函数式编程？\"><a href=\"#1-what-is-函数式编程？\" class=\"headerlink\" title=\"1. what is 函数式编程？\"></a>1. what is 函数式编程？</h2><p>函数，在编程中，通常体现为： 输入 =&gt; 执行 =&gt; 结果。他不是命令式的，而是对一段操作进行逻辑封装，拿到输入，就能产出结果。通常来说，满足函数式编程的特性的“函数”应该有如下特点:</p>\n<p>函数必须有入参，并且函数的产出会根据入参的不同而变化。<br>函数执行的整个流程中，不会对全局变量、外部属性等产生影响。<br>函数式编程代码量小，干净。<br>举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addOne</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;array.length;i++)&#123;</span><br><span class=\"line\">        array[i] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addOne(arr); <span class=\"comment\">// 2,3,4,5,6</span></span><br></pre></td></tr></table></figure>\n<p>写了一个方法，接受一个数组，产出数组每个成员+1，但这段代码的不足之处在于：</p>\n<p>难以复用，如果需求提出 addTwo,addThree方法，需要不断修改函数名和内部逻辑。<br>内部的代码很啰嗦， for 循环很low。<br>·函数式编程改进版：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">arr.map(<span class=\"function\"><span class=\"params\">item</span>=&gt;</span> item+<span class=\"number\">1</span>); <span class=\"comment\">// 3,4,5,6,7</span></span><br></pre></td></tr></table></figure>\n<p>这里，改进使用了原生的 Array.prototype.map 方法，代码量缩小了很多不说，而且复用性进一步提升。整个函数做的事情现在非常直观，入参 =&gt; 每项参数 + 1 =&gt; 返回新数组，由此，可以说，map()方法是一个纯函数(pure function)。</p>\n<h2 id=\"2-响应式编程\"><a href=\"#2-响应式编程\" class=\"headerlink\" title=\"2. 响应式编程\"></a>2. 响应式编程</h2><p>前端中也有一个概念叫响应式，bootstrap 。这里当然说的不是这个，对于响应式编程的概念，我想提及Vue或者 angular的双向绑定来阐述：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// template: </span></span><br><span class=\"line\"></span><br><span class=\"line\">i<span class=\"string\">'am &#123;&#123; name &#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// js:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">name = '</span>jhon<span class=\"string\">';</span></span><br></pre></td></tr></table></figure></p>\n<p>在前端MVVM的框架中，都有一个数据双向绑定的概念，这里的模版中的变量，实时反映了数据中的 name 变量的 value，而且，如果此时我修改了 name 的值，那么模版中对应的值也会跟着修改。数据 &lt;=&gt; 视图 是同时发生，同时改变的，因为模版就是对数据的一个映射。</p>\n<p>再举个例子：</p>\n<p>c的值，是通过 a + b 来赋值的，如果ab不是固定的，而是变化的值，那么 c 的值也不会固定为3。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>,b=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = a + b; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>不难看出，响应式编程特点：</p>\n<p> 同步发生，结果会随着修改参数而实时、动态地变化。<br>存在固定的映射关系。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/81157232\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"1-what-is-函数式编程？\"><a href=\"#1-what-is-函数式编程？\" class=\"headerlink\" title=\"1. what is 函数式编程？\"></a>1. what is 函数式编程？</h2><p>函数，在编程中，通常体现为： 输入 =&gt; 执行 =&gt; 结果。他不是命令式的，而是对一段操作进行逻辑封装，拿到输入，就能产出结果。通常来说，满足函数式编程的特性的“函数”应该有如下特点:</p>\n<p>函数必须有入参，并且函数的产出会根据入参的不同而变化。<br>函数执行的整个流程中，不会对全局变量、外部属性等产生影响。<br>函数式编程代码量小，干净。<br>举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addOne</span> (<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;array.length;i++)&#123;</span><br><span class=\"line\">        array[i] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addOne(arr); <span class=\"comment\">// 2,3,4,5,6</span></span><br></pre></td></tr></table></figure>\n<p>写了一个方法，接受一个数组，产出数组每个成员+1，但这段代码的不足之处在于：</p>\n<p>难以复用，如果需求提出 addTwo,addThree方法，需要不断修改函数名和内部逻辑。<br>内部的代码很啰嗦， for 循环很low。<br>·函数式编程改进版：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">arr.map(<span class=\"function\"><span class=\"params\">item</span>=&gt;</span> item+<span class=\"number\">1</span>); <span class=\"comment\">// 3,4,5,6,7</span></span><br></pre></td></tr></table></figure>\n<p>这里，改进使用了原生的 Array.prototype.map 方法，代码量缩小了很多不说，而且复用性进一步提升。整个函数做的事情现在非常直观，入参 =&gt; 每项参数 + 1 =&gt; 返回新数组，由此，可以说，map()方法是一个纯函数(pure function)。</p>\n<h2 id=\"2-响应式编程\"><a href=\"#2-响应式编程\" class=\"headerlink\" title=\"2. 响应式编程\"></a>2. 响应式编程</h2><p>前端中也有一个概念叫响应式，bootstrap 。这里当然说的不是这个，对于响应式编程的概念，我想提及Vue或者 angular的双向绑定来阐述：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// template: </span></span><br><span class=\"line\"></span><br><span class=\"line\">i<span class=\"string\">'am &#123;&#123; name &#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// js:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">name = '</span>jhon<span class=\"string\">';</span></span><br></pre></td></tr></table></figure></p>\n<p>在前端MVVM的框架中，都有一个数据双向绑定的概念，这里的模版中的变量，实时反映了数据中的 name 变量的 value，而且，如果此时我修改了 name 的值，那么模版中对应的值也会跟着修改。数据 &lt;=&gt; 视图 是同时发生，同时改变的，因为模版就是对数据的一个映射。</p>\n<p>再举个例子：</p>\n<p>c的值，是通过 a + b 来赋值的，如果ab不是固定的，而是变化的值，那么 c 的值也不会固定为3。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>,b=<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = a + b; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>不难看出，响应式编程特点：</p>\n<p> 同步发生，结果会随着修改参数而实时、动态地变化。<br>存在固定的映射关系。</p>\n"},{"title":"基于HEXO的个人博客图文搭建详尽过程，看不懂算我输","date":"2018-01-18T08:08:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79096846)\n\n\n\n\n## 前言 ##\n**须知：**\n*1.最终生成的博客地址必须是： ZQ-jhon.github.io  即用户名.github.io*\n*2.本地的HEXO仓库，命名必须也为 ZQ-jhon.github.io ，HEXO项目放置于该目录之下。*\n\n昨天经过一番折腾，终于将HEXO部署上线了，以下对于昨天整个搭建的过程做一个详细的回顾。\n\nHEXO是基于NODE的一款博客框架，有很多丰富的主题可以选择，配合GIT来使用。\n\nGit回顾：[本地仓](http://blog.csdn.net/qq_20264891/article/details/78773371)、[远程仓](http://blog.csdn.net/qq_20264891/article/details/78774208)\n\n## 安装 ##\n\n整个安装过程我是参考一位博主：[HEXO系列教程](http://www.chenyijun.net/2016/06/04/hexo_teach_1/)\n\n以下用自己的理解来做一番梳理与归纳：\n\n*先介绍HEXO中的4个命令：\n\n```\n$ hexo g #完整命令为hexo generate，用于生成静态文件  \n$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览  \n$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上  \n$ hexo n #完整命令为hexo new，用于新建一篇文章\n```\n\n首先，确保本地Git公钥与Github公钥相匹配，参照：[Git本地仓](http://blog.csdn.net/qq_20264891/article/details/78773371)\n\n确认匹配后，新建Repository，命名的时候，规范为：\n\ngithub名字.github.io\n\n因此，这里的新仓库名字应该为： ZQ-jhon.github.io\n\n![这里写图片描述](http://img.blog.csdn.net/20180118155548420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n同样的，在本地新建一个同名的目录：ZQ-jhon.github.io  ，然后打开目录，文件夹是空的\n\n\n**此时，在项目目录下右键打开Gitbash here**\n\n1.`$ cnpm install hexo-cli -g`&nbsp; &nbsp; &nbsp; 使用淘宝镜像安装hexo-cli\n\n2.`npm install hexo-deployer-git --save`&nbsp;&nbsp;&nbsp; 模块安装到开发目录\n\n3.`$ hexo init`&nbsp;&nbsp;&nbsp;初始化\n\n4.`$cnpm install`&nbsp;&nbsp;&nbsp;安装依赖\n\n（PS：中途如果出现问题，可以 `cnpm install hexo-deployer-git --save 安装GIT的PUSH插件）\n`\n5.`$hexo g && hexo s` 构建(genereater)并启动服务(server)，在locallhost:4000下即可预览效果\n\n![这里写图片描述](http://img.blog.csdn.net/20180118154519905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n## 远程部署 ##\n\n本地的文件我们已经在locallhost:4000端口预览的非常满意了，如何部署到站点(github)上呢？\n\n1.首先，找到HEXO目录下的 __yml文件，在最下面修改如下：\n\n```\ndeploy: \n  type: git\n  repository: git@github.com:ZQ-jhon/ZQ-jhon.github.io.git\n  branch: master\n```\n\n![](http://img.blog.csdn.net/20180118154939998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n***注意：如下图所示，这里的repository地址就是Github download时弹出的项目地址，但是最好不要用HTTPS协议，走SSH协议，昨天因为这个问题，调试了一下午！！！***\n\n![这里写图片描述](http://img.blog.csdn.net/20180118155710430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n2.布置好以后，我们来Ping一下Github，看能否有响应：\n\n```\n$ ssh -T git@github.com\n```\n![这里写图片描述](http://img.blog.csdn.net/20180118155238282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n欢迎了一波，很稳。\n\n此时，直接把Server   Ctrl + C\n \n然后 `$HEXO D`&nbsp;&nbsp;&nbsp;直接推送，稍等片刻，打开Github仓库，看看文件是否上传成功\n\n如果上传成功，大功告成，打开 [https:ZQ-jhon.github.io](https:ZQ-jhon.github.io)即可访问博客页面了。\n\n ## 文章新建与MarkDown语法 ##\n\n   \n新建文章 `$hexo n filename`\n    \n这个比较简单，建完文件，也别秀骚操作了，老老实实去source文件夹的_post文件夹里面，去用一个好点的编辑器，修改文本文档，保存为UTF-8格式，并且修改后缀名为.md，保存类型为所有类型，否则上线部署会产生乱码。\n\n值得一提的是，CSDN的在线文档编辑器就采用的是MarkDown语法，而且该种语法与标签语言完全兼容，因此，可以将HTML代码原封不动的全被拷贝近.md文件。\n\n##主题更换与配置##\n\n在我们HEXO根目录下，有一个themes文件夹，里面存放的都是各式各样的主题，默认的是landscape，我们可以去官网，HEXO的THEME分类下下载更多精美的主题，然后解压缩，将文件夹放在themes下，另外稍微修改 __yml文件下，theme:lanscape 即可。\n\n![这里写图片描述](http://img.blog.csdn.net/20180118160508595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n相关的配置，我们可以follow官方推荐作者的github去看看人家的wiki或者code，都有详尽的说明，甚至可以加QQ咨询......\n\n![这里写图片描述](http://img.blog.csdn.net/20180118160644506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 最终效果与总结 ##\nWelcome to the ZQ-jhon.github.io wiki!\n![基本效果预览](http://img.blog.csdn.net/20180118163837782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![文章详情预览](http://img.blog.csdn.net/20180118163853108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![搜索模块预览](http://img.blog.csdn.net/20180118163911153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n不得不说GITHUB开源生态真的非常强大，感谢这些开发者带来的精美主题。\n\n感谢主题作者Miachel.Lu[HEXO-Mellow-theme  点击查看该项目](https://github.com/codefine/hexo-theme-mellow)\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/基于HEXO的个人博客图文搭建详尽过程，看不懂算我输.md","raw":"---\ntitle:  基于HEXO的个人博客图文搭建详尽过程，看不懂算我输\ndate: 2018-01-18 16:08:00\ntags: [HEXO,动态部署]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79096846)\n\n\n\n\n## 前言 ##\n**须知：**\n*1.最终生成的博客地址必须是： ZQ-jhon.github.io  即用户名.github.io*\n*2.本地的HEXO仓库，命名必须也为 ZQ-jhon.github.io ，HEXO项目放置于该目录之下。*\n\n昨天经过一番折腾，终于将HEXO部署上线了，以下对于昨天整个搭建的过程做一个详细的回顾。\n\nHEXO是基于NODE的一款博客框架，有很多丰富的主题可以选择，配合GIT来使用。\n\nGit回顾：[本地仓](http://blog.csdn.net/qq_20264891/article/details/78773371)、[远程仓](http://blog.csdn.net/qq_20264891/article/details/78774208)\n\n## 安装 ##\n\n整个安装过程我是参考一位博主：[HEXO系列教程](http://www.chenyijun.net/2016/06/04/hexo_teach_1/)\n\n以下用自己的理解来做一番梳理与归纳：\n\n*先介绍HEXO中的4个命令：\n\n```\n$ hexo g #完整命令为hexo generate，用于生成静态文件  \n$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览  \n$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上  \n$ hexo n #完整命令为hexo new，用于新建一篇文章\n```\n\n首先，确保本地Git公钥与Github公钥相匹配，参照：[Git本地仓](http://blog.csdn.net/qq_20264891/article/details/78773371)\n\n确认匹配后，新建Repository，命名的时候，规范为：\n\ngithub名字.github.io\n\n因此，这里的新仓库名字应该为： ZQ-jhon.github.io\n\n![这里写图片描述](http://img.blog.csdn.net/20180118155548420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n同样的，在本地新建一个同名的目录：ZQ-jhon.github.io  ，然后打开目录，文件夹是空的\n\n\n**此时，在项目目录下右键打开Gitbash here**\n\n1.`$ cnpm install hexo-cli -g`&nbsp; &nbsp; &nbsp; 使用淘宝镜像安装hexo-cli\n\n2.`npm install hexo-deployer-git --save`&nbsp;&nbsp;&nbsp; 模块安装到开发目录\n\n3.`$ hexo init`&nbsp;&nbsp;&nbsp;初始化\n\n4.`$cnpm install`&nbsp;&nbsp;&nbsp;安装依赖\n\n（PS：中途如果出现问题，可以 `cnpm install hexo-deployer-git --save 安装GIT的PUSH插件）\n`\n5.`$hexo g && hexo s` 构建(genereater)并启动服务(server)，在locallhost:4000下即可预览效果\n\n![这里写图片描述](http://img.blog.csdn.net/20180118154519905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n## 远程部署 ##\n\n本地的文件我们已经在locallhost:4000端口预览的非常满意了，如何部署到站点(github)上呢？\n\n1.首先，找到HEXO目录下的 __yml文件，在最下面修改如下：\n\n```\ndeploy: \n  type: git\n  repository: git@github.com:ZQ-jhon/ZQ-jhon.github.io.git\n  branch: master\n```\n\n![](http://img.blog.csdn.net/20180118154939998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n***注意：如下图所示，这里的repository地址就是Github download时弹出的项目地址，但是最好不要用HTTPS协议，走SSH协议，昨天因为这个问题，调试了一下午！！！***\n\n![这里写图片描述](http://img.blog.csdn.net/20180118155710430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n2.布置好以后，我们来Ping一下Github，看能否有响应：\n\n```\n$ ssh -T git@github.com\n```\n![这里写图片描述](http://img.blog.csdn.net/20180118155238282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n欢迎了一波，很稳。\n\n此时，直接把Server   Ctrl + C\n \n然后 `$HEXO D`&nbsp;&nbsp;&nbsp;直接推送，稍等片刻，打开Github仓库，看看文件是否上传成功\n\n如果上传成功，大功告成，打开 [https:ZQ-jhon.github.io](https:ZQ-jhon.github.io)即可访问博客页面了。\n\n ## 文章新建与MarkDown语法 ##\n\n   \n新建文章 `$hexo n filename`\n    \n这个比较简单，建完文件，也别秀骚操作了，老老实实去source文件夹的_post文件夹里面，去用一个好点的编辑器，修改文本文档，保存为UTF-8格式，并且修改后缀名为.md，保存类型为所有类型，否则上线部署会产生乱码。\n\n值得一提的是，CSDN的在线文档编辑器就采用的是MarkDown语法，而且该种语法与标签语言完全兼容，因此，可以将HTML代码原封不动的全被拷贝近.md文件。\n\n##主题更换与配置##\n\n在我们HEXO根目录下，有一个themes文件夹，里面存放的都是各式各样的主题，默认的是landscape，我们可以去官网，HEXO的THEME分类下下载更多精美的主题，然后解压缩，将文件夹放在themes下，另外稍微修改 __yml文件下，theme:lanscape 即可。\n\n![这里写图片描述](http://img.blog.csdn.net/20180118160508595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n相关的配置，我们可以follow官方推荐作者的github去看看人家的wiki或者code，都有详尽的说明，甚至可以加QQ咨询......\n\n![这里写图片描述](http://img.blog.csdn.net/20180118160644506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 最终效果与总结 ##\nWelcome to the ZQ-jhon.github.io wiki!\n![基本效果预览](http://img.blog.csdn.net/20180118163837782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![文章详情预览](http://img.blog.csdn.net/20180118163853108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![搜索模块预览](http://img.blog.csdn.net/20180118163911153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n不得不说GITHUB开源生态真的非常强大，感谢这些开发者带来的精美主题。\n\n感谢主题作者Miachel.Lu[HEXO-Mellow-theme  点击查看该项目](https://github.com/codefine/hexo-theme-mellow)\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"基于HEXO的个人博客图文搭建详尽过程，看不懂算我输","published":1,"updated":"2018-08-29T06:02:02.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdga001ijgv43o8w807v","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79096846\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><strong>须知：</strong><br><em>1.最终生成的博客地址必须是： ZQ-jhon.github.io  即用户名.github.io</em><br><em>2.本地的HEXO仓库，命名必须也为 ZQ-jhon.github.io ，HEXO项目放置于该目录之下。</em></p>\n<p>昨天经过一番折腾，终于将HEXO部署上线了，以下对于昨天整个搭建的过程做一个详细的回顾。</p>\n<p>HEXO是基于NODE的一款博客框架，有很多丰富的主题可以选择，配合GIT来使用。</p>\n<p>Git回顾：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78773371\" target=\"_blank\" rel=\"noopener\">本地仓</a>、<a href=\"http://blog.csdn.net/qq_20264891/article/details/78774208\" target=\"_blank\" rel=\"noopener\">远程仓</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>整个安装过程我是参考一位博主：<a href=\"http://www.chenyijun.net/2016/06/04/hexo_teach_1/\" target=\"_blank\" rel=\"noopener\">HEXO系列教程</a></p>\n<p>以下用自己的理解来做一番梳理与归纳：</p>\n<p>*先介绍HEXO中的4个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g #完整命令为hexo generate，用于生成静态文件  </span><br><span class=\"line\">$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览  </span><br><span class=\"line\">$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上  </span><br><span class=\"line\">$ hexo n #完整命令为hexo new，用于新建一篇文章</span><br></pre></td></tr></table></figure>\n<p>首先，确保本地Git公钥与Github公钥相匹配，参照：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78773371\" target=\"_blank\" rel=\"noopener\">Git本地仓</a></p>\n<p>确认匹配后，新建Repository，命名的时候，规范为：</p>\n<p>github名字.github.io</p>\n<p>因此，这里的新仓库名字应该为： ZQ-jhon.github.io</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118155548420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>同样的，在本地新建一个同名的目录：ZQ-jhon.github.io  ，然后打开目录，文件夹是空的</p>\n<p><strong>此时，在项目目录下右键打开Gitbash here</strong></p>\n<p>1.<code>$ cnpm install hexo-cli -g</code>&nbsp; &nbsp; &nbsp; 使用淘宝镜像安装hexo-cli</p>\n<p>2.<code>npm install hexo-deployer-git --save</code>&nbsp;&nbsp;&nbsp; 模块安装到开发目录</p>\n<p>3.<code>$ hexo init</code>&nbsp;&nbsp;&nbsp;初始化</p>\n<p>4.<code>$cnpm install</code>&nbsp;&nbsp;&nbsp;安装依赖</p>\n<p>（PS：中途如果出现问题，可以 <code>cnpm install hexo-deployer-git --save 安装GIT的PUSH插件）</code><br>5.<code>$hexo g &amp;&amp; hexo s</code> 构建(genereater)并启动服务(server)，在locallhost:4000下即可预览效果</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118154519905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h2 id=\"远程部署\"><a href=\"#远程部署\" class=\"headerlink\" title=\"远程部署\"></a>远程部署</h2><p>本地的文件我们已经在locallhost:4000端口预览的非常满意了，如何部署到站点(github)上呢？</p>\n<p>1.首先，找到HEXO目录下的 __yml文件，在最下面修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy: </span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:ZQ-jhon/ZQ-jhon.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118154939998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\" title=\"\" class=\"\">\n                <p></p>\n            </figure>\n<p><strong><em>注意：如下图所示，这里的repository地址就是Github download时弹出的项目地址，但是最好不要用HTTPS协议，走SSH协议，昨天因为这个问题，调试了一下午！！！</em></strong></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118155710430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>2.布置好以后，我们来Ping一下Github，看能否有响应：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118155238282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>欢迎了一波，很稳。</p>\n<p>此时，直接把Server   Ctrl + C</p>\n<p>然后 <code>$HEXO D</code>&nbsp;&nbsp;&nbsp;直接推送，稍等片刻，打开Github仓库，看看文件是否上传成功</p>\n<p>如果上传成功，大功告成，打开 <a href=\"https:ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https:ZQ-jhon.github.io</a>即可访问博客页面了。</p>\n<h2 id=\"文章新建与MarkDown语法\"><a href=\"#文章新建与MarkDown语法\" class=\"headerlink\" title=\"文章新建与MarkDown语法\"></a>文章新建与MarkDown语法</h2><p>新建文章 <code>$hexo n filename</code></p>\n<p>这个比较简单，建完文件，也别秀骚操作了，老老实实去source文件夹的_post文件夹里面，去用一个好点的编辑器，修改文本文档，保存为UTF-8格式，并且修改后缀名为.md，保存类型为所有类型，否则上线部署会产生乱码。</p>\n<p>值得一提的是，CSDN的在线文档编辑器就采用的是MarkDown语法，而且该种语法与标签语言完全兼容，因此，可以将HTML代码原封不动的全被拷贝近.md文件。</p>\n<p>##主题更换与配置##</p>\n<p>在我们HEXO根目录下，有一个themes文件夹，里面存放的都是各式各样的主题，默认的是landscape，我们可以去官网，HEXO的THEME分类下下载更多精美的主题，然后解压缩，将文件夹放在themes下，另外稍微修改 __yml文件下，theme:lanscape 即可。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118160508595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>相关的配置，我们可以follow官方推荐作者的github去看看人家的wiki或者code，都有详尽的说明，甚至可以加QQ咨询……</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118160644506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h2 id=\"最终效果与总结\"><a href=\"#最终效果与总结\" class=\"headerlink\" title=\"最终效果与总结\"></a>最终效果与总结</h2><p>Welcome to the ZQ-jhon.github.io wiki!<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118163837782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"基本效果预览\" title=\"\" class=\"\">\n                <p>基本效果预览</p>\n            </figure><br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118163853108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"文章详情预览\" title=\"\" class=\"\">\n                <p>文章详情预览</p>\n            </figure><br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118163911153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"搜索模块预览\" title=\"\" class=\"\">\n                <p>搜索模块预览</p>\n            </figure></p>\n<p>不得不说GITHUB开源生态真的非常强大，感谢这些开发者带来的精美主题。</p>\n<p>感谢主题作者Miachel.Lu<a href=\"https://github.com/codefine/hexo-theme-mellow\" target=\"_blank\" rel=\"noopener\">HEXO-Mellow-theme  点击查看该项目</a></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79096846\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><strong>须知：</strong><br><em>1.最终生成的博客地址必须是： ZQ-jhon.github.io  即用户名.github.io</em><br><em>2.本地的HEXO仓库，命名必须也为 ZQ-jhon.github.io ，HEXO项目放置于该目录之下。</em></p>\n<p>昨天经过一番折腾，终于将HEXO部署上线了，以下对于昨天整个搭建的过程做一个详细的回顾。</p>\n<p>HEXO是基于NODE的一款博客框架，有很多丰富的主题可以选择，配合GIT来使用。</p>\n<p>Git回顾：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78773371\" target=\"_blank\" rel=\"noopener\">本地仓</a>、<a href=\"http://blog.csdn.net/qq_20264891/article/details/78774208\" target=\"_blank\" rel=\"noopener\">远程仓</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>整个安装过程我是参考一位博主：<a href=\"http://www.chenyijun.net/2016/06/04/hexo_teach_1/\" target=\"_blank\" rel=\"noopener\">HEXO系列教程</a></p>\n<p>以下用自己的理解来做一番梳理与归纳：</p>\n<p>*先介绍HEXO中的4个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g #完整命令为hexo generate，用于生成静态文件  </span><br><span class=\"line\">$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览  </span><br><span class=\"line\">$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上  </span><br><span class=\"line\">$ hexo n #完整命令为hexo new，用于新建一篇文章</span><br></pre></td></tr></table></figure>\n<p>首先，确保本地Git公钥与Github公钥相匹配，参照：<a href=\"http://blog.csdn.net/qq_20264891/article/details/78773371\" target=\"_blank\" rel=\"noopener\">Git本地仓</a></p>\n<p>确认匹配后，新建Repository，命名的时候，规范为：</p>\n<p>github名字.github.io</p>\n<p>因此，这里的新仓库名字应该为： ZQ-jhon.github.io</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118155548420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>同样的，在本地新建一个同名的目录：ZQ-jhon.github.io  ，然后打开目录，文件夹是空的</p>\n<p><strong>此时，在项目目录下右键打开Gitbash here</strong></p>\n<p>1.<code>$ cnpm install hexo-cli -g</code>&nbsp; &nbsp; &nbsp; 使用淘宝镜像安装hexo-cli</p>\n<p>2.<code>npm install hexo-deployer-git --save</code>&nbsp;&nbsp;&nbsp; 模块安装到开发目录</p>\n<p>3.<code>$ hexo init</code>&nbsp;&nbsp;&nbsp;初始化</p>\n<p>4.<code>$cnpm install</code>&nbsp;&nbsp;&nbsp;安装依赖</p>\n<p>（PS：中途如果出现问题，可以 <code>cnpm install hexo-deployer-git --save 安装GIT的PUSH插件）</code><br>5.<code>$hexo g &amp;&amp; hexo s</code> 构建(genereater)并启动服务(server)，在locallhost:4000下即可预览效果</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118154519905?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h2 id=\"远程部署\"><a href=\"#远程部署\" class=\"headerlink\" title=\"远程部署\"></a>远程部署</h2><p>本地的文件我们已经在locallhost:4000端口预览的非常满意了，如何部署到站点(github)上呢？</p>\n<p>1.首先，找到HEXO目录下的 __yml文件，在最下面修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy: </span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:ZQ-jhon/ZQ-jhon.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118154939998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\" title=\"\" class=\"\">\n                <p></p>\n            </figure>\n<p><strong><em>注意：如下图所示，这里的repository地址就是Github download时弹出的项目地址，但是最好不要用HTTPS协议，走SSH协议，昨天因为这个问题，调试了一下午！！！</em></strong></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118155710430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>2.布置好以后，我们来Ping一下Github，看能否有响应：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118155238282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>欢迎了一波，很稳。</p>\n<p>此时，直接把Server   Ctrl + C</p>\n<p>然后 <code>$HEXO D</code>&nbsp;&nbsp;&nbsp;直接推送，稍等片刻，打开Github仓库，看看文件是否上传成功</p>\n<p>如果上传成功，大功告成，打开 <a href=\"https:ZQ-jhon.github.io\" target=\"_blank\" rel=\"noopener\">https:ZQ-jhon.github.io</a>即可访问博客页面了。</p>\n<h2 id=\"文章新建与MarkDown语法\"><a href=\"#文章新建与MarkDown语法\" class=\"headerlink\" title=\"文章新建与MarkDown语法\"></a>文章新建与MarkDown语法</h2><p>新建文章 <code>$hexo n filename</code></p>\n<p>这个比较简单，建完文件，也别秀骚操作了，老老实实去source文件夹的_post文件夹里面，去用一个好点的编辑器，修改文本文档，保存为UTF-8格式，并且修改后缀名为.md，保存类型为所有类型，否则上线部署会产生乱码。</p>\n<p>值得一提的是，CSDN的在线文档编辑器就采用的是MarkDown语法，而且该种语法与标签语言完全兼容，因此，可以将HTML代码原封不动的全被拷贝近.md文件。</p>\n<p>##主题更换与配置##</p>\n<p>在我们HEXO根目录下，有一个themes文件夹，里面存放的都是各式各样的主题，默认的是landscape，我们可以去官网，HEXO的THEME分类下下载更多精美的主题，然后解压缩，将文件夹放在themes下，另外稍微修改 __yml文件下，theme:lanscape 即可。</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118160508595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>相关的配置，我们可以follow官方推荐作者的github去看看人家的wiki或者code，都有详尽的说明，甚至可以加QQ咨询……</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118160644506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h2 id=\"最终效果与总结\"><a href=\"#最终效果与总结\" class=\"headerlink\" title=\"最终效果与总结\"></a>最终效果与总结</h2><p>Welcome to the ZQ-jhon.github.io wiki!<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118163837782?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"基本效果预览\" title=\"\" class=\"\">\n                <p>基本效果预览</p>\n            </figure><br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118163853108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"文章详情预览\" title=\"\" class=\"\">\n                <p>文章详情预览</p>\n            </figure><br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180118163911153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"搜索模块预览\" title=\"\" class=\"\">\n                <p>搜索模块预览</p>\n            </figure></p>\n<p>不得不说GITHUB开源生态真的非常强大，感谢这些开发者带来的精美主题。</p>\n<p>感谢主题作者Miachel.Lu<a href=\"https://github.com/codefine/hexo-theme-mellow\" target=\"_blank\" rel=\"noopener\">HEXO-Mellow-theme  点击查看该项目</a></p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"基于bootstrap特殊分辨率页面的实现思路","date":"2018-04-14T15:11:09.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/79945485)\n\n## 前言 ##\n很久没更新博客，这段时间刚刚找到工作，会立即（从今天起）恢复更新博客的频率。罗马不是一天建成的，希望自己保持良好的学习和做笔记的习惯，笔耕不缀，他日可期！\n## 1.Boostrap重构传统固定px的页面 ##\n在第一次接手重构任务后，有点懵逼。可能是因为自己很久没有写代码了，忘了以前做的响应式的一些细节，所以又开始不断的调试，总算是把坑补上了，于是在此做一下记录。\nPSD需求图：\n![这里写图片描述](https://img-blog.csdn.net/20180414231532595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)整个需求其实蛮简单的，就是一个固定1122px的页面，里面有些图片，图片在pc端需要留出固定margin（需要像素级还原PSD稿）。想了想，自己以前做的响应式都是根据 .container类的默认宽度来写的，于是想了一会便有答案，整体思路如下：\n\n 1. 给整个页面给一个 container类，并且限制 max-width 为1122px。\n 2. 页面中右侧的小兔，因为所有图片都是从后台接口调取，一旦设定img-responsive，那么默认的max-width就是100%(想象一下，如果后台传来一个1000宽的图，用户网络慢点，基本上就GG了)，只能按照原图比例来缩放，何况每个图片的容器都是动态高度的...所以，每张图片的宽高，尽可能的去用js动态设定。\n 3. 尽量使用Rem，设定好body的font-size，然后各部分的font-size都根据rem去取，例如 0.8rem,0.6rem等等。\n 3. 布局方面，左侧的长图固定的，非接口调取，宽高固定的。在整个页面中，缩放的比例完全是以此图片作为参照物。因此给此图片加上img-responsive以及col-lg-3 col-md-3 col-sm-6 col-xs-6类，然后动态的让单个盒子容器的高度取 左侧长图的高度，这样会让盒子完美的呈现，不会留有内边距，也不会让box-shadow很难看。\n右侧的6张小图，每纵向的两个图使用一个列容器来包裹，设定 col-lg-3  col-md-3  col-sm-6 col-xs-6，这样就可以达到在手机端的显示效果，如图所示：\n![这里写图片描述](https://img-blog.csdn.net/20180414231323872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n## 2.核心逻辑代码 ##\n\n```\n//动态设置每个box-shadow 容器的高度，为imgLong的高度\nvar h = $('#imgLong').first().height();\n\n$('.box').each(function(){\n\t$(this).css({\n\t\theight:h\n\t});\n});\n$(window).resize(function(){\n\tvar h=$(\"#imgLong\").first().height();$(\".box\").each(function(){$(this).css({height:h})});\n});\n\t\t\t\t\t\n//限制h4标签文本长度\n\t$('.imgTitle').each(function(){\n\t//这里由于后台Trs模版获取的标题，前面有N个空格，因此需要前端来消化一下字数，故进行“空格剔除”，所以用  .split(' ').join('')\n\tvar txt = $(this).text().split(' ').join('');\n\tif(txt.length>20){\t\t\n\t\n\t//其实真正的标题就10个字，但是前面有10个空格\n\t\t\t                             $(this).text(txt.substring(0,19)+'...');\n\t\t}\n    });\n\t\t\t\t\t\n//为所有调用的imgShort图片增加CLASS\n\t\t\t\t\t\n$('.imgShortParent img').each(function(){\n\t\t\t$(this).addClass('imgShort');\n});\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n//动态设定每个单列容器的宽度 = imgLong的宽度，高度 = imgLong的高度，以此来保证图片不会溢出 box-shadow。\nvar h = $('.imgLong').first().height();\nvar w = $('.imgLong').first().width();\n\n$('.col-box').each(function(){\n   $(this).width(w).height(h);\n});\n\n$(window).resize(function(){\n//页面缩放时，动态获取宽高，并赋值给 col-box 列容器。\n  $('.col-box').each(function(){\n   $(this).width(w).height(h);\n})\n\n})\n```\n## 3.不足与改进思路 ##\n3.1 页面性能不足，重绘过多，网速慢的时候，会有一瞬间发生：【图片突然很大，然后被缩放到正常比例】的恐怖现象。。。\n解决方案：\n可以为每张小图(250*165)包裹一层div，设置max-height与max-width，overflow:hidden，来解决。\n\n3.2 实际上，整个项目我写了两套html骨架（由于项目紧，刚接手，长时间没写代码比较陌生），pc一套，mobile一套，感到非常罪过，不配成为一个前端工程师。。。但是话说回来，原先的项目也写的太TM乱了，一个注释都没有，而且一个页面中script标签不下20个。。。\n解决方案：\n用我上述的思路去实现\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","source":"_posts/基于bootstrap特殊分辨率页面的实现思路.md","raw":"---\ntitle: 基于bootstrap特殊分辨率页面的实现思路 \ndate: 2018-04-14 23:11:09\ntags: bootstrap\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/79945485)\n\n## 前言 ##\n很久没更新博客，这段时间刚刚找到工作，会立即（从今天起）恢复更新博客的频率。罗马不是一天建成的，希望自己保持良好的学习和做笔记的习惯，笔耕不缀，他日可期！\n## 1.Boostrap重构传统固定px的页面 ##\n在第一次接手重构任务后，有点懵逼。可能是因为自己很久没有写代码了，忘了以前做的响应式的一些细节，所以又开始不断的调试，总算是把坑补上了，于是在此做一下记录。\nPSD需求图：\n![这里写图片描述](https://img-blog.csdn.net/20180414231532595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)整个需求其实蛮简单的，就是一个固定1122px的页面，里面有些图片，图片在pc端需要留出固定margin（需要像素级还原PSD稿）。想了想，自己以前做的响应式都是根据 .container类的默认宽度来写的，于是想了一会便有答案，整体思路如下：\n\n 1. 给整个页面给一个 container类，并且限制 max-width 为1122px。\n 2. 页面中右侧的小兔，因为所有图片都是从后台接口调取，一旦设定img-responsive，那么默认的max-width就是100%(想象一下，如果后台传来一个1000宽的图，用户网络慢点，基本上就GG了)，只能按照原图比例来缩放，何况每个图片的容器都是动态高度的...所以，每张图片的宽高，尽可能的去用js动态设定。\n 3. 尽量使用Rem，设定好body的font-size，然后各部分的font-size都根据rem去取，例如 0.8rem,0.6rem等等。\n 3. 布局方面，左侧的长图固定的，非接口调取，宽高固定的。在整个页面中，缩放的比例完全是以此图片作为参照物。因此给此图片加上img-responsive以及col-lg-3 col-md-3 col-sm-6 col-xs-6类，然后动态的让单个盒子容器的高度取 左侧长图的高度，这样会让盒子完美的呈现，不会留有内边距，也不会让box-shadow很难看。\n右侧的6张小图，每纵向的两个图使用一个列容器来包裹，设定 col-lg-3  col-md-3  col-sm-6 col-xs-6，这样就可以达到在手机端的显示效果，如图所示：\n![这里写图片描述](https://img-blog.csdn.net/20180414231323872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n## 2.核心逻辑代码 ##\n\n```\n//动态设置每个box-shadow 容器的高度，为imgLong的高度\nvar h = $('#imgLong').first().height();\n\n$('.box').each(function(){\n\t$(this).css({\n\t\theight:h\n\t});\n});\n$(window).resize(function(){\n\tvar h=$(\"#imgLong\").first().height();$(\".box\").each(function(){$(this).css({height:h})});\n});\n\t\t\t\t\t\n//限制h4标签文本长度\n\t$('.imgTitle').each(function(){\n\t//这里由于后台Trs模版获取的标题，前面有N个空格，因此需要前端来消化一下字数，故进行“空格剔除”，所以用  .split(' ').join('')\n\tvar txt = $(this).text().split(' ').join('');\n\tif(txt.length>20){\t\t\n\t\n\t//其实真正的标题就10个字，但是前面有10个空格\n\t\t\t                             $(this).text(txt.substring(0,19)+'...');\n\t\t}\n    });\n\t\t\t\t\t\n//为所有调用的imgShort图片增加CLASS\n\t\t\t\t\t\n$('.imgShortParent img').each(function(){\n\t\t\t$(this).addClass('imgShort');\n});\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n//动态设定每个单列容器的宽度 = imgLong的宽度，高度 = imgLong的高度，以此来保证图片不会溢出 box-shadow。\nvar h = $('.imgLong').first().height();\nvar w = $('.imgLong').first().width();\n\n$('.col-box').each(function(){\n   $(this).width(w).height(h);\n});\n\n$(window).resize(function(){\n//页面缩放时，动态获取宽高，并赋值给 col-box 列容器。\n  $('.col-box').each(function(){\n   $(this).width(w).height(h);\n})\n\n})\n```\n## 3.不足与改进思路 ##\n3.1 页面性能不足，重绘过多，网速慢的时候，会有一瞬间发生：【图片突然很大，然后被缩放到正常比例】的恐怖现象。。。\n解决方案：\n可以为每张小图(250*165)包裹一层div，设置max-height与max-width，overflow:hidden，来解决。\n\n3.2 实际上，整个项目我写了两套html骨架（由于项目紧，刚接手，长时间没写代码比较陌生），pc一套，mobile一套，感到非常罪过，不配成为一个前端工程师。。。但是话说回来，原先的项目也写的太TM乱了，一个注释都没有，而且一个页面中script标签不下20个。。。\n解决方案：\n用我上述的思路去实现\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>\n\n","slug":"基于bootstrap特殊分辨率页面的实现思路","published":1,"updated":"2018-08-29T05:59:20.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdgc001jjgv40c94qgls","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/79945485\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很久没更新博客，这段时间刚刚找到工作，会立即（从今天起）恢复更新博客的频率。罗马不是一天建成的，希望自己保持良好的学习和做笔记的习惯，笔耕不缀，他日可期！</p>\n<h2 id=\"1-Boostrap重构传统固定px的页面\"><a href=\"#1-Boostrap重构传统固定px的页面\" class=\"headerlink\" title=\"1.Boostrap重构传统固定px的页面\"></a>1.Boostrap重构传统固定px的页面</h2><p>在第一次接手重构任务后，有点懵逼。可能是因为自己很久没有写代码了，忘了以前做的响应式的一些细节，所以又开始不断的调试，总算是把坑补上了，于是在此做一下记录。<br>PSD需求图：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180414231532595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>整个需求其实蛮简单的，就是一个固定1122px的页面，里面有些图片，图片在pc端需要留出固定margin（需要像素级还原PSD稿）。想了想，自己以前做的响应式都是根据 .container类的默认宽度来写的，于是想了一会便有答案，整体思路如下：</p>\n<ol>\n<li>给整个页面给一个 container类，并且限制 max-width 为1122px。</li>\n<li>页面中右侧的小兔，因为所有图片都是从后台接口调取，一旦设定img-responsive，那么默认的max-width就是100%(想象一下，如果后台传来一个1000宽的图，用户网络慢点，基本上就GG了)，只能按照原图比例来缩放，何况每个图片的容器都是动态高度的…所以，每张图片的宽高，尽可能的去用js动态设定。</li>\n<li>尽量使用Rem，设定好body的font-size，然后各部分的font-size都根据rem去取，例如 0.8rem,0.6rem等等。</li>\n<li>布局方面，左侧的长图固定的，非接口调取，宽高固定的。在整个页面中，缩放的比例完全是以此图片作为参照物。因此给此图片加上img-responsive以及col-lg-3 col-md-3 col-sm-6 col-xs-6类，然后动态的让单个盒子容器的高度取 左侧长图的高度，这样会让盒子完美的呈现，不会留有内边距，也不会让box-shadow很难看。<br>右侧的6张小图，每纵向的两个图使用一个列容器来包裹，设定 col-lg-3  col-md-3  col-sm-6 col-xs-6，这样就可以达到在手机端的显示效果，如图所示：<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180414231323872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h2 id=\"2-核心逻辑代码\"><a href=\"#2-核心逻辑代码\" class=\"headerlink\" title=\"2.核心逻辑代码\"></a>2.核心逻辑代码</h2></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//动态设置每个box-shadow 容器的高度，为imgLong的高度</span><br><span class=\"line\">var h = $(&apos;#imgLong&apos;).first().height();</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;.box&apos;).each(function()&#123;</span><br><span class=\"line\">\t$(this).css(&#123;</span><br><span class=\"line\">\t\theight:h</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$(window).resize(function()&#123;</span><br><span class=\"line\">\tvar h=$(&quot;#imgLong&quot;).first().height();$(&quot;.box&quot;).each(function()&#123;$(this).css(&#123;height:h&#125;)&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">//限制h4标签文本长度</span><br><span class=\"line\">\t$(&apos;.imgTitle&apos;).each(function()&#123;</span><br><span class=\"line\">\t//这里由于后台Trs模版获取的标题，前面有N个空格，因此需要前端来消化一下字数，故进行“空格剔除”，所以用  .split(&apos; &apos;).join(&apos;&apos;)</span><br><span class=\"line\">\tvar txt = $(this).text().split(&apos; &apos;).join(&apos;&apos;);</span><br><span class=\"line\">\tif(txt.length&gt;20)&#123;\t\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//其实真正的标题就10个字，但是前面有10个空格</span><br><span class=\"line\">\t\t\t                             $(this).text(txt.substring(0,19)+&apos;...&apos;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">//为所有调用的imgShort图片增加CLASS</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">$(&apos;.imgShortParent img&apos;).each(function()&#123;</span><br><span class=\"line\">\t\t\t$(this).addClass(&apos;imgShort&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">//动态设定每个单列容器的宽度 = imgLong的宽度，高度 = imgLong的高度，以此来保证图片不会溢出 box-shadow。</span><br><span class=\"line\">var h = $(&apos;.imgLong&apos;).first().height();</span><br><span class=\"line\">var w = $(&apos;.imgLong&apos;).first().width();</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;.col-box&apos;).each(function()&#123;</span><br><span class=\"line\">   $(this).width(w).height(h);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(window).resize(function()&#123;</span><br><span class=\"line\">//页面缩放时，动态获取宽高，并赋值给 col-box 列容器。</span><br><span class=\"line\">  $(&apos;.col-box&apos;).each(function()&#123;</span><br><span class=\"line\">   $(this).width(w).height(h);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-不足与改进思路\"><a href=\"#3-不足与改进思路\" class=\"headerlink\" title=\"3.不足与改进思路\"></a>3.不足与改进思路</h2><p>3.1 页面性能不足，重绘过多，网速慢的时候，会有一瞬间发生：【图片突然很大，然后被缩放到正常比例】的恐怖现象。。。<br>解决方案：<br>可以为每张小图(250*165)包裹一层div，设置max-height与max-width，overflow:hidden，来解决。</p>\n<p>3.2 实际上，整个项目我写了两套html骨架（由于项目紧，刚接手，长时间没写代码比较陌生），pc一套，mobile一套，感到非常罪过，不配成为一个前端工程师。。。但是话说回来，原先的项目也写的太TM乱了，一个注释都没有，而且一个页面中script标签不下20个。。。<br>解决方案：<br>用我上述的思路去实现</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/79945485\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很久没更新博客，这段时间刚刚找到工作，会立即（从今天起）恢复更新博客的频率。罗马不是一天建成的，希望自己保持良好的学习和做笔记的习惯，笔耕不缀，他日可期！</p>\n<h2 id=\"1-Boostrap重构传统固定px的页面\"><a href=\"#1-Boostrap重构传统固定px的页面\" class=\"headerlink\" title=\"1.Boostrap重构传统固定px的页面\"></a>1.Boostrap重构传统固定px的页面</h2><p>在第一次接手重构任务后，有点懵逼。可能是因为自己很久没有写代码了，忘了以前做的响应式的一些细节，所以又开始不断的调试，总算是把坑补上了，于是在此做一下记录。<br>PSD需求图：<br><figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180414231532595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>整个需求其实蛮简单的，就是一个固定1122px的页面，里面有些图片，图片在pc端需要留出固定margin（需要像素级还原PSD稿）。想了想，自己以前做的响应式都是根据 .container类的默认宽度来写的，于是想了一会便有答案，整体思路如下：</p>\n<ol>\n<li>给整个页面给一个 container类，并且限制 max-width 为1122px。</li>\n<li>页面中右侧的小兔，因为所有图片都是从后台接口调取，一旦设定img-responsive，那么默认的max-width就是100%(想象一下，如果后台传来一个1000宽的图，用户网络慢点，基本上就GG了)，只能按照原图比例来缩放，何况每个图片的容器都是动态高度的…所以，每张图片的宽高，尽可能的去用js动态设定。</li>\n<li>尽量使用Rem，设定好body的font-size，然后各部分的font-size都根据rem去取，例如 0.8rem,0.6rem等等。</li>\n<li>布局方面，左侧的长图固定的，非接口调取，宽高固定的。在整个页面中，缩放的比例完全是以此图片作为参照物。因此给此图片加上img-responsive以及col-lg-3 col-md-3 col-sm-6 col-xs-6类，然后动态的让单个盒子容器的高度取 左侧长图的高度，这样会让盒子完美的呈现，不会留有内边距，也不会让box-shadow很难看。<br>右侧的6张小图，每纵向的两个图使用一个列容器来包裹，设定 col-lg-3  col-md-3  col-sm-6 col-xs-6，这样就可以达到在手机端的显示效果，如图所示：<figure class=\"image-box\">\n                <img src=\"https://img-blog.csdn.net/20180414231323872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMjY0ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<h2 id=\"2-核心逻辑代码\"><a href=\"#2-核心逻辑代码\" class=\"headerlink\" title=\"2.核心逻辑代码\"></a>2.核心逻辑代码</h2></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//动态设置每个box-shadow 容器的高度，为imgLong的高度</span><br><span class=\"line\">var h = $(&apos;#imgLong&apos;).first().height();</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;.box&apos;).each(function()&#123;</span><br><span class=\"line\">\t$(this).css(&#123;</span><br><span class=\"line\">\t\theight:h</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$(window).resize(function()&#123;</span><br><span class=\"line\">\tvar h=$(&quot;#imgLong&quot;).first().height();$(&quot;.box&quot;).each(function()&#123;$(this).css(&#123;height:h&#125;)&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">//限制h4标签文本长度</span><br><span class=\"line\">\t$(&apos;.imgTitle&apos;).each(function()&#123;</span><br><span class=\"line\">\t//这里由于后台Trs模版获取的标题，前面有N个空格，因此需要前端来消化一下字数，故进行“空格剔除”，所以用  .split(&apos; &apos;).join(&apos;&apos;)</span><br><span class=\"line\">\tvar txt = $(this).text().split(&apos; &apos;).join(&apos;&apos;);</span><br><span class=\"line\">\tif(txt.length&gt;20)&#123;\t\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//其实真正的标题就10个字，但是前面有10个空格</span><br><span class=\"line\">\t\t\t                             $(this).text(txt.substring(0,19)+&apos;...&apos;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">//为所有调用的imgShort图片增加CLASS</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">$(&apos;.imgShortParent img&apos;).each(function()&#123;</span><br><span class=\"line\">\t\t\t$(this).addClass(&apos;imgShort&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">//动态设定每个单列容器的宽度 = imgLong的宽度，高度 = imgLong的高度，以此来保证图片不会溢出 box-shadow。</span><br><span class=\"line\">var h = $(&apos;.imgLong&apos;).first().height();</span><br><span class=\"line\">var w = $(&apos;.imgLong&apos;).first().width();</span><br><span class=\"line\"></span><br><span class=\"line\">$(&apos;.col-box&apos;).each(function()&#123;</span><br><span class=\"line\">   $(this).width(w).height(h);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$(window).resize(function()&#123;</span><br><span class=\"line\">//页面缩放时，动态获取宽高，并赋值给 col-box 列容器。</span><br><span class=\"line\">  $(&apos;.col-box&apos;).each(function()&#123;</span><br><span class=\"line\">   $(this).width(w).height(h);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-不足与改进思路\"><a href=\"#3-不足与改进思路\" class=\"headerlink\" title=\"3.不足与改进思路\"></a>3.不足与改进思路</h2><p>3.1 页面性能不足，重绘过多，网速慢的时候，会有一瞬间发生：【图片突然很大，然后被缩放到正常比例】的恐怖现象。。。<br>解决方案：<br>可以为每张小图(250*165)包裹一层div，设置max-height与max-width，overflow:hidden，来解决。</p>\n<p>3.2 实际上，整个项目我写了两套html骨架（由于项目紧，刚接手，长时间没写代码比较陌生），pc一套，mobile一套，感到非常罪过，不配成为一个前端工程师。。。但是话说回来，原先的项目也写的太TM乱了，一个注释都没有，而且一个页面中script标签不下20个。。。<br>解决方案：<br>用我上述的思路去实现</p>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上","date":"2018-01-31T07:28:17.000Z","reward":true,"comment":true,"_content":"\n\n\n\n\n\n\n\n\n\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79212913)\n\n\n这篇博客同步更新于我的GitHub博客：[我的GitHub博客](https://zq-jhon.github.io/2018/01/30/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94%28%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE%29%20%E4%B8%8A/)\n\n面试回顾：[腾讯面试回顾](http://blog.csdn.net/qq_20264891/article/details/79158495)\n\n## 1.js中ajax发送请求的步骤 ##\n    在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下:\n   \n**①创建XMLHttpRequest对象（标准浏览器）：**\n  \n\n```\nif(window.XMLHttpRequest){\n  var xhr = new XMLHttpRequest();\n}\n```\n\n IE7及以下，这个对象为：ActiveXObject：\n \n \n\n```\nif(window.ActiveXObject){\nvar xhr = new ActiveXObject('Microsoft.XMLHTTP')\n}\n```\n\n**② 初始化请求**\n \n \n\n```\nxhr.open('GET','http://www.请求地址.com',是否异步?true:false);\n```\n\n**③发送请求/传递数据**\n\n```\nxhr.send();\n```\n\n请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：\n\n```\n//数据\nxhr.open('GET','http://www.请求地址.com/index.html',true);\n```\n\n如果是POST方法，直接写  `xhr.send('数据')` 中。\n\n**④设置异步回调callback()**\n先给个错误示范：\n```\n//xhr.readyState 本地的请求状态\n//xhr.status 服务器返回的请求状态码\nif(xhr.readystate==4 && xhr.status == 200){\n  do something...\n}\n```\n这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1\n\n这里的异步方式主要通过一个事件来完成：\n\n```\nxhr.onreadystatechange()=function(){\n\nif(xhr.readystate==4 && xhr.status == 200){\n  do something...\n}\n\n}\n```\n如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。\n\n反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。\n\n扩展：既然 readyState==4 && status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~\n参考文章 ，我以前的博客：[Ajax初探](https://zq-jhon.github.io/2017/11/06/Ajax%E5%88%9D%E6%8E%A2/)\n上一次的面试中，xhr.open()初始化  xhr.send()发送请求  xhr.onreadystatechange=function(){}回调函数  这三点都忘记答了，一定要注意。\n## 2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？ ##\n\n事件捕获、事件响应、事件冒泡。\n\n如图：\n\n![事件捕获和冒泡](http://img.blog.csdn.net/20180131093105267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。\n\n一句话概括这种机制：\n\n捕获：自外而内，从根到叶，从大到小 。\n\n冒泡：自内而外，从叶到根，从小到大。\n\n来做个实验，有如下的html结构 和 js代码：\n\n```\n<!--HTML结构-->\n<div id=\"div1\">\n\t\t我是DIV1\n\t\t<div id=\"div2\">\n\t\t\t我是DIV2\n\t\t\t<button id=\"btn\">\n\t\t\t\ti am a button\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\n\n//script代码\n\nvar div1 = document.getElementById('div1');\nvar div2 = document.getElementById('div2');\nvar btn = document.getElementById('btn');\n\nbtn.addEventListener('click', function() {console.log(this.id)},false);\n\n\ndiv2.addEventListener('click', function(){console.log(this.id)},false);\n\ndiv1.addEventListener('click', function(){console.log(this.id)},false);\n\t\n```\nHTML结构如图：\n\n![HTML结构](http://img.blog.csdn.net/20180131094357898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n当点击最里面的button，会依次出现这种情况：\n\n![控制台输出](http://img.blog.csdn.net/20180131094911606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到，事件是在冒泡阶段被触发的。\n\n当改变js API中最后一个Boolean值为true时，又会产生另外一种景观：\n\n![这里写图片描述](http://img.blog.csdn.net/20180131095628141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这次是从外向内依次触发的。\n\n总结：\n1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。\n2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。\n\n## 3.闭包是怎么回事？用在什么场景？ ##\n简而言之：**1、闭包就是可以访问局部作用域的变量。**\n并且：        **2、 可以使局部变量常驻内存**\n参考阮一峰老师的闭包博客： [阮一峰----闭包](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n\n**Q:闭包的内部函数为什么变量不会被销毁？**\nA：\n\n```\nfunction a(){\nvar a =1;\n\nfunction b(){\na+=1;\nreturn a;\n}\nreturn b();\n\n}\n```\n\n因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。\n\n**Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）**\n\nA：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。\n人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；\n\n**Q3.2：如何避免内存泄漏的问题？**\nA：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。\n\n## 4.CALL和Apply是干嘛的？ ##\n二者都是为了更改function 的this指针，举个例子\n\nCALL(新的this对象，原先的参数1，原先的参数2...);\nApply(新的this对象，[原先的参数1，原先的参数2...]);\n\n先传入新的this对象，再传入旧方法的传参。\n\n## 5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？ ##\n1.jsonp跨域\n利用`<script>`标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：\n\n```\n\t\t//在js预先定义好callback()函数  \n\t\t\n\t\tfunction fun(data){\n\t\t\t\n\t\t\t//use data to do somethings.\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t//动态创建script标签，并在url中说明请求地址\n\t\tvar body = document.getElementsByTagName('body')[0];\n\t\t\n\t\tvar script = document.createElement('script');\n\t\t\n\t\tscript.type = 'text/javasctipt';\n\t\t\n\t\tscript.src = 'require.php?callback=fun';\n\t\t\n\t\tbody.appendChild(script);\n\t\t\n\t\t//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。\n\t       //假设传回的值是 fun({\"name\":\"xiaoming\"})，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。\n\t\t\n```\n这样，通过script不受跨域访问的特性，实现了跨域访问。\n\n2.CORS跨域（主流浏览器及IE10+）\n    对于客户端，我们还是正常使用xhr对象发送ajax请求。\n    唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;\n    对于服务器端，需要在 response header中设置如下两个字段:\n    Access-Control-Allow-Origin: http://www.yourhost.com\n    Access-Control-Allow-Credentials:true\n    这样，我们就可以跨域请求接口了。\n\n3.返回的json和jsonp有什么区别？\n返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：\n\n```\ncallback({\"name\":\"HanMeiMei\"})\n```\n    \n\n\n\n\n\n\n\n\n\n\n\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上.md","raw":"---\ntitle:  基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上 \ndate: 2018-01-31 15:28:17\ntags: [腾讯,面试,javascript,浏览器兼容,ajax,原理]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n\n\n\n\n\n\n\n\n\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79212913)\n\n\n这篇博客同步更新于我的GitHub博客：[我的GitHub博客](https://zq-jhon.github.io/2018/01/30/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94%28%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE%29%20%E4%B8%8A/)\n\n面试回顾：[腾讯面试回顾](http://blog.csdn.net/qq_20264891/article/details/79158495)\n\n## 1.js中ajax发送请求的步骤 ##\n    在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下:\n   \n**①创建XMLHttpRequest对象（标准浏览器）：**\n  \n\n```\nif(window.XMLHttpRequest){\n  var xhr = new XMLHttpRequest();\n}\n```\n\n IE7及以下，这个对象为：ActiveXObject：\n \n \n\n```\nif(window.ActiveXObject){\nvar xhr = new ActiveXObject('Microsoft.XMLHTTP')\n}\n```\n\n**② 初始化请求**\n \n \n\n```\nxhr.open('GET','http://www.请求地址.com',是否异步?true:false);\n```\n\n**③发送请求/传递数据**\n\n```\nxhr.send();\n```\n\n请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：\n\n```\n//数据\nxhr.open('GET','http://www.请求地址.com/index.html',true);\n```\n\n如果是POST方法，直接写  `xhr.send('数据')` 中。\n\n**④设置异步回调callback()**\n先给个错误示范：\n```\n//xhr.readyState 本地的请求状态\n//xhr.status 服务器返回的请求状态码\nif(xhr.readystate==4 && xhr.status == 200){\n  do something...\n}\n```\n这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1\n\n这里的异步方式主要通过一个事件来完成：\n\n```\nxhr.onreadystatechange()=function(){\n\nif(xhr.readystate==4 && xhr.status == 200){\n  do something...\n}\n\n}\n```\n如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。\n\n反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。\n\n扩展：既然 readyState==4 && status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~\n参考文章 ，我以前的博客：[Ajax初探](https://zq-jhon.github.io/2017/11/06/Ajax%E5%88%9D%E6%8E%A2/)\n上一次的面试中，xhr.open()初始化  xhr.send()发送请求  xhr.onreadystatechange=function(){}回调函数  这三点都忘记答了，一定要注意。\n## 2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？ ##\n\n事件捕获、事件响应、事件冒泡。\n\n如图：\n\n![事件捕获和冒泡](http://img.blog.csdn.net/20180131093105267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。\n\n一句话概括这种机制：\n\n捕获：自外而内，从根到叶，从大到小 。\n\n冒泡：自内而外，从叶到根，从小到大。\n\n来做个实验，有如下的html结构 和 js代码：\n\n```\n<!--HTML结构-->\n<div id=\"div1\">\n\t\t我是DIV1\n\t\t<div id=\"div2\">\n\t\t\t我是DIV2\n\t\t\t<button id=\"btn\">\n\t\t\t\ti am a button\n\t\t\t</button>\n\t\t</div>\n\t</div>\n\n\n//script代码\n\nvar div1 = document.getElementById('div1');\nvar div2 = document.getElementById('div2');\nvar btn = document.getElementById('btn');\n\nbtn.addEventListener('click', function() {console.log(this.id)},false);\n\n\ndiv2.addEventListener('click', function(){console.log(this.id)},false);\n\ndiv1.addEventListener('click', function(){console.log(this.id)},false);\n\t\n```\nHTML结构如图：\n\n![HTML结构](http://img.blog.csdn.net/20180131094357898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n当点击最里面的button，会依次出现这种情况：\n\n![控制台输出](http://img.blog.csdn.net/20180131094911606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到，事件是在冒泡阶段被触发的。\n\n当改变js API中最后一个Boolean值为true时，又会产生另外一种景观：\n\n![这里写图片描述](http://img.blog.csdn.net/20180131095628141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n这次是从外向内依次触发的。\n\n总结：\n1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。\n2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。\n\n## 3.闭包是怎么回事？用在什么场景？ ##\n简而言之：**1、闭包就是可以访问局部作用域的变量。**\n并且：        **2、 可以使局部变量常驻内存**\n参考阮一峰老师的闭包博客： [阮一峰----闭包](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)\n\n**Q:闭包的内部函数为什么变量不会被销毁？**\nA：\n\n```\nfunction a(){\nvar a =1;\n\nfunction b(){\na+=1;\nreturn a;\n}\nreturn b();\n\n}\n```\n\n因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。\n\n**Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）**\n\nA：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。\n人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；\n\n**Q3.2：如何避免内存泄漏的问题？**\nA：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。\n\n## 4.CALL和Apply是干嘛的？ ##\n二者都是为了更改function 的this指针，举个例子\n\nCALL(新的this对象，原先的参数1，原先的参数2...);\nApply(新的this对象，[原先的参数1，原先的参数2...]);\n\n先传入新的this对象，再传入旧方法的传参。\n\n## 5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？ ##\n1.jsonp跨域\n利用`<script>`标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：\n\n```\n\t\t//在js预先定义好callback()函数  \n\t\t\n\t\tfunction fun(data){\n\t\t\t\n\t\t\t//use data to do somethings.\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t//动态创建script标签，并在url中说明请求地址\n\t\tvar body = document.getElementsByTagName('body')[0];\n\t\t\n\t\tvar script = document.createElement('script');\n\t\t\n\t\tscript.type = 'text/javasctipt';\n\t\t\n\t\tscript.src = 'require.php?callback=fun';\n\t\t\n\t\tbody.appendChild(script);\n\t\t\n\t\t//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。\n\t       //假设传回的值是 fun({\"name\":\"xiaoming\"})，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。\n\t\t\n```\n这样，通过script不受跨域访问的特性，实现了跨域访问。\n\n2.CORS跨域（主流浏览器及IE10+）\n    对于客户端，我们还是正常使用xhr对象发送ajax请求。\n    唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;\n    对于服务器端，需要在 response header中设置如下两个字段:\n    Access-Control-Allow-Origin: http://www.yourhost.com\n    Access-Control-Allow-Credentials:true\n    这样，我们就可以跨域请求接口了。\n\n3.返回的json和jsonp有什么区别？\n返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：\n\n```\ncallback({\"name\":\"HanMeiMei\"})\n```\n    \n\n\n\n\n\n\n\n\n\n\n\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 上","published":1,"updated":"2018-08-29T08:53:44.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdge001kjgv4210u73bg","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79212913\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>这篇博客同步更新于我的GitHub博客：<a href=\"https://zq-jhon.github.io/2018/01/30/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94%28%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE%29%20%E4%B8%8A/\" target=\"_blank\" rel=\"noopener\">我的GitHub博客</a></p>\n<p>面试回顾：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79158495\" target=\"_blank\" rel=\"noopener\">腾讯面试回顾</a></p>\n<h2 id=\"1-js中ajax发送请求的步骤\"><a href=\"#1-js中ajax发送请求的步骤\" class=\"headerlink\" title=\"1.js中ajax发送请求的步骤\"></a>1.js中ajax发送请求的步骤</h2><pre><code>在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下:\n</code></pre><p><strong>①创建XMLHttpRequest对象（标准浏览器）：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(window.XMLHttpRequest)&#123;</span><br><span class=\"line\">  var xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> IE7及以下，这个对象为：ActiveXObject：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(window.ActiveXObject)&#123;</span><br><span class=\"line\">var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>② 初始化请求</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com&apos;,是否异步?true:false);</span><br></pre></td></tr></table></figure>\n<p><strong>③发送请求/传递数据</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure>\n<p>请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据</span><br><span class=\"line\">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com/index.html&apos;,true);</span><br></pre></td></tr></table></figure>\n<p>如果是POST方法，直接写  <code>xhr.send(&#39;数据&#39;)</code> 中。</p>\n<p><strong>④设置异步回调callback()</strong><br>先给个错误示范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//xhr.readyState 本地的请求状态</span><br><span class=\"line\">//xhr.status 服务器返回的请求状态码</span><br><span class=\"line\">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class=\"line\">  do something...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1</p>\n<p>这里的异步方式主要通过一个事件来完成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.onreadystatechange()=function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class=\"line\">  do something...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。</p>\n<p>反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。</p>\n<p>扩展：既然 readyState==4 &amp;&amp; status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~<br>参考文章 ，我以前的博客：<a href=\"https://zq-jhon.github.io/2017/11/06/Ajax%E5%88%9D%E6%8E%A2/\" target=\"_blank\" rel=\"noopener\">Ajax初探</a><br>上一次的面试中，xhr.open()初始化  xhr.send()发送请求  xhr.onreadystatechange=function(){}回调函数  这三点都忘记答了，一定要注意。</p>\n<h2 id=\"2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？\"><a href=\"#2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？\" class=\"headerlink\" title=\"2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？\"></a>2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</h2><p>事件捕获、事件响应、事件冒泡。</p>\n<p>如图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131093105267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件捕获和冒泡\" title=\"\" class=\"\">\n                <p>事件捕获和冒泡</p>\n            </figure>\n<p>不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。</p>\n<p>一句话概括这种机制：</p>\n<p>捕获：自外而内，从根到叶，从大到小 。</p>\n<p>冒泡：自内而外，从叶到根，从小到大。</p>\n<p>来做个实验，有如下的html结构 和 js代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--HTML结构--&gt;</span><br><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;</span><br><span class=\"line\">\t\t我是DIV1</span><br><span class=\"line\">\t\t&lt;div id=&quot;div2&quot;&gt;</span><br><span class=\"line\">\t\t\t我是DIV2</span><br><span class=\"line\">\t\t\t&lt;button id=&quot;btn&quot;&gt;</span><br><span class=\"line\">\t\t\t\ti am a button</span><br><span class=\"line\">\t\t\t&lt;/button&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//script代码</span><br><span class=\"line\"></span><br><span class=\"line\">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class=\"line\">var div2 = document.getElementById(&apos;div2&apos;);</span><br><span class=\"line\">var btn = document.getElementById(&apos;btn&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">btn.addEventListener(&apos;click&apos;, function() &#123;console.log(this.id)&#125;,false);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">div2.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br><span class=\"line\"></span><br><span class=\"line\">div1.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br></pre></td></tr></table></figure>\n<p>HTML结构如图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131094357898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"HTML结构\" title=\"\" class=\"\">\n                <p>HTML结构</p>\n            </figure>\n<p>当点击最里面的button，会依次出现这种情况：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131094911606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"控制台输出\" title=\"\" class=\"\">\n                <p>控制台输出</p>\n            </figure>\n<p>可以看到，事件是在冒泡阶段被触发的。</p>\n<p>当改变js API中最后一个Boolean值为true时，又会产生另外一种景观：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131095628141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>这次是从外向内依次触发的。</p>\n<p>总结：<br>1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。<br>2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。</p>\n<h2 id=\"3-闭包是怎么回事？用在什么场景？\"><a href=\"#3-闭包是怎么回事？用在什么场景？\" class=\"headerlink\" title=\"3.闭包是怎么回事？用在什么场景？\"></a>3.闭包是怎么回事？用在什么场景？</h2><p>简而言之：<strong>1、闭包就是可以访问局部作用域的变量。</strong><br>并且：        <strong>2、 可以使局部变量常驻内存</strong><br>参考阮一峰老师的闭包博客： <a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\" rel=\"noopener\">阮一峰—-闭包</a></p>\n<p><strong>Q:闭包的内部函数为什么变量不会被销毁？</strong><br>A：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a()&#123;</span><br><span class=\"line\">var a =1;</span><br><span class=\"line\"></span><br><span class=\"line\">function b()&#123;</span><br><span class=\"line\">a+=1;</span><br><span class=\"line\">return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return b();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。</p>\n<p><strong>Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）</strong></p>\n<p>A：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。<br>人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；</p>\n<p><strong>Q3.2：如何避免内存泄漏的问题？</strong><br>A：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。</p>\n<h2 id=\"4-CALL和Apply是干嘛的？\"><a href=\"#4-CALL和Apply是干嘛的？\" class=\"headerlink\" title=\"4.CALL和Apply是干嘛的？\"></a>4.CALL和Apply是干嘛的？</h2><p>二者都是为了更改function 的this指针，举个例子</p>\n<p>CALL(新的this对象，原先的参数1，原先的参数2…);<br>Apply(新的this对象，[原先的参数1，原先的参数2…]);</p>\n<p>先传入新的this对象，再传入旧方法的传参。</p>\n<h2 id=\"5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？\"><a href=\"#5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？\" class=\"headerlink\" title=\"5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？\"></a>5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</h2><p>1.jsonp跨域<br>利用<code>&lt;script&gt;</code>标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在js预先定义好callback()函数  </span><br><span class=\"line\"></span><br><span class=\"line\">function fun(data)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//use data to do somethings.</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//动态创建script标签，并在url中说明请求地址</span><br><span class=\"line\">var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class=\"line\"></span><br><span class=\"line\">var script = document.createElement(&apos;script&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">script.type = &apos;text/javasctipt&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">script.src = &apos;require.php?callback=fun&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">body.appendChild(script);</span><br><span class=\"line\"></span><br><span class=\"line\">//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。</span><br><span class=\"line\">      //假设传回的值是 fun(&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。</span><br></pre></td></tr></table></figure>\n<p>这样，通过script不受跨域访问的特性，实现了跨域访问。</p>\n<p>2.CORS跨域（主流浏览器及IE10+）<br>    对于客户端，我们还是正常使用xhr对象发送ajax请求。<br>    唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;<br>    对于服务器端，需要在 response header中设置如下两个字段:<br>    Access-Control-Allow-Origin: <a href=\"http://www.yourhost.com\" target=\"_blank\" rel=\"noopener\">http://www.yourhost.com</a><br>    Access-Control-Allow-Credentials:true<br>    这样，我们就可以跨域请求接口了。</p>\n<p>3.返回的json和jsonp有什么区别？<br>返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback(&#123;&quot;name&quot;:&quot;HanMeiMei&quot;&#125;)</span><br></pre></td></tr></table></figure>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79212913\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<p>这篇博客同步更新于我的GitHub博客：<a href=\"https://zq-jhon.github.io/2018/01/30/%E5%9F%BA%E4%BA%8E%E4%B8%8A%E6%AC%A1%E8%85%BE%E8%AE%AF%E8%BF%9C%E7%A8%8B%E9%9D%A2%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%9E%E7%AD%94%28%E7%B2%BE%E5%BF%83%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE%29%20%E4%B8%8A/\" target=\"_blank\" rel=\"noopener\">我的GitHub博客</a></p>\n<p>面试回顾：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79158495\" target=\"_blank\" rel=\"noopener\">腾讯面试回顾</a></p>\n<h2 id=\"1-js中ajax发送请求的步骤\"><a href=\"#1-js中ajax发送请求的步骤\" class=\"headerlink\" title=\"1.js中ajax发送请求的步骤\"></a>1.js中ajax发送请求的步骤</h2><pre><code>在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put...)。原生的方法步骤如下:\n</code></pre><p><strong>①创建XMLHttpRequest对象（标准浏览器）：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(window.XMLHttpRequest)&#123;</span><br><span class=\"line\">  var xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> IE7及以下，这个对象为：ActiveXObject：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(window.ActiveXObject)&#123;</span><br><span class=\"line\">var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>② 初始化请求</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com&apos;,是否异步?true:false);</span><br></pre></td></tr></table></figure>\n<p><strong>③发送请求/传递数据</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure>\n<p>请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据</span><br><span class=\"line\">xhr.open(&apos;GET&apos;,&apos;http://www.请求地址.com/index.html&apos;,true);</span><br></pre></td></tr></table></figure>\n<p>如果是POST方法，直接写  <code>xhr.send(&#39;数据&#39;)</code> 中。</p>\n<p><strong>④设置异步回调callback()</strong><br>先给个错误示范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//xhr.readyState 本地的请求状态</span><br><span class=\"line\">//xhr.status 服务器返回的请求状态码</span><br><span class=\"line\">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class=\"line\">  do something...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直长等于 1</p>\n<p>这里的异步方式主要通过一个事件来完成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.onreadystatechange()=function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class=\"line\">  do something...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。</p>\n<p>反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。</p>\n<p>扩展：既然 readyState==4 &amp;&amp; status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~<br>参考文章 ，我以前的博客：<a href=\"https://zq-jhon.github.io/2017/11/06/Ajax%E5%88%9D%E6%8E%A2/\" target=\"_blank\" rel=\"noopener\">Ajax初探</a><br>上一次的面试中，xhr.open()初始化  xhr.send()发送请求  xhr.onreadystatechange=function(){}回调函数  这三点都忘记答了，一定要注意。</p>\n<h2 id=\"2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？\"><a href=\"#2-浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？\" class=\"headerlink\" title=\"2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？\"></a>2.浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</h2><p>事件捕获、事件响应、事件冒泡。</p>\n<p>如图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131093105267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"事件捕获和冒泡\" title=\"\" class=\"\">\n                <p>事件捕获和冒泡</p>\n            </figure>\n<p>不管body上绑定事件、或者div甚至div的text节点上绑定事件，这个事件必须先从根节点开始遍历（即Window对象开始），从上往下，传递的过程中，发现有的元素绑定了事件，也先放着，等全部事件捕获完毕（遍历完毕）， 开始处理事件，处理的顺序为，从最小的根节点上的事件开始，依次向上冒泡。</p>\n<p>一句话概括这种机制：</p>\n<p>捕获：自外而内，从根到叶，从大到小 。</p>\n<p>冒泡：自内而外，从叶到根，从小到大。</p>\n<p>来做个实验，有如下的html结构 和 js代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--HTML结构--&gt;</span><br><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;</span><br><span class=\"line\">\t\t我是DIV1</span><br><span class=\"line\">\t\t&lt;div id=&quot;div2&quot;&gt;</span><br><span class=\"line\">\t\t\t我是DIV2</span><br><span class=\"line\">\t\t\t&lt;button id=&quot;btn&quot;&gt;</span><br><span class=\"line\">\t\t\t\ti am a button</span><br><span class=\"line\">\t\t\t&lt;/button&gt;</span><br><span class=\"line\">\t\t&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//script代码</span><br><span class=\"line\"></span><br><span class=\"line\">var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class=\"line\">var div2 = document.getElementById(&apos;div2&apos;);</span><br><span class=\"line\">var btn = document.getElementById(&apos;btn&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">btn.addEventListener(&apos;click&apos;, function() &#123;console.log(this.id)&#125;,false);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">div2.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br><span class=\"line\"></span><br><span class=\"line\">div1.addEventListener(&apos;click&apos;, function()&#123;console.log(this.id)&#125;,false);</span><br></pre></td></tr></table></figure>\n<p>HTML结构如图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131094357898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"HTML结构\" title=\"\" class=\"\">\n                <p>HTML结构</p>\n            </figure>\n<p>当点击最里面的button，会依次出现这种情况：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131094911606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"控制台输出\" title=\"\" class=\"\">\n                <p>控制台输出</p>\n            </figure>\n<p>可以看到，事件是在冒泡阶段被触发的。</p>\n<p>当改变js API中最后一个Boolean值为true时，又会产生另外一种景观：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180131095628141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\" class=\"\">\n                <p>这里写图片描述</p>\n            </figure>\n<p>这次是从外向内依次触发的。</p>\n<p>总结：<br>1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。<br>2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。</p>\n<h2 id=\"3-闭包是怎么回事？用在什么场景？\"><a href=\"#3-闭包是怎么回事？用在什么场景？\" class=\"headerlink\" title=\"3.闭包是怎么回事？用在什么场景？\"></a>3.闭包是怎么回事？用在什么场景？</h2><p>简而言之：<strong>1、闭包就是可以访问局部作用域的变量。</strong><br>并且：        <strong>2、 可以使局部变量常驻内存</strong><br>参考阮一峰老师的闭包博客： <a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\" rel=\"noopener\">阮一峰—-闭包</a></p>\n<p><strong>Q:闭包的内部函数为什么变量不会被销毁？</strong><br>A：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a()&#123;</span><br><span class=\"line\">var a =1;</span><br><span class=\"line\"></span><br><span class=\"line\">function b()&#123;</span><br><span class=\"line\">a+=1;</span><br><span class=\"line\">return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return b();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。</p>\n<p><strong>Q 3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）</strong></p>\n<p>A：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。<br>人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；</p>\n<p><strong>Q3.2：如何避免内存泄漏的问题？</strong><br>A：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。</p>\n<h2 id=\"4-CALL和Apply是干嘛的？\"><a href=\"#4-CALL和Apply是干嘛的？\" class=\"headerlink\" title=\"4.CALL和Apply是干嘛的？\"></a>4.CALL和Apply是干嘛的？</h2><p>二者都是为了更改function 的this指针，举个例子</p>\n<p>CALL(新的this对象，原先的参数1，原先的参数2…);<br>Apply(新的this对象，[原先的参数1，原先的参数2…]);</p>\n<p>先传入新的this对象，再传入旧方法的传参。</p>\n<h2 id=\"5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？\"><a href=\"#5-在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？\" class=\"headerlink\" title=\"5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？\"></a>5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</h2><p>1.jsonp跨域<br>利用<code>&lt;script&gt;</code>标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在js预先定义好callback()函数  </span><br><span class=\"line\"></span><br><span class=\"line\">function fun(data)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//use data to do somethings.</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//动态创建script标签，并在url中说明请求地址</span><br><span class=\"line\">var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class=\"line\"></span><br><span class=\"line\">var script = document.createElement(&apos;script&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">script.type = &apos;text/javasctipt&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">script.src = &apos;require.php?callback=fun&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">body.appendChild(script);</span><br><span class=\"line\"></span><br><span class=\"line\">//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。</span><br><span class=\"line\">      //假设传回的值是 fun(&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。</span><br></pre></td></tr></table></figure>\n<p>这样，通过script不受跨域访问的特性，实现了跨域访问。</p>\n<p>2.CORS跨域（主流浏览器及IE10+）<br>    对于客户端，我们还是正常使用xhr对象发送ajax请求。<br>    唯一需要注意的是，我们需要设置我们的xhr属性withCredentials为true，不然的话，cookie是带不过去的哦，设置： xhr.withCredentials = true;<br>    对于服务器端，需要在 response header中设置如下两个字段:<br>    Access-Control-Allow-Origin: <a href=\"http://www.yourhost.com\" target=\"_blank\" rel=\"noopener\">http://www.yourhost.com</a><br>    Access-Control-Allow-Credentials:true<br>    这样，我们就可以跨域请求接口了。</p>\n<p>3.返回的json和jsonp有什么区别？<br>返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callback(&#123;&quot;name&quot;:&quot;HanMeiMei&quot;&#125;)</span><br></pre></td></tr></table></figure>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下","date":"2018-02-01T07:15:28.000Z","reward":true,"comment":true,"_content":"\n\n\n\n\n\n\n\n\n\n\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客]()\n\n\n\n## 6. 简单说一说盒模型，W3C和IE怪异盒模型。##\n\nW3C标准的盒模型：width ==  content_width(不包括padding+border+margin)\n\nIE怪异盒模型： width  == content_width+padding+border\n\n参考我之前的博客：[http://blog.csdn.net/qq_20264891/article/details/79019724](http://blog.csdn.net/qq_20264891/article/details/79019724)\n\n## 7.简要阐述XSS和CSRF攻击及防范 ##\n\n**7.1 XSS攻击与防范**\n注入攻击。\n简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。\n\n防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。\n\n例如: \n\n```\n<input type=\"text\" value=\"<script>alert(123)</script>\" name=\"input\"></input>\n```\n显然，正常的用户，不会再输入框里面输入形如`<script>alert(123)</script>`的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。\n\n**7.2 CSRF攻击与防范**\n\nCSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。\n\n举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。\n防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。\n参考文章：[https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/](https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/)\n这篇文章写的很好。\n\n## 8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype) ##\n\n在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个`_proto_`对象，构造函数则有一个`prototype`对象，该对象上挂载的是可以继承的方法、属性等等。\n\n8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？\n\n通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。\n## 9.页面性能优化有哪些方式？ ##\na.文件(css,js,img)压缩、合并（雪碧图）\n\nb.减少请求数量\n\nc.减少页面重排/重绘\n\nd.使用懒加载，按需加载\n\ne.CSS3动画有限保持帧率\n\nf.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值\n\ng.减少代码冗余量，精简代码\n\nh.静态资源部署到CDN节点\n\n**9.1 重绘/重排是怎么回事？有什么区别？**\n\n网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。\n\n例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的*重排*。\n\n当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是*重绘*。\n\n重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。\n\n*也就是说，重排一定会引发重绘。*\n\n\n重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。\n\n*也就是说，重绘现象的发生，有可能是以重排作为前提。*\n\n**9.2 请举例说明重绘，什么情况下会重绘？**\n\n重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。\n\n**9.3  你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？**\n是的。\n\ncolor,background等属性会引发重绘。\n\n浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。\n\n\n## 10. 浏览器如何知道一个css文件,js文件需要缓存？ ##\n\n首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。\n\n在[https://www.cnblogs.com/shixiaomiao1122/p/7591556.html](https://www.cnblogs.com/shixiaomiao1122/p/7591556.html)看到一个缓存原理图，侵删，图注的很详细：\n![缓存机制原理图](http://img.blog.csdn.net/20180201144623611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 11.HTTP状态码304,502,503 ##\n304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。\n\n502：服务器作为网关或代理，从上游服务器收到无效响应。\n\n503：服务器停机维护。\n\nhttp状态码：\n1XX：临时响应。并继续等待客户端的请求\n2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容\n3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。\n4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。\n5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。\n\n## 12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？ ##\n\n任何项目只有未发现 bug 和已经发现 bug 两种情况\n\n不存在没有 bug 的情况\n\n即便是测试人员也不可能覆盖 100% 的可能性\n\n但是测试表中的要求必须 100%\n\n 覆盖如果测试通过上线后产生的 bug \n \n\n如果是测试表中未覆盖的则编制测试表的人员背锅\n\n如果是不可抗力福利彩票背锅\n\n作者：王小明\n链接：https://www.zhihu.com/question/65688799/answer/233725228\n\n开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。\n\n如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。\n\n\n\n\n\n\n\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下.md","raw":"---\ntitle:  基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下\ndate:   2018-02-01 15:15:28\ntags: [重绘,冲排,javascript,原理,腾讯面试]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n\n\n\n\n\n\n\n\n\n\n\n\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客]()\n\n\n\n## 6. 简单说一说盒模型，W3C和IE怪异盒模型。##\n\nW3C标准的盒模型：width ==  content_width(不包括padding+border+margin)\n\nIE怪异盒模型： width  == content_width+padding+border\n\n参考我之前的博客：[http://blog.csdn.net/qq_20264891/article/details/79019724](http://blog.csdn.net/qq_20264891/article/details/79019724)\n\n## 7.简要阐述XSS和CSRF攻击及防范 ##\n\n**7.1 XSS攻击与防范**\n注入攻击。\n简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。\n\n防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。\n\n例如: \n\n```\n<input type=\"text\" value=\"<script>alert(123)</script>\" name=\"input\"></input>\n```\n显然，正常的用户，不会再输入框里面输入形如`<script>alert(123)</script>`的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。\n\n**7.2 CSRF攻击与防范**\n\nCSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。\n\n举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。\n防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。\n参考文章：[https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/](https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/)\n这篇文章写的很好。\n\n## 8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype) ##\n\n在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个`_proto_`对象，构造函数则有一个`prototype`对象，该对象上挂载的是可以继承的方法、属性等等。\n\n8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？\n\n通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。\n## 9.页面性能优化有哪些方式？ ##\na.文件(css,js,img)压缩、合并（雪碧图）\n\nb.减少请求数量\n\nc.减少页面重排/重绘\n\nd.使用懒加载，按需加载\n\ne.CSS3动画有限保持帧率\n\nf.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值\n\ng.减少代码冗余量，精简代码\n\nh.静态资源部署到CDN节点\n\n**9.1 重绘/重排是怎么回事？有什么区别？**\n\n网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。\n\n例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的*重排*。\n\n当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是*重绘*。\n\n重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。\n\n*也就是说，重排一定会引发重绘。*\n\n\n重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。\n\n*也就是说，重绘现象的发生，有可能是以重排作为前提。*\n\n**9.2 请举例说明重绘，什么情况下会重绘？**\n\n重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。\n\n**9.3  你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？**\n是的。\n\ncolor,background等属性会引发重绘。\n\n浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。\n\n\n## 10. 浏览器如何知道一个css文件,js文件需要缓存？ ##\n\n首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。\n\n在[https://www.cnblogs.com/shixiaomiao1122/p/7591556.html](https://www.cnblogs.com/shixiaomiao1122/p/7591556.html)看到一个缓存原理图，侵删，图注的很详细：\n![缓存机制原理图](http://img.blog.csdn.net/20180201144623611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 11.HTTP状态码304,502,503 ##\n304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。\n\n502：服务器作为网关或代理，从上游服务器收到无效响应。\n\n503：服务器停机维护。\n\nhttp状态码：\n1XX：临时响应。并继续等待客户端的请求\n2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容\n3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。\n4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。\n5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。\n\n## 12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？ ##\n\n任何项目只有未发现 bug 和已经发现 bug 两种情况\n\n不存在没有 bug 的情况\n\n即便是测试人员也不可能覆盖 100% 的可能性\n\n但是测试表中的要求必须 100%\n\n 覆盖如果测试通过上线后产生的 bug \n \n\n如果是测试表中未覆盖的则编制测试表的人员背锅\n\n如果是不可抗力福利彩票背锅\n\n作者：王小明\n链接：https://www.zhihu.com/question/65688799/answer/233725228\n\n开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。\n\n如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。\n\n\n\n\n\n\n\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"基于上次腾讯远程面试的题目总结与回答(精心总结回顾) 下","published":1,"updated":"2018-08-29T08:53:48.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdgg001mjgv41x465jxv","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"\">我的CSDN博客</a></p>\n<h2 id=\"6-简单说一说盒模型，W3C和IE怪异盒模型。\"><a href=\"#6-简单说一说盒模型，W3C和IE怪异盒模型。\" class=\"headerlink\" title=\"6. 简单说一说盒模型，W3C和IE怪异盒模型。\"></a>6. 简单说一说盒模型，W3C和IE怪异盒模型。</h2><p>W3C标准的盒模型：width ==  content_width(不包括padding+border+margin)</p>\n<p>IE怪异盒模型： width  == content_width+padding+border</p>\n<p>参考我之前的博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79019724\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20264891/article/details/79019724</a></p>\n<h2 id=\"7-简要阐述XSS和CSRF攻击及防范\"><a href=\"#7-简要阐述XSS和CSRF攻击及防范\" class=\"headerlink\" title=\"7.简要阐述XSS和CSRF攻击及防范\"></a>7.简要阐述XSS和CSRF攻击及防范</h2><p><strong>7.1 XSS攻击与防范</strong><br>注入攻击。<br>简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。</p>\n<p>防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。</p>\n<p>例如: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; value=&quot;&lt;script&gt;alert(123)&lt;/script&gt;&quot; name=&quot;input&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure>\n<p>显然，正常的用户，不会再输入框里面输入形如<code>&lt;script&gt;alert(123)&lt;/script&gt;</code>的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。</p>\n<p><strong>7.2 CSRF攻击与防范</strong></p>\n<p>CSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。</p>\n<p>举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。<br>防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。<br>参考文章：<a href=\"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/\" target=\"_blank\" rel=\"noopener\">https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/</a><br>这篇文章写的很好。</p>\n<h2 id=\"8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype\"><a href=\"#8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype\" class=\"headerlink\" title=\"8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)\"></a>8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)</h2><p>在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个<code>_proto_</code>对象，构造函数则有一个<code>prototype</code>对象，该对象上挂载的是可以继承的方法、属性等等。</p>\n<p>8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？</p>\n<p>通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。</p>\n<h2 id=\"9-页面性能优化有哪些方式？\"><a href=\"#9-页面性能优化有哪些方式？\" class=\"headerlink\" title=\"9.页面性能优化有哪些方式？\"></a>9.页面性能优化有哪些方式？</h2><p>a.文件(css,js,img)压缩、合并（雪碧图）</p>\n<p>b.减少请求数量</p>\n<p>c.减少页面重排/重绘</p>\n<p>d.使用懒加载，按需加载</p>\n<p>e.CSS3动画有限保持帧率</p>\n<p>f.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值</p>\n<p>g.减少代码冗余量，精简代码</p>\n<p>h.静态资源部署到CDN节点</p>\n<p><strong>9.1 重绘/重排是怎么回事？有什么区别？</strong></p>\n<p>网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。</p>\n<p>例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的<em>重排</em>。</p>\n<p>当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是<em>重绘</em>。</p>\n<p>重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。</p>\n<p><em>也就是说，重排一定会引发重绘。</em></p>\n<p>重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。</p>\n<p><em>也就是说，重绘现象的发生，有可能是以重排作为前提。</em></p>\n<p><strong>9.2 请举例说明重绘，什么情况下会重绘？</strong></p>\n<p>重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。</p>\n<p><strong>9.3  你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？</strong><br>是的。</p>\n<p>color,background等属性会引发重绘。</p>\n<p>浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。</p>\n<h2 id=\"10-浏览器如何知道一个css文件-js文件需要缓存？\"><a href=\"#10-浏览器如何知道一个css文件-js文件需要缓存？\" class=\"headerlink\" title=\"10. 浏览器如何知道一个css文件,js文件需要缓存？\"></a>10. 浏览器如何知道一个css文件,js文件需要缓存？</h2><p>首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。</p>\n<p>在<a href=\"https://www.cnblogs.com/shixiaomiao1122/p/7591556.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/shixiaomiao1122/p/7591556.html</a>看到一个缓存原理图，侵删，图注的很详细：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180201144623611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"缓存机制原理图\" title=\"\" class=\"\">\n                <p>缓存机制原理图</p>\n            </figure></p>\n<h2 id=\"11-HTTP状态码304-502-503\"><a href=\"#11-HTTP状态码304-502-503\" class=\"headerlink\" title=\"11.HTTP状态码304,502,503\"></a>11.HTTP状态码304,502,503</h2><p>304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。</p>\n<p>502：服务器作为网关或代理，从上游服务器收到无效响应。</p>\n<p>503：服务器停机维护。</p>\n<p>http状态码：<br>1XX：临时响应。并继续等待客户端的请求<br>2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容<br>3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。<br>4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。<br>5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。</p>\n<h2 id=\"12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？\"><a href=\"#12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？\" class=\"headerlink\" title=\"12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？\"></a>12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？</h2><p>任何项目只有未发现 bug 和已经发现 bug 两种情况</p>\n<p>不存在没有 bug 的情况</p>\n<p>即便是测试人员也不可能覆盖 100% 的可能性</p>\n<p>但是测试表中的要求必须 100%</p>\n<p> 覆盖如果测试通过上线后产生的 bug </p>\n<p>如果是测试表中未覆盖的则编制测试表的人员背锅</p>\n<p>如果是不可抗力福利彩票背锅</p>\n<p>作者：王小明<br>链接：<a href=\"https://www.zhihu.com/question/65688799/answer/233725228\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/65688799/answer/233725228</a></p>\n<p>开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。</p>\n<p>如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。</p>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"\">我的CSDN博客</a></p>\n<h2 id=\"6-简单说一说盒模型，W3C和IE怪异盒模型。\"><a href=\"#6-简单说一说盒模型，W3C和IE怪异盒模型。\" class=\"headerlink\" title=\"6. 简单说一说盒模型，W3C和IE怪异盒模型。\"></a>6. 简单说一说盒模型，W3C和IE怪异盒模型。</h2><p>W3C标准的盒模型：width ==  content_width(不包括padding+border+margin)</p>\n<p>IE怪异盒模型： width  == content_width+padding+border</p>\n<p>参考我之前的博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79019724\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq_20264891/article/details/79019724</a></p>\n<h2 id=\"7-简要阐述XSS和CSRF攻击及防范\"><a href=\"#7-简要阐述XSS和CSRF攻击及防范\" class=\"headerlink\" title=\"7.简要阐述XSS和CSRF攻击及防范\"></a>7.简要阐述XSS和CSRF攻击及防范</h2><p><strong>7.1 XSS攻击与防范</strong><br>注入攻击。<br>简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。</p>\n<p>防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。</p>\n<p>例如: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; value=&quot;&lt;script&gt;alert(123)&lt;/script&gt;&quot; name=&quot;input&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure>\n<p>显然，正常的用户，不会再输入框里面输入形如<code>&lt;script&gt;alert(123)&lt;/script&gt;</code>的字符串。那么前端在js层上，可以对获取到的表单值进行正则判断，或者转义，来甄别这个输入究竟是不是合法/正常的输入。</p>\n<p><strong>7.2 CSRF攻击与防范</strong></p>\n<p>CSRF就是在用户不知情的情况下，借助用户的信息，来发起伪造请求。</p>\n<p>举例：用户访问A网站，登录以后并没有关闭网页或者清空缓存信息。此时被诱导点击B网站，B网站发起恶意请求，此时A网站服务端无法甄别该请求是否是用户的本意，因为用户在A网站已经登录，有cookies，所以相当于B网站借助用户，来在A网站为所欲为。<br>防范的主要措施在于后端，后端需要严格的来甄别该请求是否用户自己的本意，常见的方法措施有：验证请求头的Refer字段，加Token验证等。<br>参考文章：<a href=\"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/\" target=\"_blank\" rel=\"noopener\">https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/</a><br>这篇文章写的很好。</p>\n<h2 id=\"8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype\"><a href=\"#8-强类型语言有继承，在JS里面如何做到继承呢？-proto和prototype\" class=\"headerlink\" title=\"8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)\"></a>8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)</h2><p>在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个<code>_proto_</code>对象，构造函数则有一个<code>prototype</code>对象，该对象上挂载的是可以继承的方法、属性等等。</p>\n<p>8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？</p>\n<p>通过实例化对象来继承，只能继承prototype上的方法，而内部的test()方法无权访问。</p>\n<h2 id=\"9-页面性能优化有哪些方式？\"><a href=\"#9-页面性能优化有哪些方式？\" class=\"headerlink\" title=\"9.页面性能优化有哪些方式？\"></a>9.页面性能优化有哪些方式？</h2><p>a.文件(css,js,img)压缩、合并（雪碧图）</p>\n<p>b.减少请求数量</p>\n<p>c.减少页面重排/重绘</p>\n<p>d.使用懒加载，按需加载</p>\n<p>e.CSS3动画有限保持帧率</p>\n<p>f.减少dom的访问次数，将经常的访问的节点/属性，进行定义并赋值</p>\n<p>g.减少代码冗余量，精简代码</p>\n<p>h.静态资源部署到CDN节点</p>\n<p><strong>9.1 重绘/重排是怎么回事？有什么区别？</strong></p>\n<p>网页加载的时候，会根据DOM节点构造出一颗DOM节点树，同时根据CSS树来渲染出CSS树，最后合并DOM树和CSS树 ，变成Render树，Render树将有所有的元素属性进行渲染、排布，包括使用相对单位的em/vh都通通转化成px，将隐藏的元素踢出树中等。</p>\n<p>例如：当使用js动态添加div标签，那么整个dom树的构造就会发生变化，因此会引起浏览器的<em>重排</em>。</p>\n<p>当某个DOM节点，甚至几个、几十个DOM节点的样式外观、属性发生变化，浏览器不得不把这些变化的属性重新进行渲染，在用户的浏览器view层得到体现，这就是<em>重绘</em>。</p>\n<p>重排是对dom节点的排布，预先为每个dom节点留好坑，一旦有dom节点增删、位置变动、宽高增改的情况出现，就会进行重新排布。排布是发生在整个DOM树的，一旦DOM树改变，CSS渲染树的子节点/孙子节点也要重新变化，因而会重新绘制。</p>\n<p><em>也就是说，重排一定会引发重绘。</em></p>\n<p>重绘的过程，实际上是先有确定可见的DOM树，根据DOM树，构造出一颗节点/结构相同的CSS树，来对前者进行绘制。一旦DOM树结构变化，CSS树也要跟着变化，那么就会引起浏览器的重新绘制。如果DOM树没有发生结构变化，而仅仅是给其中的某个div加了1px height，然后把border:1px solid black，改成1px solid red，虽然没有进行重排，但是这过程进行了重绘。</p>\n<p><em>也就是说，重绘现象的发生，有可能是以重排作为前提。</em></p>\n<p><strong>9.2 请举例说明重绘，什么情况下会重绘？</strong></p>\n<p>重排会引发重绘。样式属性（例如，颜色，字体大小，背景色）改变会引发重绘。</p>\n<p><strong>9.3  你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？</strong><br>是的。</p>\n<p>color,background等属性会引发重绘。</p>\n<p>浏览器窗口变化，DOM树结构变化(包括文本节点变化)引发重排。</p>\n<h2 id=\"10-浏览器如何知道一个css文件-js文件需要缓存？\"><a href=\"#10-浏览器如何知道一个css文件-js文件需要缓存？\" class=\"headerlink\" title=\"10. 浏览器如何知道一个css文件,js文件需要缓存？\"></a>10. 浏览器如何知道一个css文件,js文件需要缓存？</h2><p>首先浏览器访问某个站点，会检查本地是否有缓存，如果有缓存，查看缓存是否新鲜，如果不新鲜，就去询问服务器，我这个缓存协议时间到了，可能不新鲜，你那边更新了吗？如果服务器缓存也没有更新，那么仍然使用本地缓存。这时服务器会返回304，意思是我这里也没更新，你就用以前的缓存吧。</p>\n<p>在<a href=\"https://www.cnblogs.com/shixiaomiao1122/p/7591556.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/shixiaomiao1122/p/7591556.html</a>看到一个缓存原理图，侵删，图注的很详细：<br><figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180201144623611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"缓存机制原理图\" title=\"\" class=\"\">\n                <p>缓存机制原理图</p>\n            </figure></p>\n<h2 id=\"11-HTTP状态码304-502-503\"><a href=\"#11-HTTP状态码304-502-503\" class=\"headerlink\" title=\"11.HTTP状态码304,502,503\"></a>11.HTTP状态码304,502,503</h2><p>304：缓存并未更新，让浏览器继续使用缓存好的静态文件，无需向服务器请求该静态资源。</p>\n<p>502：服务器作为网关或代理，从上游服务器收到无效响应。</p>\n<p>503：服务器停机维护。</p>\n<p>http状态码：<br>1XX：临时响应。并继续等待客户端的请求<br>2XX：成功。201已创建，202已接受，203未授权信息，204无返回内容，205重置内容<br>3XX：重定向。300 多种选择，301 资源永久移动 ，302 资源临时移动，303 自动转到其他位置，304 未修改。<br>4XX：请求错误。401 未授权，404 未找到 ，403 禁止请求，406 不接受，408 超时。<br>5XX：服务器错误。500内部错误，501 尚未实施，502 错误网关，503 请求不可用。</p>\n<h2 id=\"12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？\"><a href=\"#12-Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？\" class=\"headerlink\" title=\"12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？\"></a>12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？</h2><p>任何项目只有未发现 bug 和已经发现 bug 两种情况</p>\n<p>不存在没有 bug 的情况</p>\n<p>即便是测试人员也不可能覆盖 100% 的可能性</p>\n<p>但是测试表中的要求必须 100%</p>\n<p> 覆盖如果测试通过上线后产生的 bug </p>\n<p>如果是测试表中未覆盖的则编制测试表的人员背锅</p>\n<p>如果是不可抗力福利彩票背锅</p>\n<p>作者：王小明<br>链接：<a href=\"https://www.zhihu.com/question/65688799/answer/233725228\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/65688799/answer/233725228</a></p>\n<p>开个玩笑，根据我自己发布响应式页面的时候，首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。</p>\n<p>如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。如果BUG真的很逆天，那么可以考虑去填写离职手续。</p>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>\n\n\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"用原生js制作一个动态简历(多动症简历)及在线预览部署过程","date":"2018-01-29T09:18:00.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79197651)\n\n\n\n本项目Fork地址(欢迎Star)：\n--\n[https://github.com/ZQ-jhon/resume](https://github.com/ZQ-jhon/resume)\n\n\n本项目预览地址(Preview Address)\n--\nPreview :  [多动症简历](https://zq-jhon.github.io/resume/)\n\n项目起因\n--\n因为在网上看到一个大神做的动态简历，如连接所示：\n\n[http://strml.net/](http://strml.net/)\n\n炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。\n\n引用的第三方库\n--\n1.jQuery  实际用到的地方只有1%\n\n2.prism   代码高亮库。用到30%\n\n3.marked.js markdown语法转html的库，实际用到20%\n\n技术概要\n--\n通篇中使用的技术难度并不大，主要有：\n\n\n - **核心原理：**同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。\n \n - 字符串提取、拼接。\n \n - setInterval定时器控制整个代码的吞吐节奏/速率。\n \n - 在setInterval中设定一些if，用来控制总字符串的吞吐位置。\n \n 避坑指南\n--\n**1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释/**/，要对/进行转义，如下`\\/*这里填写你的内容*\\/。**\n\n**2.字符串的命名一定要切实合理： 如图所示：**\n\n![字符串的命名](http://img.blog.csdn.net/20180129213013960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n>123&&n<321)这种方法来进行区域渲染。prism的渲染代码如下：**\n\n```\n\n官方js库地址：[http://prismjs.com/](http://prismjs.com/)\n\n语法:prism.heihlight(渲染的字符串,渲染的代码格式)\n\nPrism.highlight(str.substring(0,n), Prism.languages.css);\n\n```\n\n\n**4.MarkDown ⇒ HTML渲染 ：  同样根据n的值，来使用if()来进行循环。**\n\nmarked.js官方库地址：[https://www.npmjs.com/package/marked](https://www.npmjs.com/package/marked)\n\n渲染代码如下:\n\n`drawBoard.innerHTML =marked(str.substring(929,1885));`\n\n**5.动态创建Pre标签（id=\"drawBoard\"）  ：  CSS代码版是一开始写在HTML的，但是之后的简历板子（id=\"drawBoard\"，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：**\n\n![动态创建drawBoard](http://img.blog.csdn.net/20180129214532614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**6.已经创建的元素无法在另外的循环中获取 ：**\n **在刚才的【5】中，动态创建的pre标签(id=\"drawBoard\")会在if()的区域内无法document.getElementById('drawBoard')，此时需要在if里面再次获取并且赋值，如图所示：**\n\n\n![再次赋值](http://img.blog.csdn.net/20180129214929626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n**7.动态下拉   同样通过n的值来让元素的溢出自动下拉**\n\n如图：\n\n![动态下拉](http://img.blog.csdn.net/20180129215552841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**8. 动态简历最后的魔术环节  ：   还是通过n的值来进行判断，从而渲染 **\n\n其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。\n\n\n代码如图：\n\n\n![魔术效果实现](http://img.blog.csdn.net/20180129215916887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n核心原理代码\n--\n\n```\n//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义\n\nvar styleTag = document.getElementById('styleTag');\n\nvar sourceBoard = document.getElementById('sourceBoard');\n\nvar str = '\\/*大家好...今天我给大家做一个在线简历...\\/*';\n\n\nvar n = 0;\nwindow.setInterval(function(){\n   n++;\n   styleTag.innerHTML = str.substring(0,n);\n    \n   sourceBoard.innerHTML = str.substring(0,n);\n\n\n},100);\n\n//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。\n```\n Demo部署到GitHub详细过程\n--\n本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：\n\n![gh-pages预览项目](http://img.blog.csdn.net/20180129220933667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。\n\n整个部署的环节大致如下：\n\n 1. 在本地的项目根目录下，`$ git init`\n\n 2. 加入当前所有文件到暂存区 `$ git add .`(后面有个“·”，代表全部文件)\n\n 3. 连接远程仓库  `$ git remote add origin \"your repository address\"`\n\n 4. 提交所有文件到git版本控制系统 `$ git commit -m \"create Demo resume\"`\n\n 5. push到你的远程仓库 `$ git push origin master`\n\n 6. 打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。\n \n PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub\n\n 反思与不足\n--\n\n\n 1. 在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。\n\n\n 2. 我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。\n\n 我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：[http://strml.net/](http://strml.net/)的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。\n 3. 整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。\n \n \n 4. 整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","source":"_posts/用原生js制作一个动态简历(多动症简历)及在线预览部署过程.md","raw":"---\ntitle:  用原生js制作一个动态简历(多动症简历)及在线预览部署过程 \ndate: 2018-01-29 17:18:00\ntags: [动态简历,Github部署]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](http://blog.csdn.net/qq_20264891/article/details/79197651)\n\n\n\n本项目Fork地址(欢迎Star)：\n--\n[https://github.com/ZQ-jhon/resume](https://github.com/ZQ-jhon/resume)\n\n\n本项目预览地址(Preview Address)\n--\nPreview :  [多动症简历](https://zq-jhon.github.io/resume/)\n\n项目起因\n--\n因为在网上看到一个大神做的动态简历，如连接所示：\n\n[http://strml.net/](http://strml.net/)\n\n炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。\n\n引用的第三方库\n--\n1.jQuery  实际用到的地方只有1%\n\n2.prism   代码高亮库。用到30%\n\n3.marked.js markdown语法转html的库，实际用到20%\n\n技术概要\n--\n通篇中使用的技术难度并不大，主要有：\n\n\n - **核心原理：**同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。\n \n - 字符串提取、拼接。\n \n - setInterval定时器控制整个代码的吞吐节奏/速率。\n \n - 在setInterval中设定一些if，用来控制总字符串的吞吐位置。\n \n 避坑指南\n--\n**1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释/**/，要对/进行转义，如下`\\/*这里填写你的内容*\\/。**\n\n**2.字符串的命名一定要切实合理： 如图所示：**\n\n![字符串的命名](http://img.blog.csdn.net/20180129213013960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n>123&&n<321)这种方法来进行区域渲染。prism的渲染代码如下：**\n\n```\n\n官方js库地址：[http://prismjs.com/](http://prismjs.com/)\n\n语法:prism.heihlight(渲染的字符串,渲染的代码格式)\n\nPrism.highlight(str.substring(0,n), Prism.languages.css);\n\n```\n\n\n**4.MarkDown ⇒ HTML渲染 ：  同样根据n的值，来使用if()来进行循环。**\n\nmarked.js官方库地址：[https://www.npmjs.com/package/marked](https://www.npmjs.com/package/marked)\n\n渲染代码如下:\n\n`drawBoard.innerHTML =marked(str.substring(929,1885));`\n\n**5.动态创建Pre标签（id=\"drawBoard\"）  ：  CSS代码版是一开始写在HTML的，但是之后的简历板子（id=\"drawBoard\"，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：**\n\n![动态创建drawBoard](http://img.blog.csdn.net/20180129214532614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**6.已经创建的元素无法在另外的循环中获取 ：**\n **在刚才的【5】中，动态创建的pre标签(id=\"drawBoard\")会在if()的区域内无法document.getElementById('drawBoard')，此时需要在if里面再次获取并且赋值，如图所示：**\n\n\n![再次赋值](http://img.blog.csdn.net/20180129214929626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n**7.动态下拉   同样通过n的值来让元素的溢出自动下拉**\n\n如图：\n\n![动态下拉](http://img.blog.csdn.net/20180129215552841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**8. 动态简历最后的魔术环节  ：   还是通过n的值来进行判断，从而渲染 **\n\n其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。\n\n\n代码如图：\n\n\n![魔术效果实现](http://img.blog.csdn.net/20180129215916887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n核心原理代码\n--\n\n```\n//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义\n\nvar styleTag = document.getElementById('styleTag');\n\nvar sourceBoard = document.getElementById('sourceBoard');\n\nvar str = '\\/*大家好...今天我给大家做一个在线简历...\\/*';\n\n\nvar n = 0;\nwindow.setInterval(function(){\n   n++;\n   styleTag.innerHTML = str.substring(0,n);\n    \n   sourceBoard.innerHTML = str.substring(0,n);\n\n\n},100);\n\n//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。\n```\n Demo部署到GitHub详细过程\n--\n本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：\n\n![gh-pages预览项目](http://img.blog.csdn.net/20180129220933667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。\n\n整个部署的环节大致如下：\n\n 1. 在本地的项目根目录下，`$ git init`\n\n 2. 加入当前所有文件到暂存区 `$ git add .`(后面有个“·”，代表全部文件)\n\n 3. 连接远程仓库  `$ git remote add origin \"your repository address\"`\n\n 4. 提交所有文件到git版本控制系统 `$ git commit -m \"create Demo resume\"`\n\n 5. push到你的远程仓库 `$ git push origin master`\n\n 6. 打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。\n \n PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub\n\n 反思与不足\n--\n\n\n 1. 在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。\n\n\n 2. 我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。\n\n 我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：[http://strml.net/](http://strml.net/)的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。\n 3. 整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。\n \n \n 4. 整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。\n\n\n\n\n\n\n\n\n\n<b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b>","slug":"用原生js制作一个动态简历(多动症简历)及在线预览部署过程","published":1,"updated":"2018-08-29T06:02:27.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdgi001njgv4l6jo2b6o","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79197651\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"本项目Fork地址-欢迎Star-：\"><a href=\"#本项目Fork地址-欢迎Star-：\" class=\"headerlink\" title=\"本项目Fork地址(欢迎Star)：\"></a>本项目Fork地址(欢迎Star)：</h2><p><a href=\"https://github.com/ZQ-jhon/resume\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/resume</a></p>\n<h2 id=\"本项目预览地址-Preview-Address\"><a href=\"#本项目预览地址-Preview-Address\" class=\"headerlink\" title=\"本项目预览地址(Preview Address)\"></a>本项目预览地址(Preview Address)</h2><p>Preview :  <a href=\"https://zq-jhon.github.io/resume/\" target=\"_blank\" rel=\"noopener\">多动症简历</a></p>\n<h2 id=\"项目起因\"><a href=\"#项目起因\" class=\"headerlink\" title=\"项目起因\"></a>项目起因</h2><p>因为在网上看到一个大神做的动态简历，如连接所示：</p>\n<p><a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a></p>\n<p>炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。</p>\n<h2 id=\"引用的第三方库\"><a href=\"#引用的第三方库\" class=\"headerlink\" title=\"引用的第三方库\"></a>引用的第三方库</h2><p>1.jQuery  实际用到的地方只有1%</p>\n<p>2.prism   代码高亮库。用到30%</p>\n<p>3.marked.js markdown语法转html的库，实际用到20%</p>\n<h2 id=\"技术概要\"><a href=\"#技术概要\" class=\"headerlink\" title=\"技术概要\"></a>技术概要</h2><p>通篇中使用的技术难度并不大，主要有：</p>\n<ul>\n<li><p><strong>核心原理：</strong>同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。</p>\n</li>\n<li><p>字符串提取、拼接。</p>\n</li>\n<li><p>setInterval定时器控制整个代码的吞吐节奏/速率。</p>\n</li>\n<li><p>在setInterval中设定一些if，用来控制总字符串的吞吐位置。</p>\n<h2 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a>避坑指南</h2><p><strong>1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释/</strong>/，要对/进行转义，如下`\\/<em>这里填写你的内容</em>\\/。**</p>\n</li>\n</ul>\n<p><strong>2.字符串的命名一定要切实合理： 如图所示：</strong></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129213013960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"字符串的命名\" title=\"\" class=\"\">\n                <p>字符串的命名</p>\n            </figure>\n<p><strong>3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n&gt;123&amp;&amp;n&lt;321)这种方法来进行区域渲染。prism的渲染代码如下：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">官方js库地址：[http://prismjs.com/](http://prismjs.com/)</span><br><span class=\"line\"></span><br><span class=\"line\">语法:prism.heihlight(渲染的字符串,渲染的代码格式)</span><br><span class=\"line\"></span><br><span class=\"line\">Prism.highlight(str.substring(0,n), Prism.languages.css);</span><br></pre></td></tr></table></figure>\n<p><strong>4.MarkDown ⇒ HTML渲染 ：  同样根据n的值，来使用if()来进行循环。</strong></p>\n<p>marked.js官方库地址：<a href=\"https://www.npmjs.com/package/marked\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/marked</a></p>\n<p>渲染代码如下:</p>\n<p><code>drawBoard.innerHTML =marked(str.substring(929,1885));</code></p>\n<p><strong>5.动态创建Pre标签（id=”drawBoard”）  ：  CSS代码版是一开始写在HTML的，但是之后的简历板子（id=”drawBoard”，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：</strong></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129214532614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"动态创建drawBoard\" title=\"\" class=\"\">\n                <p>动态创建drawBoard</p>\n            </figure>\n<p><strong>6.已经创建的元素无法在另外的循环中获取 ：</strong><br> <strong>在刚才的【5】中，动态创建的pre标签(id=”drawBoard”)会在if()的区域内无法document.getElementById(‘drawBoard’)，此时需要在if里面再次获取并且赋值，如图所示：</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20180129214929626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"再次赋值\"></p>\n<p><strong>7.动态下拉   同样通过n的值来让元素的溢出自动下拉</strong></p>\n<p>如图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129215552841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"动态下拉\" title=\"\" class=\"\">\n                <p>动态下拉</p>\n            </figure>\n<p><strong>8. 动态简历最后的魔术环节  ：   还是通过n的值来进行判断，从而渲染 </strong></p>\n<p>其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。</p>\n<p>代码如图：</p>\n<p><img src=\"http://img.blog.csdn.net/20180129215916887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"魔术效果实现\"></p>\n<h2 id=\"核心原理代码\"><a href=\"#核心原理代码\" class=\"headerlink\" title=\"核心原理代码\"></a>核心原理代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义</span><br><span class=\"line\"></span><br><span class=\"line\">var styleTag = document.getElementById(&apos;styleTag&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var sourceBoard = document.getElementById(&apos;sourceBoard&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &apos;\\/*大家好...今天我给大家做一个在线简历...\\/*&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var n = 0;</span><br><span class=\"line\">window.setInterval(function()&#123;</span><br><span class=\"line\">   n++;</span><br><span class=\"line\">   styleTag.innerHTML = str.substring(0,n);</span><br><span class=\"line\">    </span><br><span class=\"line\">   sourceBoard.innerHTML = str.substring(0,n);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,100);</span><br><span class=\"line\"></span><br><span class=\"line\">//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。</span><br></pre></td></tr></table></figure>\n<h2 id=\"Demo部署到GitHub详细过程\"><a href=\"#Demo部署到GitHub详细过程\" class=\"headerlink\" title=\" Demo部署到GitHub详细过程\"></a> Demo部署到GitHub详细过程</h2><p>本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129220933667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"gh-pages预览项目\" title=\"\" class=\"\">\n                <p>gh-pages预览项目</p>\n            </figure>\n<p>在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。</p>\n<p>整个部署的环节大致如下：</p>\n<ol>\n<li><p>在本地的项目根目录下，<code>$ git init</code></p>\n</li>\n<li><p>加入当前所有文件到暂存区 <code>$ git add .</code>(后面有个“·”，代表全部文件)</p>\n</li>\n<li><p>连接远程仓库  <code>$ git remote add origin &quot;your repository address&quot;</code></p>\n</li>\n<li><p>提交所有文件到git版本控制系统 <code>$ git commit -m &quot;create Demo resume&quot;</code></p>\n</li>\n<li><p>push到你的远程仓库 <code>$ git push origin master</code></p>\n</li>\n<li><p>打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。</p>\n<p>PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub</p>\n<h2 id=\"反思与不足\"><a href=\"#反思与不足\" class=\"headerlink\" title=\"反思与不足\"></a>反思与不足</h2></li>\n</ol>\n<ol>\n<li>在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。</li>\n</ol>\n<ol start=\"2\">\n<li><p>我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。</p>\n<p>我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：<a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a>的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。</p>\n</li>\n<li>整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。</li>\n</ol>\n<ol start=\"4\">\n<li>整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。</li>\n</ol>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"http://blog.csdn.net/qq_20264891/article/details/79197651\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"本项目Fork地址-欢迎Star-：\"><a href=\"#本项目Fork地址-欢迎Star-：\" class=\"headerlink\" title=\"本项目Fork地址(欢迎Star)：\"></a>本项目Fork地址(欢迎Star)：</h2><p><a href=\"https://github.com/ZQ-jhon/resume\" target=\"_blank\" rel=\"noopener\">https://github.com/ZQ-jhon/resume</a></p>\n<h2 id=\"本项目预览地址-Preview-Address\"><a href=\"#本项目预览地址-Preview-Address\" class=\"headerlink\" title=\"本项目预览地址(Preview Address)\"></a>本项目预览地址(Preview Address)</h2><p>Preview :  <a href=\"https://zq-jhon.github.io/resume/\" target=\"_blank\" rel=\"noopener\">多动症简历</a></p>\n<h2 id=\"项目起因\"><a href=\"#项目起因\" class=\"headerlink\" title=\"项目起因\"></a>项目起因</h2><p>因为在网上看到一个大神做的动态简历，如连接所示：</p>\n<p><a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a></p>\n<p>炫不炫？酷不酷？其实这个项目其实很简单，整个代码中，js的API超不过10个。</p>\n<h2 id=\"引用的第三方库\"><a href=\"#引用的第三方库\" class=\"headerlink\" title=\"引用的第三方库\"></a>引用的第三方库</h2><p>1.jQuery  实际用到的地方只有1%</p>\n<p>2.prism   代码高亮库。用到30%</p>\n<p>3.marked.js markdown语法转html的库，实际用到20%</p>\n<h2 id=\"技术概要\"><a href=\"#技术概要\" class=\"headerlink\" title=\"技术概要\"></a>技术概要</h2><p>通篇中使用的技术难度并不大，主要有：</p>\n<ul>\n<li><p><strong>核心原理：</strong>同时向一个style标签和pre标签吐代码，pre中显示源码，而style中直接可以变成样式。</p>\n</li>\n<li><p>字符串提取、拼接。</p>\n</li>\n<li><p>setInterval定时器控制整个代码的吞吐节奏/速率。</p>\n</li>\n<li><p>在setInterval中设定一些if，用来控制总字符串的吞吐位置。</p>\n<h2 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a>避坑指南</h2><p><strong>1.注意字符串拼接 ： 要注意字符串拼接的时候，往styleTag里面吐的代码，一旦包含注释/</strong>/，要对/进行转义，如下`\\/<em>这里填写你的内容</em>\\/。**</p>\n</li>\n</ul>\n<p><strong>2.字符串的命名一定要切实合理： 如图所示：</strong></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129213013960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"字符串的命名\" title=\"\" class=\"\">\n                <p>字符串的命名</p>\n            </figure>\n<p><strong>3.代码高亮渲染 ： 中途加入代码高亮渲染的时候，通过判定字符串循环的 n ++ 达到多少，从而用if(n&gt;123&amp;&amp;n&lt;321)这种方法来进行区域渲染。prism的渲染代码如下：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">官方js库地址：[http://prismjs.com/](http://prismjs.com/)</span><br><span class=\"line\"></span><br><span class=\"line\">语法:prism.heihlight(渲染的字符串,渲染的代码格式)</span><br><span class=\"line\"></span><br><span class=\"line\">Prism.highlight(str.substring(0,n), Prism.languages.css);</span><br></pre></td></tr></table></figure>\n<p><strong>4.MarkDown ⇒ HTML渲染 ：  同样根据n的值，来使用if()来进行循环。</strong></p>\n<p>marked.js官方库地址：<a href=\"https://www.npmjs.com/package/marked\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/marked</a></p>\n<p>渲染代码如下:</p>\n<p><code>drawBoard.innerHTML =marked(str.substring(929,1885));</code></p>\n<p><strong>5.动态创建Pre标签（id=”drawBoard”）  ：  CSS代码版是一开始写在HTML的，但是之后的简历板子（id=”drawBoard”，本质上是个pre标签）是通过判断n的值，来动态创建的，如图所示：</strong></p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129214532614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"动态创建drawBoard\" title=\"\" class=\"\">\n                <p>动态创建drawBoard</p>\n            </figure>\n<p><strong>6.已经创建的元素无法在另外的循环中获取 ：</strong><br> <strong>在刚才的【5】中，动态创建的pre标签(id=”drawBoard”)会在if()的区域内无法document.getElementById(‘drawBoard’)，此时需要在if里面再次获取并且赋值，如图所示：</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20180129214929626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"再次赋值\"></p>\n<p><strong>7.动态下拉   同样通过n的值来让元素的溢出自动下拉</strong></p>\n<p>如图：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129215552841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"动态下拉\" title=\"\" class=\"\">\n                <p>动态下拉</p>\n            </figure>\n<p><strong>8. 动态简历最后的魔术环节  ：   还是通过n的值来进行判断，从而渲染 </strong></p>\n<p>其实这个环节就是故弄玄虚，通过判断CSS代码板 的 最后结尾字符串的n值，来进行渲染。</p>\n<p>代码如图：</p>\n<p><img src=\"http://img.blog.csdn.net/20180129215916887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"魔术效果实现\"></p>\n<h2 id=\"核心原理代码\"><a href=\"#核心原理代码\" class=\"headerlink\" title=\"核心原理代码\"></a>核心原理代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注意事项，往style标签里面吐字符串时，要注意对/**/注释标签进行转义</span><br><span class=\"line\"></span><br><span class=\"line\">var styleTag = document.getElementById(&apos;styleTag&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var sourceBoard = document.getElementById(&apos;sourceBoard&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &apos;\\/*大家好...今天我给大家做一个在线简历...\\/*&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var n = 0;</span><br><span class=\"line\">window.setInterval(function()&#123;</span><br><span class=\"line\">   n++;</span><br><span class=\"line\">   styleTag.innerHTML = str.substring(0,n);</span><br><span class=\"line\">    </span><br><span class=\"line\">   sourceBoard.innerHTML = str.substring(0,n);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,100);</span><br><span class=\"line\"></span><br><span class=\"line\">//此时，用户观看字符串轮番出现的同时，程序也已经向style标签吐了代码，这样，当用户看完一个CSS样式结束后，对应的样式可以立马通过浏览器渲染出来。</span><br></pre></td></tr></table></figure>\n<h2 id=\"Demo部署到GitHub详细过程\"><a href=\"#Demo部署到GitHub详细过程\" class=\"headerlink\" title=\" Demo部署到GitHub详细过程\"></a> Demo部署到GitHub详细过程</h2><p>本来还不知道Demo可以直接在Github上预览。。。直到发现这样的功能：</p>\n<figure class=\"image-box\">\n                <img src=\"http://img.blog.csdn.net/20180129220933667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjAyNjQ4OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"gh-pages预览项目\" title=\"\" class=\"\">\n                <p>gh-pages预览项目</p>\n            </figure>\n<p>在Demo的仓库里，点击Settings，然后找到GitHub Pages，设置源为master主分支（此项目只有一个分支，所以也没得选），点击Save保存，即可出现预览地址，一般保存后会稍有延迟。</p>\n<p>整个部署的环节大致如下：</p>\n<ol>\n<li><p>在本地的项目根目录下，<code>$ git init</code></p>\n</li>\n<li><p>加入当前所有文件到暂存区 <code>$ git add .</code>(后面有个“·”，代表全部文件)</p>\n</li>\n<li><p>连接远程仓库  <code>$ git remote add origin &quot;your repository address&quot;</code></p>\n</li>\n<li><p>提交所有文件到git版本控制系统 <code>$ git commit -m &quot;create Demo resume&quot;</code></p>\n</li>\n<li><p>push到你的远程仓库 <code>$ git push origin master</code></p>\n</li>\n<li><p>打开浏览器，进入这个目录的respository，点击settings,设置GitHub pages为 master,稍等片刻，即可预览。</p>\n<p>PS:学会这个骚操作，我把以前做的好多Demo都给部署了一遍，目前都可以预览，感谢GitHub</p>\n<h2 id=\"反思与不足\"><a href=\"#反思与不足\" class=\"headerlink\" title=\"反思与不足\"></a>反思与不足</h2></li>\n</ol>\n<ol>\n<li>在快速预览模式下，例如，将setInterval的间隔时间设为0，整个页面跑完，容易出现两个代码版的下拉滚动条“假死”,拉不动，但是将间隔时间设定为正常的90ms或者100ms，整个页面跑完没有任何问题。我初步总结的原因是，因为每次下拉的值是1000，这个下拉的动作很可能重复几百次，几千次。所以当间隔时间极小，重复次数极高，下拉值极大，那么这种现象就越容易出现。</li>\n</ol>\n<ol start=\"2\">\n<li><p>我在向一些前端前辈请教这个Demo的不足之处时，大神告诉我：面试官只关心页面上的信息，而不是如何呈现，更不能忍受长达200s的等待。这个Demo算是炫技，但是又没有什么核心的技术点，还不如老老实实的写一份干净清爽的简历实在。</p>\n<p>我的反思是，这个Demo由于大量的字符串以及转义字符拼接，因而没有像原作者：<a href=\"http://strml.net/\" target=\"_blank\" rel=\"noopener\">http://strml.net/</a>的页面那样，呈现的美轮美奂，这也是我在写Demo之初没有全局考虑的结果，导致现在如果加一些CSS代码，会带来极大的工作量。</p>\n</li>\n<li>整个页面没有加速或者暂停的功能，其实这个倒是简单，设置三个按钮：慢，中速，快速，在setInterval中的if里，对点击事件进行监听，一旦点击，就修改setInterval的时间间隔，然后return当前的n值。</li>\n</ol>\n<ol start=\"4\">\n<li>整个Demo代码过于混乱，没有进行封装，因为自己现在对面向对象还是有些手生，希望以后进行封装，以便提高运行效率，以及复用。</li>\n</ol>\n<p><b>觉得文章有用？点击下方打赏，鼓励作者更好的写作！</b></p>\n"},{"title":"谈一谈来北京后的工作节奏以及对前端的看法","date":"2018-05-23T14:12:52.000Z","reward":true,"comment":true,"_content":"本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/80427169)\n\n\n\n\n\n\n\n## 为什么来北京 ##\n这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。\n那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。\n下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。\n## 工作 ##\n因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。\n虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。\n想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。\n## 前端 ##\n别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。\n其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。\n两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于：\n\n - 熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。\n - 对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。\n - 对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等\n - 对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。\n - 能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。\n其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。\n其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。\n但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。\n## 生活 ##\n来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。\n在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。\n女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。\n最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。\n总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。\n很久没有写东西，思路比较乱，想到哪写到哪。\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>","source":"_posts/谈一谈来北京的工作节奏以及对前端的看法.md","raw":"---\ntitle:  谈一谈来北京后的工作节奏以及对前端的看法\ndate: 2018-05-23 22:12:52\ntags: [杂谈]\nreward: true #是否开启打赏功能\ncomment: true #是否开启评论功能\n---\n本文初始编辑地址，源自我的CSDN博客：[我的CSDN博客](https://blog.csdn.net/qq_20264891/article/details/80427169)\n\n\n\n\n\n\n\n## 为什么来北京 ##\n这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。\n那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。\n下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。\n## 工作 ##\n因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。\n虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。\n想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。\n## 前端 ##\n别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。\n其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。\n两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于：\n\n - 熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。\n - 对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。\n - 对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等\n - 对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。\n - 能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。\n其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。\n其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。\n但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。\n## 生活 ##\n来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。\n在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。\n女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。\n最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。\n总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。\n很久没有写东西，思路比较乱，想到哪写到哪。\n\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>","slug":"谈一谈来北京的工作节奏以及对前端的看法","published":1,"updated":"2018-08-29T08:54:17.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlewxdgk001pjgv4a2big5tb","content":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/80427169\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"为什么来北京\"><a href=\"#为什么来北京\" class=\"headerlink\" title=\"为什么来北京\"></a>为什么来北京</h2><p>这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。<br>那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。<br>下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。<br>虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。<br>想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。</p>\n<h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><p>别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。<br>其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。<br>两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于：</p>\n<ul>\n<li>熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。</li>\n<li>对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。</li>\n<li>对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等</li>\n<li>对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。</li>\n<li>能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。<br>其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。<br>其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。<br>但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2>来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。<br>在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。<br>女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。<br>最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。<br>总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。<br>很久没有写东西，思路比较乱，想到哪写到哪。</li>\n</ul>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>","site":{"data":{}},"excerpt":"","more":"<p>本文初始编辑地址，源自我的CSDN博客：<a href=\"https://blog.csdn.net/qq_20264891/article/details/80427169\" target=\"_blank\" rel=\"noopener\">我的CSDN博客</a></p>\n<h2 id=\"为什么来北京\"><a href=\"#为什么来北京\" class=\"headerlink\" title=\"为什么来北京\"></a>为什么来北京</h2><p>这个问题放在几个月之前，我肯定会踌躇满志的说：因为渴望技术，因为热爱coding（其实是因为贫穷）。<br>那时候一味的认为北京物价高，对应工资高是理所应当的。结果直到我住到沙河，才明白，北京的物价没有我想像的那么夸张，工作也没有我在兰州那样简单和无趣。粗略的一算，来北京已经将近三个月了，除了发际线有点不受控制，其他方面可以说一直在走上坡路。<br>下面，总结一下这三个月以来，关于工作，关于前端，关于生活方面的感悟和理解。</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>因为之前毕竟接到过腾讯和电信的面试邀请（但是因为太菜，挂了），所以信心满满，觉得自己也是前端界的人了。来北京找工作其实还是碰壁了很多次的，连续十几天，寄宿在我哥的出租屋里，每天早出晚归，一天面三家公司，无一例外都被发好人卡。几近心灰意冷的时候，才出现了转机。虽然现在在一个小公司里，但是也好歹算是稳定下来了。美中不足的是，误打误撞的进入了外包公司，每天基本上被业务填满，再加上住在沙河，明天上下班耗费我4个小时，晚上回家基本上学习一两个小时就要睡觉，没有大片空余的时间能够让我挥霍。<br>虽然进入外包公司，但是收入方面让我挺满意的，相比于在兰州，基本上翻了3，4番，而且加班还有加班工资（外包界清流）。所以大多数时候，我会在双休日主动加班。为了整取加班工资，我已经丧心病狂，用我的发际线去交换货币，或是满足自己的虚荣心，或是为了快速成长，或者两种心理皆存。<br>想了一想，自从大学遇见女朋友以后，我的工作一直在走上坡路，虽然在兰州的时候干的活简单，但是自己并没有松懈。现在拿的这个工资，勉强对得起自己去年一年的努力，但是还有不尽人意的地方。以后我得更加努力。</p>\n<h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><p>别看我博客里面写了很多看似高端的东西，其实很多并没有在实际的生产环节使用过。我的女朋友经常教导我，不要眼高手低，你虽然理论知识丰富，但是实际上手啥也不会，多做点项目，比啥都强。确实如此，在公司近乎两月的时间里，虽然没有在工程化方向迈进一步，但是好歹jQuery现在API用的十分熟练，也对一些比较常用的前端知识进行了实践。<br>其实我这种学渣，学历不够光鲜，脑子不够灵活，唯一支撑我信念的是不甘平庸的心。<br>两个月的时间里，虽然没有在深度方面前进，但是对于【前端工程师】的一些基本技能算是都过了一遍，这些技能包括但不限于：</p>\n<ul>\n<li>熟练地使用F12控制台去分析页面性能、请求结果、静态资源加载、调试等。</li>\n<li>对于前后端分离的项目进行实践，包括表单上传/文件上传，普通ajax请求，字段命名/接口约定等。</li>\n<li>对于一些团队协作工具上手操作，例如:GIT、SVN、GITLAB、石墨文档、WORKTITLE等等</li>\n<li>对于页面中一些常见Bug能快速定位，找到解决方案。例如：没有阻止冒泡导致事件重复执行、封装方法功能/逻辑解耦、重复数据过滤，HTTPS协议的页面请求HTTP协议的资源等等。</li>\n<li>能够快速上手一些简单的类库，例如layUi,ElementsUi,还有TRS系统，WCM系统等。<br>其实，前端领域确实很杂，我也非常的懊悔，这么晚才来北京，如果早点来，我可能比现在更加专业，更符合【工程师】这个头衔。我给自己顶下的目标是3年内进一线大厂。我明白自己已经不再年轻了，脑力比不过刚毕业的小鲜肉，体力尚可，但看着腰上的肥肉，又担心自己的身体日渐衰退。<br>其实我也蛮担心的，当时迫于生计，急需钱，没有思虑再三，进入外包公司，听说很多互联网企业一听外包的工作经验，都不愿意搭理。可能我更有体会吧，我做东西很愿意把时间花在细节上，但是做出来的产品就像在给别人家养娃，不是自己的，这或许就是我不愿意去外包公司的一个理由吧。每天被充实的业务需求填满，没有时间去思考如何做一个小而美的产品。<br>但是话又说回来了，企业是要生存的。产品是有生命周期的，不会像自己心爱的积木一样，可以翻来覆去每天把玩，每天都搭不同样式的摩天大楼。所以希望自己以后能够有点大局观，站在产品的角度去看待整个项目。<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2>来北京，确实感觉交通压力很大，每天出行就像打仗一样，用尽浑身解数才能上的了地铁。刚住沙河，上班的第一天，在沙河站等地铁，过去了4趟，硬是没有上去。。。后来学到了，反向坐到高教园比较容易上车（我真是太机智了）。<br>在工作之余，我会自己做做饭，打扫打扫房间，毕竟房子是租来的，生活是自己的。有的时候手很痒，很想弹弹琴，但是又告诉自己，年纪不小了，该攒钱了，没钱啥也干不了。<br>女朋友最近也抱怨，来北京，陪她聊天的时间越来越少，因为每天下班晚不说，回来我还得学习，或者有时候洗衣服，陪她的时间少之又少。突然很理解程序员为什么都没老婆了。。。<br>最近晚上在看Vue和js基础，北京这边公司要求VUE的比较多，对于ng，似乎只在电信才用。<br>总的来说，目前在北京，也算是勉强站住脚了，但是对于自己工作，还有一些需要改进的地方。对于程序员来说，时间和效率是最珍贵的财富，我目前甄需提高的就是自己的开发速度/效率，一方面需要自己不断的熟练技能，另一方面，需要去实际使用一些提升开发效率的工具，比如：WEBPACK、SASS，TypeScript等等，不能让这些学过的东西永远没有上手的机会。另外，对于工作中遇到的问题，一定要自己想方设法去解决（在不影响项目进度的前提下），实在搞不懂再开口问。<br>很久没有写东西，思路比较乱，想到哪写到哪。</li>\n</ul>\n<script type=\"text/javascript\">\nconst password = 'tycho';\nif(window.prompt('请输入密码')==password){\n\nalert('password success')\n\n}else{\nalert('password error');window.history.back(-1);\n}          \n</script>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjlewxdem0003jgv4991wroaq","tag_id":"cjlewxdeu0006jgv4x1e1vete","_id":"cjlewxdf6000djgv4aicwyo0q"},{"post_id":"cjlewxder0005jgv4qp2dypkf","tag_id":"cjlewxdf5000cjgv4ii31n0lx","_id":"cjlewxdfd000ijgv4qbjjv1wi"},{"post_id":"cjlewxdex0008jgv4vf3t617h","tag_id":"cjlewxdfb000gjgv4wbsn5qfz","_id":"cjlewxdfh000mjgv4mdzq8xhr"},{"post_id":"cjlewxdf2000ajgv4ov6cd24s","tag_id":"cjlewxdfb000gjgv4wbsn5qfz","_id":"cjlewxdfl000qjgv4ui341j1h"},{"post_id":"cjlewxdf4000bjgv4dwzw9zyi","tag_id":"cjlewxdfb000gjgv4wbsn5qfz","_id":"cjlewxdfp000ujgv4zjrh7jt9"},{"post_id":"cjlewxdf8000ejgv43vwvvj66","tag_id":"cjlewxdfn000sjgv4taxaz2ap","_id":"cjlewxdfs000yjgv4459vpoh0"},{"post_id":"cjlewxdfr000xjgv45vkx1x2u","tag_id":"cjlewxdf5000cjgv4ii31n0lx","_id":"cjlewxdfu0010jgv44jvszby3"},{"post_id":"cjlewxdfa000fjgv4971hf84q","tag_id":"cjlewxdfr000wjgv40n4kjinw","_id":"cjlewxdfw0013jgv4z39ewa1y"},{"post_id":"cjlewxdfc000hjgv44w2mxvbp","tag_id":"cjlewxdfr000wjgv40n4kjinw","_id":"cjlewxdg00017jgv45t0313ly"},{"post_id":"cjlewxdfd000jjgv4dh2clv7n","tag_id":"cjlewxdfz0016jgv4dppc3fi8","_id":"cjlewxdg5001cjgv4ukiwm1hk"},{"post_id":"cjlewxdff000ljgv4pdvsk8tr","tag_id":"cjlewxdg3001ajgv45v400nrf","_id":"cjlewxdgm001sjgv45tdegao2"},{"post_id":"cjlewxdff000ljgv4pdvsk8tr","tag_id":"cjlewxdg6001ejgv48t8m3pe1","_id":"cjlewxdgm001tjgv4uov76efj"},{"post_id":"cjlewxdff000ljgv4pdvsk8tr","tag_id":"cjlewxdga001hjgv4dz1iv4o0","_id":"cjlewxdgn001vjgv4qhw7vf7i"},{"post_id":"cjlewxdff000ljgv4pdvsk8tr","tag_id":"cjlewxdgf001ljgv48dwqpkxp","_id":"cjlewxdgn001wjgv43fzbv475"},{"post_id":"cjlewxdff000ljgv4pdvsk8tr","tag_id":"cjlewxdgj001ojgv49fwp92rx","_id":"cjlewxdgo001yjgv41we6mxmb"},{"post_id":"cjlewxdff000ljgv4pdvsk8tr","tag_id":"cjlewxdgl001qjgv4k2j0p3a5","_id":"cjlewxdgo001zjgv4de1uhezd"},{"post_id":"cjlewxdfi000njgv4k1jaukww","tag_id":"cjlewxdgl001rjgv4oan3shyy","_id":"cjlewxdgo0021jgv4sbenod8c"},{"post_id":"cjlewxdfk000pjgv4mkqxnrgs","tag_id":"cjlewxdgm001ujgv4evp1iv9d","_id":"cjlewxdgp0022jgv41b35fa16"},{"post_id":"cjlewxdfk000pjgv4mkqxnrgs","tag_id":"cjlewxdgn001xjgv4bjfv7g1t","_id":"cjlewxdgp0023jgv4z34j3ktj"},{"post_id":"cjlewxdfl000rjgv4c9c4sltv","tag_id":"cjlewxdgo0020jgv4a68szabz","_id":"cjlewxdgq0025jgv4ej7b4lbr"},{"post_id":"cjlewxdfo000tjgv4y2ai2uxn","tag_id":"cjlewxdgp0024jgv44pfvwfr9","_id":"cjlewxdgr0027jgv455dubgpn"},{"post_id":"cjlewxdfp000vjgv4n3ht3xsw","tag_id":"cjlewxdgq0026jgv4d10x575c","_id":"cjlewxdgs0029jgv4gxr6orqm"},{"post_id":"cjlewxdft000zjgv4tt5zrqss","tag_id":"cjlewxdgr0028jgv458uiobjb","_id":"cjlewxdgs002bjgv44jd0nzn0"},{"post_id":"cjlewxdfv0011jgv4u3raqk7b","tag_id":"cjlewxdgs002ajgv4n288u5fg","_id":"cjlewxdgt002djgv4g201nob9"},{"post_id":"cjlewxdfx0014jgv4avx9cqd4","tag_id":"cjlewxdgn001xjgv4bjfv7g1t","_id":"cjlewxdgv002gjgv4demvo8kc"},{"post_id":"cjlewxdfx0014jgv4avx9cqd4","tag_id":"cjlewxdgu002ejgv438e3xrk5","_id":"cjlewxdgv002hjgv498vpwkks"},{"post_id":"cjlewxdfy0015jgv467b4eb01","tag_id":"cjlewxdgv002fjgv4o349gzw8","_id":"cjlewxdgx002jjgv4t2twxou6"},{"post_id":"cjlewxdg00018jgv4j749r9bz","tag_id":"cjlewxdgw002ijgv49oeh2e59","_id":"cjlewxdh0002ojgv4xl7zunql"},{"post_id":"cjlewxdg00018jgv4j749r9bz","tag_id":"cjlewxdgx002kjgv4emg3ni7t","_id":"cjlewxdh0002pjgv4gmi2zupt"},{"post_id":"cjlewxdg00018jgv4j749r9bz","tag_id":"cjlewxdgn001xjgv4bjfv7g1t","_id":"cjlewxdh0002rjgv4d046te4v"},{"post_id":"cjlewxdg00018jgv4j749r9bz","tag_id":"cjlewxdgz002mjgv4b66euqy8","_id":"cjlewxdh1002sjgv4r6slx34d"},{"post_id":"cjlewxdg20019jgv4f3j66e7w","tag_id":"cjlewxdgz002njgv4yhu0f0ha","_id":"cjlewxdh1002ujgv4r8h4ww9n"},{"post_id":"cjlewxdg20019jgv4f3j66e7w","tag_id":"cjlewxdh0002qjgv4azc29alc","_id":"cjlewxdh2002vjgv48h8d6f59"},{"post_id":"cjlewxdg4001bjgv44ghdnayd","tag_id":"cjlewxdgs002ajgv4n288u5fg","_id":"cjlewxdh2002xjgv4qaae4llh"},{"post_id":"cjlewxdg5001djgv4hjp6b5r2","tag_id":"cjlewxdh2002wjgv42feouis1","_id":"cjlewxdh3002zjgv4t2jdo2ls"},{"post_id":"cjlewxdg7001fjgv452x1062y","tag_id":"cjlewxdh2002yjgv4nswswety","_id":"cjlewxdh30031jgv4v79s2g3p"},{"post_id":"cjlewxdg8001gjgv4x0fclvcp","tag_id":"cjlewxdgn001xjgv4bjfv7g1t","_id":"cjlewxdh40033jgv4dd7jree0"},{"post_id":"cjlewxdga001ijgv43o8w807v","tag_id":"cjlewxdh40032jgv43v7ljorc","_id":"cjlewxdh50036jgv48rw8ga06"},{"post_id":"cjlewxdga001ijgv43o8w807v","tag_id":"cjlewxdh40034jgv4mp2hkikv","_id":"cjlewxdh50037jgv4ass529mv"},{"post_id":"cjlewxdgc001jjgv40c94qgls","tag_id":"cjlewxdh50035jgv40munan0x","_id":"cjlewxdh60039jgv4qzyy5vvu"},{"post_id":"cjlewxdge001kjgv4210u73bg","tag_id":"cjlewxdh60038jgv4pvv3u48f","_id":"cjlewxdh8003fjgv46fe0grli"},{"post_id":"cjlewxdge001kjgv4210u73bg","tag_id":"cjlewxdh6003ajgv48uwe93aa","_id":"cjlewxdh8003gjgv47xa1lpl9"},{"post_id":"cjlewxdge001kjgv4210u73bg","tag_id":"cjlewxdgn001xjgv4bjfv7g1t","_id":"cjlewxdh9003ijgv4vjdlepmp"},{"post_id":"cjlewxdge001kjgv4210u73bg","tag_id":"cjlewxdh7003cjgv4ysx0qy45","_id":"cjlewxdh9003jjgv4cjjywv25"},{"post_id":"cjlewxdge001kjgv4210u73bg","tag_id":"cjlewxdf5000cjgv4ii31n0lx","_id":"cjlewxdh9003ljgv41qo2mwhu"},{"post_id":"cjlewxdge001kjgv4210u73bg","tag_id":"cjlewxdh7003djgv4cgfuithx","_id":"cjlewxdha003mjgv4h5pnmi3e"},{"post_id":"cjlewxdgg001mjgv41x465jxv","tag_id":"cjlewxdh8003ejgv4xarry3tw","_id":"cjlewxdhc003qjgv4z36vmqd8"},{"post_id":"cjlewxdgg001mjgv41x465jxv","tag_id":"cjlewxdh8003hjgv4tgrx2g7u","_id":"cjlewxdhc003rjgv4fmaxjruq"},{"post_id":"cjlewxdgg001mjgv41x465jxv","tag_id":"cjlewxdgn001xjgv4bjfv7g1t","_id":"cjlewxdhd003tjgv4i8ocp9xj"},{"post_id":"cjlewxdgg001mjgv41x465jxv","tag_id":"cjlewxdh7003djgv4cgfuithx","_id":"cjlewxdhd003ujgv4hiayya42"},{"post_id":"cjlewxdgg001mjgv41x465jxv","tag_id":"cjlewxdhb003ojgv436gn5wc4","_id":"cjlewxdhd003wjgv4l4t106xk"},{"post_id":"cjlewxdgi001njgv4l6jo2b6o","tag_id":"cjlewxdhb003pjgv4eodsog5n","_id":"cjlewxdhe003xjgv4w4elkeax"},{"post_id":"cjlewxdgi001njgv4l6jo2b6o","tag_id":"cjlewxdhc003sjgv4xqp4uf7m","_id":"cjlewxdhe003yjgv44ju0wy62"},{"post_id":"cjlewxdgk001pjgv4a2big5tb","tag_id":"cjlewxdhd003vjgv43yjp3pol","_id":"cjlewxdhe003zjgv4kgm09hyx"}],"Tag":[{"name":"腾讯SNG-IMWeb面试","_id":"cjlewxdeu0006jgv4x1e1vete"},{"name":"ajax","_id":"cjlewxdf5000cjgv4ii31n0lx"},{"name":"angularjs","_id":"cjlewxdfb000gjgv4wbsn5qfz"},{"name":"Express","_id":"cjlewxdfn000sjgv4taxaz2ap"},{"name":"git","_id":"cjlewxdfr000wjgv40n4kjinw"},{"name":"html5","_id":"cjlewxdfz0016jgv4dppc3fi8"},{"name":"android","_id":"cjlewxdg3001ajgv45v400nrf"},{"name":"SDK","_id":"cjlewxdg6001ejgv48t8m3pe1"},{"name":"JDK","_id":"cjlewxdga001hjgv4dz1iv4o0"},{"name":"APP","_id":"cjlewxdgf001ljgv48dwqpkxp"},{"name":"IONIC","_id":"cjlewxdgj001ojgv49fwp92rx"},{"name":"gradle","_id":"cjlewxdgl001qjgv4k2j0p3a5"},{"name":"算法","_id":"cjlewxdgl001rjgv4oan3shyy"},{"name":"node","_id":"cjlewxdgm001ujgv4evp1iv9d"},{"name":"javascript","_id":"cjlewxdgn001xjgv4bjfv7g1t"},{"name":"nodejs","_id":"cjlewxdgo0020jgv4a68szabz"},{"name":"php","_id":"cjlewxdgp0024jgv44pfvwfr9"},{"name":"Webpack","_id":"cjlewxdgq0026jgv4d10x575c"},{"name":"http","_id":"cjlewxdgr0028jgv458uiobjb"},{"name":"css3","_id":"cjlewxdgs002ajgv4n288u5fg"},{"name":"plug-in","_id":"cjlewxdgu002ejgv438e3xrk5"},{"name":"angular","_id":"cjlewxdgv002fjgv4o349gzw8"},{"name":"typescript","_id":"cjlewxdgw002ijgv49oeh2e59"},{"name":"编译","_id":"cjlewxdgx002kjgv4emg3ni7t"},{"name":"工具","_id":"cjlewxdgz002mjgv4b66euqy8"},{"name":"Travis-CI","_id":"cjlewxdgz002njgv4yhu0f0ha"},{"name":"Hexo","_id":"cjlewxdh0002qjgv4azc29alc"},{"name":"jquery","_id":"cjlewxdh2002wjgv42feouis1"},{"name":"百度share","_id":"cjlewxdh2002yjgv4nswswety"},{"name":"HEXO","_id":"cjlewxdh40032jgv43v7ljorc"},{"name":"动态部署","_id":"cjlewxdh40034jgv4mp2hkikv"},{"name":"bootstrap","_id":"cjlewxdh50035jgv40munan0x"},{"name":"腾讯","_id":"cjlewxdh60038jgv4pvv3u48f"},{"name":"面试","_id":"cjlewxdh6003ajgv48uwe93aa"},{"name":"浏览器兼容","_id":"cjlewxdh7003cjgv4ysx0qy45"},{"name":"原理","_id":"cjlewxdh7003djgv4cgfuithx"},{"name":"重绘","_id":"cjlewxdh8003ejgv4xarry3tw"},{"name":"冲排","_id":"cjlewxdh8003hjgv4tgrx2g7u"},{"name":"腾讯面试","_id":"cjlewxdhb003ojgv436gn5wc4"},{"name":"动态简历","_id":"cjlewxdhb003pjgv4eodsog5n"},{"name":"Github部署","_id":"cjlewxdhc003sjgv4xqp4uf7m"},{"name":"杂谈","_id":"cjlewxdhd003vjgv43yjp3pol"}]}}